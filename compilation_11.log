Processing: defmacro
Processing: inductive
Processing: inductive
Processing: def
Processing def: add with type: Syntax { kind: List([Syntax { kind: Symbol("pi"), span: Span { start: 236, end: 238, line: 16, col: 10 }, scopes: [] }, Syntax { kind: Symbol("n"), span: Span { start: 239, end: 240, line: 16, col: 13 }, scopes: [] }, Syntax { kind: Symbol("Nat"), span: Span { start: 241, end: 244, line: 16, col: 15 }, scopes: [] }, Syntax { kind: List([Syntax { kind: Symbol("pi"), span: Span { start: 246, end: 248, line: 16, col: 20 }, scopes: [] }, Syntax { kind: Symbol("m"), span: Span { start: 249, end: 250, line: 16, col: 23 }, scopes: [] }, Syntax { kind: Symbol("Nat"), span: Span { start: 251, end: 254, line: 16, col: 25 }, scopes: [] }, Syntax { kind: Symbol("Nat"), span: Span { start: 255, end: 258, line: 16, col: 29 }, scopes: [] }]), span: Span { start: 245, end: 259, line: 16, col: 19 }, scopes: [] }]), span: Span { start: 235, end: 260, line: 16, col: 9 }, scopes: [] }
Resolved def: succ
Check Def add: ty_core=Pi(Ind("Nat", []), Pi(Ind("Nat", []), Ind("Nat", []))) val_core=Lam(Ind("Nat", []), Lam(Ind("Nat", []), App(App(App(App(Rec("Nat", []), Lam(Ind("Nat", []), Ind("Nat", []))), Var(0)), Lam(Ind("Nat", []), Lam(App(Lam(Ind("Nat", []), Ind("Nat", [])), Var(0)), App(Const("succ", []), Var(0))))), Var(1))))
Processing: def
Processing def: not with type: Syntax { kind: List([Syntax { kind: Symbol("pi"), span: Span { start: 413, end: 415, line: 27, col: 10 }, scopes: [] }, Syntax { kind: Symbol("b"), span: Span { start: 416, end: 417, line: 27, col: 13 }, scopes: [] }, Syntax { kind: Symbol("Bool"), span: Span { start: 418, end: 422, line: 27, col: 15 }, scopes: [] }, Syntax { kind: Symbol("Bool"), span: Span { start: 423, end: 427, line: 27, col: 20 }, scopes: [] }]), span: Span { start: 412, end: 428, line: 27, col: 9 }, scopes: [] }
Resolved def: false
Resolved def: true
Check Def not: ty_core=Pi(Ind("Bool", []), Ind("Bool", [])) val_core=Lam(Ind("Bool", []), App(App(App(App(Rec("Bool", []), Lam(Ind("Bool", []), Ind("Bool", []))), Const("false", [])), Const("true", [])), Var(0)))
Processing: def
Processing def: if_nat with type: Syntax { kind: List([Syntax { kind: Symbol("pi"), span: Span { start: 539, end: 541, line: 36, col: 13 }, scopes: [] }, Syntax { kind: Symbol("c"), span: Span { start: 542, end: 543, line: 36, col: 16 }, scopes: [] }, Syntax { kind: Symbol("Bool"), span: Span { start: 544, end: 548, line: 36, col: 18 }, scopes: [] }, Syntax { kind: List([Syntax { kind: Symbol("pi"), span: Span { start: 550, end: 552, line: 36, col: 24 }, scopes: [] }, Syntax { kind: Symbol("t"), span: Span { start: 553, end: 554, line: 36, col: 27 }, scopes: [] }, Syntax { kind: Symbol("Nat"), span: Span { start: 555, end: 558, line: 36, col: 29 }, scopes: [] }, Syntax { kind: List([Syntax { kind: Symbol("pi"), span: Span { start: 560, end: 562, line: 36, col: 34 }, scopes: [] }, Syntax { kind: Symbol("f"), span: Span { start: 563, end: 564, line: 36, col: 37 }, scopes: [] }, Syntax { kind: Symbol("Nat"), span: Span { start: 565, end: 568, line: 36, col: 39 }, scopes: [] }, Syntax { kind: Symbol("Nat"), span: Span { start: 569, end: 572, line: 36, col: 43 }, scopes: [] }]), span: Span { start: 559, end: 573, line: 36, col: 33 }, scopes: [] }]), span: Span { start: 549, end: 574, line: 36, col: 23 }, scopes: [] }]), span: Span { start: 538, end: 575, line: 36, col: 12 }, scopes: [] }
Check Def if_nat: ty_core=Pi(Ind("Bool", []), Pi(Ind("Nat", []), Pi(Ind("Nat", []), Ind("Nat", [])))) val_core=Lam(Ind("Bool", []), Lam(Ind("Nat", []), Lam(Ind("Nat", []), App(App(App(App(Rec("Bool", []), Lam(Ind("Bool", []), Ind("Nat", []))), Var(1)), Var(0)), Var(2)))))
Processing: def
Processing def: and with type: Syntax { kind: List([Syntax { kind: Symbol("pi"), span: Span { start: 737, end: 739, line: 49, col: 10 }, scopes: [] }, Syntax { kind: Symbol("a"), span: Span { start: 740, end: 741, line: 49, col: 13 }, scopes: [] }, Syntax { kind: Symbol("Bool"), span: Span { start: 742, end: 746, line: 49, col: 15 }, scopes: [] }, Syntax { kind: List([Syntax { kind: Symbol("pi"), span: Span { start: 748, end: 750, line: 49, col: 21 }, scopes: [] }, Syntax { kind: Symbol("b"), span: Span { start: 751, end: 752, line: 49, col: 24 }, scopes: [] }, Syntax { kind: Symbol("Bool"), span: Span { start: 753, end: 757, line: 49, col: 26 }, scopes: [] }, Syntax { kind: Symbol("Bool"), span: Span { start: 758, end: 762, line: 49, col: 31 }, scopes: [] }]), span: Span { start: 747, end: 763, line: 49, col: 20 }, scopes: [] }]), span: Span { start: 736, end: 764, line: 49, col: 9 }, scopes: [] }
Resolved def: false
Check Def and: ty_core=Pi(Ind("Bool", []), Pi(Ind("Bool", []), Ind("Bool", []))) val_core=Lam(Ind("Bool", []), Lam(Ind("Bool", []), App(App(App(App(Rec("Bool", []), Lam(Ind("Bool", []), Ind("Bool", []))), Var(0)), Const("false", [])), Var(1))))
Processing: def
Processing def: or with type: Syntax { kind: List([Syntax { kind: Symbol("pi"), span: Span { start: 898, end: 900, line: 60, col: 9 }, scopes: [] }, Syntax { kind: Symbol("a"), span: Span { start: 901, end: 902, line: 60, col: 12 }, scopes: [] }, Syntax { kind: Symbol("Bool"), span: Span { start: 903, end: 907, line: 60, col: 14 }, scopes: [] }, Syntax { kind: List([Syntax { kind: Symbol("pi"), span: Span { start: 909, end: 911, line: 60, col: 20 }, scopes: [] }, Syntax { kind: Symbol("b"), span: Span { start: 912, end: 913, line: 60, col: 23 }, scopes: [] }, Syntax { kind: Symbol("Bool"), span: Span { start: 914, end: 918, line: 60, col: 25 }, scopes: [] }, Syntax { kind: Symbol("Bool"), span: Span { start: 919, end: 923, line: 60, col: 30 }, scopes: [] }]), span: Span { start: 908, end: 924, line: 60, col: 19 }, scopes: [] }]), span: Span { start: 897, end: 925, line: 60, col: 8 }, scopes: [] }
Resolved def: true
Check Def or: ty_core=Pi(Ind("Bool", []), Pi(Ind("Bool", []), Ind("Bool", []))) val_core=Lam(Ind("Bool", []), Lam(Ind("Bool", []), App(App(App(App(Rec("Bool", []), Lam(Ind("Bool", []), Ind("Bool", []))), Const("true", [])), Var(0)), Var(1))))
Processing: inductive
Processing: inductive
Processing: def
Processing def: getBox with type: Syntax { kind: List([Syntax { kind: Symbol("pi"), span: Span { start: 69, end: 71, line: 4, col: 13 }, scopes: [] }, Syntax { kind: Symbol("b"), span: Span { start: 72, end: 73, line: 4, col: 16 }, scopes: [] }, Syntax { kind: Symbol("MyBox"), span: Span { start: 74, end: 79, line: 4, col: 18 }, scopes: [] }, Syntax { kind: Symbol("Nat"), span: Span { start: 80, end: 83, line: 4, col: 24 }, scopes: [] }]), span: Span { start: 68, end: 84, line: 4, col: 12 }, scopes: [] }
Check Def getBox: ty_core=Pi(Ind("MyBox", []), Ind("Nat", [])) val_core=Lam(Ind("MyBox", []), App(App(App(Rec("MyBox", []), Lam(Ind("MyBox", []), Ind("Nat", []))), Lam(Ind("Nat", []), Var(0))), Var(0)))
Processing: def
Processing def: res1 with type: Syntax { kind: Symbol("Nat"), span: Span { start: 165, end: 168, line: 12, col: 10 }, scopes: [] }
Resolved def: getBox
Resolved def: mkBox
Resolved def: succ
Resolved def: zero
Check Def res1: ty_core=Ind("Nat", []) val_core=App(Const("getBox", []), App(Const("mkBox", []), App(Const("succ", []), Const("zero", []))))
Processing: inductive
Processing: def
Processing def: toNat with type: Syntax { kind: List([Syntax { kind: Symbol("pi"), span: Span { start: 293, end: 295, line: 18, col: 12 }, scopes: [] }, Syntax { kind: Symbol("m"), span: Span { start: 296, end: 297, line: 18, col: 15 }, scopes: [] }, Syntax { kind: Symbol("MyNat"), span: Span { start: 298, end: 303, line: 18, col: 17 }, scopes: [] }, Syntax { kind: Symbol("Nat"), span: Span { start: 304, end: 307, line: 18, col: 23 }, scopes: [] }]), span: Span { start: 292, end: 308, line: 18, col: 11 }, scopes: [] }
Resolved def: zero
Resolved def: succ
Check Def toNat: ty_core=Pi(Ind("MyNat", []), Ind("Nat", [])) val_core=Lam(Ind("MyNat", []), App(App(App(App(Rec("MyNat", []), Lam(Ind("MyNat", []), Ind("Nat", []))), Const("zero", [])), Lam(Ind("MyNat", []), Lam(App(Lam(Ind("MyNat", []), Ind("Nat", [])), Var(0)), App(Const("succ", []), Var(0))))), Var(0)))
Processing: def
Processing def: res2 with type: Syntax { kind: Symbol("Nat"), span: Span { start: 428, end: 431, line: 27, col: 10 }, scopes: [] }
Resolved def: toNat
Resolved def: mysucc
Resolved def: mysucc
Resolved def: myzero
Check Def res2: ty_core=Ind("Nat", []) val_core=App(Const("toNat", []), App(Const("mysucc", []), App(Const("mysucc", []), Const("myzero", []))))
Resolved def: res1
Resolved def: res2
Compiling build/output.rs to generic_test...
warning: hard linking files in the incremental compilation cache failed. copying files instead. consider moving the cache directory to a file system which supports hard linking in session dir `/Volumes/Crucial X6/MacBook/Code/leanrustlisp/build/incremental/output-2wsjtpnx8bt2e/s-hfc5pu9dd2-1jvuhz8-working`

warning: failed to garbage collect finalized incremental compilation session directory `/Volumes/Crucial X6/MacBook/Code/leanrustlisp/build/incremental/output-2wsjtpnx8bt2e/s-hfbvq37umc-im8rpw-4y8x6dw0il5aykgh42d05diai`: No such file or directory (os error 2)

warning: failed to garbage collect finalized incremental compilation session directory `/Volumes/Crucial X6/MacBook/Code/leanrustlisp/build/incremental/output-2wsjtpnx8bt2e/s-hfbvr7iv9n-85c0vt-6oj73qd2oyf6rlxghtnz2snbi`: No such file or directory (os error 2)

warning: failed to garbage collect finalized incremental compilation session directory `/Volumes/Crucial X6/MacBook/Code/leanrustlisp/build/incremental/output-2wsjtpnx8bt2e/s-hfbvqn46o3-7w0xxg-4y8x6dw0il5aykgh42d05diai`: No such file or directory (os error 2)

warning: unnecessary braces around block return value
   --> output.rs:166:1
    |
166 | { Value::Func(Rc::new(move |x_0: Value| { { let x_0 = x_0.clone(); Value::Func(Rc::new(move |x_1: Value| { (match (match (match (match Value::Func(Rc::new(rec_nat_entry)) { Value::Func(f) => f({ let x_0 = x_0.clone(); let x_1 = x_1.clone(); Value::Func(Rc::new(move |x_2: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_1.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f({ let x_0 = x_0.clone(); let x_1 = x_1.clone(); Value::Func(Rc::new(move |x_3: Value| { { let x_0 = x_0.clone(); let x_1 = x_1.clone(); let x_3 = x_3.clone(); Value::Func(Rc::new(move |x_4: Value| { (match succ() { Value::Func(f) => f(x_4.clone()), _ => panic!("Expected Func") }) })) } })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_0.clone()), _ => panic!("Expected Func") }) })) } })) }
    | ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^^
    |
    = note: `#[warn(unused_braces)]` on by default
help: remove these braces
    |
166 - { Value::Func(Rc::new(move |x_0: Value| { { let x_0 = x_0.clone(); Value::Func(Rc::new(move |x_1: Value| { (match (match (match (match Value::Func(Rc::new(rec_nat_entry)) { Value::Func(f) => f({ let x_0 = x_0.clone(); let x_1 = x_1.clone(); Value::Func(Rc::new(move |x_2: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_1.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f({ let x_0 = x_0.clone(); let x_1 = x_1.clone(); Value::Func(Rc::new(move |x_3: Value| { { let x_0 = x_0.clone(); let x_1 = x_1.clone(); let x_3 = x_3.clone(); Value::Func(Rc::new(move |x_4: Value| { (match succ() { Value::Func(f) => f(x_4.clone()), _ => panic!("Expected Func") }) })) } })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_0.clone()), _ => panic!("Expected Func") }) })) } })) }
166 + Value::Func(Rc::new(move |x_0: Value| { { let x_0 = x_0.clone(); Value::Func(Rc::new(move |x_1: Value| { (match (match (match (match Value::Func(Rc::new(rec_nat_entry)) { Value::Func(f) => f({ let x_0 = x_0.clone(); let x_1 = x_1.clone(); Value::Func(Rc::new(move |x_2: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_1.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f({ let x_0 = x_0.clone(); let x_1 = x_1.clone(); Value::Func(Rc::new(move |x_3: Value| { { let x_0 = x_0.clone(); let x_1 = x_1.clone(); let x_3 = x_3.clone(); Value::Func(Rc::new(move |x_4: Value| { (match succ() { Value::Func(f) => f(x_4.clone()), _ => panic!("Expected Func") }) })) } })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_0.clone()), _ => panic!("Expected Func") }) })) } }))
    |

warning: unnecessary braces around block return value
   --> output.rs:169:1
    |
169 | { Value::Func(Rc::new(move |x_5: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_5 = x_5.clone(); Value::Func(Rc::new(move |x_6: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#false()), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#true()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_5.clone()), _ => panic!("Expected Func") }) })) }
    | ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^^
    |
help: remove these braces
    |
169 - { Value::Func(Rc::new(move |x_5: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_5 = x_5.clone(); Value::Func(Rc::new(move |x_6: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#false()), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#true()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_5.clone()), _ => panic!("Expected Func") }) })) }
169 + Value::Func(Rc::new(move |x_5: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_5 = x_5.clone(); Value::Func(Rc::new(move |x_6: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#false()), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#true()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_5.clone()), _ => panic!("Expected Func") }) }))
    |

warning: unnecessary braces around block return value
   --> output.rs:172:1
    |
172 | { Value::Func(Rc::new(move |x_7: Value| { { let x_7 = x_7.clone(); Value::Func(Rc::new(move |x_8: Value| { { let x_7 = x_7.clone(); let x_8 = x_8.clone(); Value::Func(Rc::new(move |x_9: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_7 = x_7.clone(); let x_8 = x_8.clone(); let x_9 = x_9.clone(); Value::Func(Rc::new(move |x_10: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_8.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_9.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_7.clone()), _ => panic!("Expected Func") }) })) } })) } })) }
    | ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^^
    |
help: remove these braces
    |
172 - { Value::Func(Rc::new(move |x_7: Value| { { let x_7 = x_7.clone(); Value::Func(Rc::new(move |x_8: Value| { { let x_7 = x_7.clone(); let x_8 = x_8.clone(); Value::Func(Rc::new(move |x_9: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_7 = x_7.clone(); let x_8 = x_8.clone(); let x_9 = x_9.clone(); Value::Func(Rc::new(move |x_10: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_8.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_9.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_7.clone()), _ => panic!("Expected Func") }) })) } })) } })) }
172 + Value::Func(Rc::new(move |x_7: Value| { { let x_7 = x_7.clone(); Value::Func(Rc::new(move |x_8: Value| { { let x_7 = x_7.clone(); let x_8 = x_8.clone(); Value::Func(Rc::new(move |x_9: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_7 = x_7.clone(); let x_8 = x_8.clone(); let x_9 = x_9.clone(); Value::Func(Rc::new(move |x_10: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_8.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_9.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_7.clone()), _ => panic!("Expected Func") }) })) } })) } }))
    |

warning: unnecessary braces around block return value
   --> output.rs:175:1
    |
175 | { Value::Func(Rc::new(move |x_11: Value| { { let x_11 = x_11.clone(); Value::Func(Rc::new(move |x_12: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_11 = x_11.clone(); let x_12 = x_12.clone(); Value::Func(Rc::new(move |x_13: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_12.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#false()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_11.clone()), _ => panic!("Expected Func") }) })) } })) }
    | ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^^
    |
help: remove these braces
    |
175 - { Value::Func(Rc::new(move |x_11: Value| { { let x_11 = x_11.clone(); Value::Func(Rc::new(move |x_12: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_11 = x_11.clone(); let x_12 = x_12.clone(); Value::Func(Rc::new(move |x_13: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_12.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#false()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_11.clone()), _ => panic!("Expected Func") }) })) } })) }
175 + Value::Func(Rc::new(move |x_11: Value| { { let x_11 = x_11.clone(); Value::Func(Rc::new(move |x_12: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_11 = x_11.clone(); let x_12 = x_12.clone(); Value::Func(Rc::new(move |x_13: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_12.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#false()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_11.clone()), _ => panic!("Expected Func") }) })) } }))
    |

warning: unnecessary braces around block return value
   --> output.rs:178:1
    |
178 | { Value::Func(Rc::new(move |x_14: Value| { { let x_14 = x_14.clone(); Value::Func(Rc::new(move |x_15: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_14 = x_14.clone(); let x_15 = x_15.clone(); Value::Func(Rc::new(move |x_16: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#true()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_15.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_14.clone()), _ => panic!("Expected Func") }) })) } })) }
    | ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^^
    |
help: remove these braces
    |
178 - { Value::Func(Rc::new(move |x_14: Value| { { let x_14 = x_14.clone(); Value::Func(Rc::new(move |x_15: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_14 = x_14.clone(); let x_15 = x_15.clone(); Value::Func(Rc::new(move |x_16: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#true()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_15.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_14.clone()), _ => panic!("Expected Func") }) })) } })) }
178 + Value::Func(Rc::new(move |x_14: Value| { { let x_14 = x_14.clone(); Value::Func(Rc::new(move |x_15: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_14 = x_14.clone(); let x_15 = x_15.clone(); Value::Func(Rc::new(move |x_16: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#true()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_15.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_14.clone()), _ => panic!("Expected Func") }) })) } }))
    |

warning: unnecessary braces around block return value
   --> output.rs:190:1
    |
190 | { Value::Func(Rc::new(move |x_17: Value| { (match (match (match Value::Func(Rc::new(rec_MyBox_entry)) { Value::Func(f) => f({ let x_17 = x_17.clone(); Value::Func(Rc::new(move |x_18: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f({ let x_17 = x_17.clone(); Value::Func(Rc::new(move |x_19: Value| { x_19.clone() })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_17.clone()), _ => panic!("Expected Func") }) })) }
    | ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^^
    |
help: remove these braces
    |
190 - { Value::Func(Rc::new(move |x_17: Value| { (match (match (match Value::Func(Rc::new(rec_MyBox_entry)) { Value::Func(f) => f({ let x_17 = x_17.clone(); Value::Func(Rc::new(move |x_18: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f({ let x_17 = x_17.clone(); Value::Func(Rc::new(move |x_19: Value| { x_19.clone() })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_17.clone()), _ => panic!("Expected Func") }) })) }
190 + Value::Func(Rc::new(move |x_17: Value| { (match (match (match Value::Func(Rc::new(rec_MyBox_entry)) { Value::Func(f) => f({ let x_17 = x_17.clone(); Value::Func(Rc::new(move |x_18: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f({ let x_17 = x_17.clone(); Value::Func(Rc::new(move |x_19: Value| { x_19.clone() })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_17.clone()), _ => panic!("Expected Func") }) }))
    |

warning: unnecessary braces around block return value
   --> output.rs:202:1
    |
202 | { Value::Func(Rc::new(move |x_20: Value| { (match (match (match (match Value::Func(Rc::new(rec_MyNat_entry)) { Value::Func(f) => f({ let x_20 = x_20.clone(); Value::Func(Rc::new(move |x_21: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(zero()), _ => panic!("Expected Func") }) { Value::Func(f) => f({ let x_20 = x_20.clone(); Value::Func(Rc::new(move |x_22: Value| { { let x_20 = x_20.clone(); let x_22 = x_22.clone(); Value::Func(Rc::new(move |x_23: Value| { (match succ() { Value::Func(f) => f(x_23.clone()), _ => panic!("Expected Func") }) })) } })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_20.clone()), _ => panic!("Expected Func") }) })) }
    | ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^^
    |
help: remove these braces
    |
202 - { Value::Func(Rc::new(move |x_20: Value| { (match (match (match (match Value::Func(Rc::new(rec_MyNat_entry)) { Value::Func(f) => f({ let x_20 = x_20.clone(); Value::Func(Rc::new(move |x_21: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(zero()), _ => panic!("Expected Func") }) { Value::Func(f) => f({ let x_20 = x_20.clone(); Value::Func(Rc::new(move |x_22: Value| { { let x_20 = x_20.clone(); let x_22 = x_22.clone(); Value::Func(Rc::new(move |x_23: Value| { (match succ() { Value::Func(f) => f(x_23.clone()), _ => panic!("Expected Func") }) })) } })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_20.clone()), _ => panic!("Expected Func") }) })) }
202 + Value::Func(Rc::new(move |x_20: Value| { (match (match (match (match Value::Func(Rc::new(rec_MyNat_entry)) { Value::Func(f) => f({ let x_20 = x_20.clone(); Value::Func(Rc::new(move |x_21: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(zero()), _ => panic!("Expected Func") }) { Value::Func(f) => f({ let x_20 = x_20.clone(); Value::Func(Rc::new(move |x_22: Value| { { let x_20 = x_20.clone(); let x_22 = x_22.clone(); Value::Func(Rc::new(move |x_23: Value| { (match succ() { Value::Func(f) => f(x_23.clone()), _ => panic!("Expected Func") }) })) } })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_20.clone()), _ => panic!("Expected Func") }) }))
    |

warning: variable does not need to be mutable
   --> output.rs:262:25
    |
262 |                     let mut curr_fn = arg_1.clone();
    |                         ----^^^^^^^
    |                         |
    |                         help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: variable `T_val` should have a snake case name
   --> output.rs:101:19
    |
101 | fn rec_list_entry(T_val: Value) -> Value {
    |                   ^^^^^ help: convert the identifier to snake case: `t_val`
    |
    = note: `#[warn(non_snake_case)]` on by default

warning: variable `_M` should have a snake case name
   --> output.rs:102:31
    |
102 |     Value::Func(Rc::new(move |_M| {
    |                               ^^ help: convert the identifier to snake case: `_m`

warning: variable `T_val` should have a snake case name
   --> output.rs:103:13
    |
103 |         let T_val = T_val.clone();
    |             ^^^^^ help: convert the identifier to snake case: `t_val`

warning: variable `T_val` should have a snake case name
   --> output.rs:105:17
    |
105 |             let T_val = T_val.clone();
    |                 ^^^^^ help: convert the identifier to snake case: `t_val`

warning: variable `T_val` should have a snake case name
   --> output.rs:108:22
    |
108 |                  let T_val = T_val.clone();
    |                      ^^^^^ help: convert the identifier to snake case: `t_val`

warning: variable `T_val` should have a snake case name
   --> output.rs:119:18
    |
119 | fn rec_list_impl(T_val: Value, nil_case: Value, cons_case: Value...
    |                  ^^^^^ help: convert the identifier to snake case: `t_val`

warning: function `mkBox` should have a snake case name
   --> output.rs:186:4
    |
186 | fn mkBox() -> Value {
    |    ^^^^^ help: convert the identifier to snake case: `mk_box`

warning: function `getBox` should have a snake case name
   --> output.rs:189:4
    |
189 | fn getBox() -> Value {
    |    ^^^^^^ help: convert the identifier to snake case: `get_box`

warning: function `toNat` should have a snake case name
   --> output.rs:201:4
    |
201 | fn toNat() -> Value {
    |    ^^^^^ help: convert the identifier to snake case: `to_nat`

warning: function `rec_MyBox_entry` should have a snake case name
   --> output.rs:208:4
    |
208 | fn rec_MyBox_entry(arg_0: Value) -> Value {
    |    ^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `rec_my_box_entry`

warning: function `rec_MyBox_impl` should have a snake case name
   --> output.rs:219:4
    |
219 | fn rec_MyBox_impl(arg_0: Value, arg_1: Value, arg_2: Value) -> V...
    |    ^^^^^^^^^^^^^^ help: convert the identifier to snake case: `rec_my_box_impl`

warning: function `rec_MyNat_entry` should have a snake case name
   --> output.rs:239:4
    |
239 | fn rec_MyNat_entry(arg_0: Value) -> Value {
    |    ^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `rec_my_nat_entry`

warning: function `rec_MyNat_impl` should have a snake case name
   --> output.rs:255:4
    |
255 | fn rec_MyNat_impl(arg_0: Value, arg_1: Value, arg_2: Value, arg_...
    |    ^^^^^^^^^^^^^^ help: convert the identifier to snake case: `rec_my_nat_impl`

warning: failed to garbage collect finalized incremental compilation session directory `/Volumes/Crucial X6/MacBook/Code/leanrustlisp/build/incremental/output-2wsjtpnx8bt2e/s-hfc5nt4os9-23ftkk-ef01zwsnlm13f8t98l2sb2jni`: No such file or directory (os error 2)

warning: 26 warnings emitted

Compilation successful. Binary 'generic_test' created.
