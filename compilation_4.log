Processing: defmacro
Processing: inductive
Processing: inductive
Processing: def
Def Check Error add: TypeMismatch { expected: Ind("Nat", []), got: Sort(Zero) }
Processing: def
Processing: def
Processing: def
Processing: def
Processing: inductive
Processing: inductive
Processing: def
Def Check Error getBox: TypeMismatch { expected: App(Var(0), Ctor("MyBox", 0, [])), got: Pi(Ind("Nat", []), Ind("Nat", [])) }
Processing: def
[31mError:[0m Unbound variable: getBox
    [38;5;246mâ•­[0m[38;5;246mâ”€[0m[38;5;246m[[0mtests/generic_ind_test.lrl:12:16[38;5;246m][0m
    [38;5;246mâ”‚[0m
 [38;5;246m12 â”‚[0m [38;5;249m([0m[38;5;249md[0m[38;5;249me[0m[38;5;249mf[0m[38;5;249m [0m[38;5;249mr[0m[38;5;249me[0m[38;5;249ms[0m[38;5;249m1[0m[38;5;249m [0m[38;5;249mN[0m[38;5;249ma[0m[38;5;249mt[0m[38;5;249m [0m[38;5;249m([0m[31mg[0m[31me[0m[31mt[0m[31mB[0m[31mo[0m[31mx[0m[38;5;249m [0m[38;5;249m([0m[38;5;249mm[0m[38;5;249mk[0m[38;5;249mB[0m[38;5;249mo[0m[38;5;249mx[0m[38;5;249m [0m[38;5;249m([0m[38;5;249ms[0m[38;5;249mu[0m[38;5;249mc[0m[38;5;249mc[0m[38;5;249m [0m[38;5;249mz[0m[38;5;249me[0m[38;5;249mr[0m[38;5;249mo[0m[38;5;249m)[0m[38;5;249m)[0m[38;5;249m)[0m[38;5;249m)[0m
 [38;5;240m   â”‚[0m                [31mâ”€[0m[31mâ”€[0m[31mâ”€[0m[31mâ”¬[0m[31mâ”€[0m[31mâ”€[0m  
 [38;5;240m   â”‚[0m                   [31mâ•°[0m[31mâ”€[0m[31mâ”€[0m[31mâ”€[0m[31mâ”€[0m Unbound variable: getBox
[38;5;246mâ”€â”€â”€â”€â•¯[0m
Processing: inductive
Processing: def
Def Check Error toNat: TypeMismatch { expected: Ind("Nat", []), got: Sort(Zero) }
Processing: def
[31mError:[0m Unbound variable: toNat
    [38;5;246mâ•­[0m[38;5;246mâ”€[0m[38;5;246m[[0mtests/generic_ind_test.lrl:27:16[38;5;246m][0m
    [38;5;246mâ”‚[0m
 [38;5;246m27 â”‚[0m [38;5;249m([0m[38;5;249md[0m[38;5;249me[0m[38;5;249mf[0m[38;5;249m [0m[38;5;249mr[0m[38;5;249me[0m[38;5;249ms[0m[38;5;249m2[0m[38;5;249m [0m[38;5;249mN[0m[38;5;249ma[0m[38;5;249mt[0m[38;5;249m [0m[38;5;249m([0m[31mt[0m[31mo[0m[31mN[0m[31ma[0m[31mt[0m[38;5;249m [0m[38;5;249m([0m[38;5;249mm[0m[38;5;249my[0m[38;5;249ms[0m[38;5;249mu[0m[38;5;249mc[0m[38;5;249mc[0m[38;5;249m [0m[38;5;249m([0m[38;5;249mm[0m[38;5;249my[0m[38;5;249ms[0m[38;5;249mu[0m[38;5;249mc[0m[38;5;249mc[0m[38;5;249m [0m[38;5;249mm[0m[38;5;249my[0m[38;5;249mz[0m[38;5;249me[0m[38;5;249mr[0m[38;5;249mo[0m[38;5;249m)[0m[38;5;249m)[0m[38;5;249m)[0m[38;5;249m)[0m
 [38;5;240m   â”‚[0m                [31mâ”€[0m[31mâ”€[0m[31mâ”¬[0m[31mâ”€[0m[31mâ”€[0m  
 [38;5;240m   â”‚[0m                  [31mâ•°[0m[31mâ”€[0m[31mâ”€[0m[31mâ”€[0m[31mâ”€[0m Unbound variable: toNat
[38;5;246mâ”€â”€â”€â”€â•¯[0m
[31mError:[0m Unbound variable: res1
    [38;5;246mâ•­[0m[38;5;246mâ”€[0m[38;5;246m[[0mtests/generic_ind_test.lrl:28:1[38;5;246m][0m
    [38;5;246mâ”‚[0m
 [38;5;246m28 â”‚[0m [31mr[0m[31me[0m[31ms[0m[31m1[0m
 [38;5;240m   â”‚[0m [31mâ”€[0m[31mâ”€[0m[31mâ”¬[0m[31mâ”€[0m  
 [38;5;240m   â”‚[0m   [31mâ•°[0m[31mâ”€[0m[31mâ”€[0m[31mâ”€[0m Unbound variable: res1
[38;5;246mâ”€â”€â”€â”€â•¯[0m
[31mError:[0m Unbound variable: res2
    [38;5;246mâ•­[0m[38;5;246mâ”€[0m[38;5;246m[[0mtests/generic_ind_test.lrl:29:1[38;5;246m][0m
    [38;5;246mâ”‚[0m
 [38;5;246m29 â”‚[0m [31mr[0m[31me[0m[31ms[0m[31m2[0m
 [38;5;240m   â”‚[0m [31mâ”€[0m[31mâ”€[0m[31mâ”¬[0m[31mâ”€[0m  
 [38;5;240m   â”‚[0m   [31mâ•°[0m[31mâ”€[0m[31mâ”€[0m[31mâ”€[0m Unbound variable: res2
[38;5;246mâ”€â”€â”€â”€â•¯[0m
Compiling output.rs to generic_test...
warning: unnecessary braces around block return value
   --> output.rs:166:1
    |
166 | { Value::Func(Rc::new(move |x_0: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_0 = x_0.clone(); Value::Func(Rc::new(move |x_1: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#false()), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#true()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_0.clone()), _ => panic!("Expected Func") }) })) }
    | ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^^
    |
    = note: `#[warn(unused_braces)]` on by default
help: remove these braces
    |
166 - { Value::Func(Rc::new(move |x_0: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_0 = x_0.clone(); Value::Func(Rc::new(move |x_1: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#false()), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#true()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_0.clone()), _ => panic!("Expected Func") }) })) }
166 + Value::Func(Rc::new(move |x_0: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_0 = x_0.clone(); Value::Func(Rc::new(move |x_1: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#false()), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#true()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_0.clone()), _ => panic!("Expected Func") }) }))
    |

warning: unnecessary braces around block return value
   --> output.rs:169:1
    |
169 | { Value::Func(Rc::new(move |x_2: Value| { { let x_2 = x_2.clone(); Value::Func(Rc::new(move |x_3: Value| { { let x_2 = x_2.clone(); let x_3 = x_3.clone(); Value::Func(Rc::new(move |x_4: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_2 = x_2.clone(); let x_3 = x_3.clone(); let x_4 = x_4.clone(); Value::Func(Rc::new(move |x_5: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_3.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_4.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_2.clone()), _ => panic!("Expected Func") }) })) } })) } })) }
    | ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^^
    |
help: remove these braces
    |
169 - { Value::Func(Rc::new(move |x_2: Value| { { let x_2 = x_2.clone(); Value::Func(Rc::new(move |x_3: Value| { { let x_2 = x_2.clone(); let x_3 = x_3.clone(); Value::Func(Rc::new(move |x_4: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_2 = x_2.clone(); let x_3 = x_3.clone(); let x_4 = x_4.clone(); Value::Func(Rc::new(move |x_5: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_3.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_4.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_2.clone()), _ => panic!("Expected Func") }) })) } })) } })) }
169 + Value::Func(Rc::new(move |x_2: Value| { { let x_2 = x_2.clone(); Value::Func(Rc::new(move |x_3: Value| { { let x_2 = x_2.clone(); let x_3 = x_3.clone(); Value::Func(Rc::new(move |x_4: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_2 = x_2.clone(); let x_3 = x_3.clone(); let x_4 = x_4.clone(); Value::Func(Rc::new(move |x_5: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_3.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_4.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_2.clone()), _ => panic!("Expected Func") }) })) } })) } }))
    |

warning: unnecessary braces around block return value
   --> output.rs:172:1
    |
172 | { Value::Func(Rc::new(move |x_6: Value| { { let x_6 = x_6.clone(); Value::Func(Rc::new(move |x_7: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_6 = x_6.clone(); let x_7 = x_7.clone(); Value::Func(Rc::new(move |x_8: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_7.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#false()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_6.clone()), _ => panic!("Expected Func") }) })) } })) }
    | ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^^
    |
help: remove these braces
    |
172 - { Value::Func(Rc::new(move |x_6: Value| { { let x_6 = x_6.clone(); Value::Func(Rc::new(move |x_7: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_6 = x_6.clone(); let x_7 = x_7.clone(); Value::Func(Rc::new(move |x_8: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_7.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#false()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_6.clone()), _ => panic!("Expected Func") }) })) } })) }
172 + Value::Func(Rc::new(move |x_6: Value| { { let x_6 = x_6.clone(); Value::Func(Rc::new(move |x_7: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_6 = x_6.clone(); let x_7 = x_7.clone(); Value::Func(Rc::new(move |x_8: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_7.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#false()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_6.clone()), _ => panic!("Expected Func") }) })) } }))
    |

warning: unnecessary braces around block return value
   --> output.rs:175:1
    |
175 | { Value::Func(Rc::new(move |x_9: Value| { { let x_9 = x_9.clone(); Value::Func(Rc::new(move |x_10: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_9 = x_9.clone(); let x_10 = x_10.clone(); Value::Func(Rc::new(move |x_11: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#true()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_10.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_9.clone()), _ => panic!("Expected Func") }) })) } })) }
    | ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^^
    |
help: remove these braces
    |
175 - { Value::Func(Rc::new(move |x_9: Value| { { let x_9 = x_9.clone(); Value::Func(Rc::new(move |x_10: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_9 = x_9.clone(); let x_10 = x_10.clone(); Value::Func(Rc::new(move |x_11: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#true()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_10.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_9.clone()), _ => panic!("Expected Func") }) })) } })) }
175 + Value::Func(Rc::new(move |x_9: Value| { { let x_9 = x_9.clone(); Value::Func(Rc::new(move |x_10: Value| { (match (match (match (match Value::Func(Rc::new(rec_bool_entry)) { Value::Func(f) => f({ let x_9 = x_9.clone(); let x_10 = x_10.clone(); Value::Func(Rc::new(move |x_11: Value| { Value::Unit })) }), _ => panic!("Expected Func") }) { Value::Func(f) => f(r#true()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_10.clone()), _ => panic!("Expected Func") }) { Value::Func(f) => f(x_9.clone()), _ => panic!("Expected Func") }) })) } }))
    |

warning: variable does not need to be mutable
   --> output.rs:247:25
    |
247 |                     let mut curr_fn = arg_1.clone();
    |                         ----^^^^^^^
    |                         |
    |                         help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: variable `T_val` should have a snake case name
   --> output.rs:101:19
    |
101 | fn rec_list_entry(T_val: Value) -> Value {
    |                   ^^^^^ help: convert the identifier to snake case: `t_val`
    |
    = note: `#[warn(non_snake_case)]` on by default

warning: variable `_M` should have a snake case name
   --> output.rs:102:31
    |
102 |     Value::Func(Rc::new(move |_M| {
    |                               ^^ help: convert the identifier to snake case: `_m`

warning: variable `T_val` should have a snake case name
   --> output.rs:103:13
    |
103 |         let T_val = T_val.clone();
    |             ^^^^^ help: convert the identifier to snake case: `t_val`

warning: variable `T_val` should have a snake case name
   --> output.rs:105:17
    |
105 |             let T_val = T_val.clone();
    |                 ^^^^^ help: convert the identifier to snake case: `t_val`

warning: variable `T_val` should have a snake case name
   --> output.rs:108:22
    |
108 |                  let T_val = T_val.clone();
    |                      ^^^^^ help: convert the identifier to snake case: `t_val`

warning: variable `T_val` should have a snake case name
   --> output.rs:119:18
    |
119 | fn rec_list_impl(T_val: Value, nil_case: Value, cons_case: Value...
    |                  ^^^^^ help: convert the identifier to snake case: `t_val`

warning: function `mkBox` should have a snake case name
   --> output.rs:183:4
    |
183 | fn mkBox() -> Value {
    |    ^^^^^ help: convert the identifier to snake case: `mk_box`

warning: function `rec_MyBox_entry` should have a snake case name
   --> output.rs:193:4
    |
193 | fn rec_MyBox_entry(arg_0: Value) -> Value {
    |    ^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `rec_my_box_entry`

warning: function `rec_MyBox_impl` should have a snake case name
   --> output.rs:204:4
    |
204 | fn rec_MyBox_impl(arg_0: Value, arg_1: Value, arg_2: Value) -> V...
    |    ^^^^^^^^^^^^^^ help: convert the identifier to snake case: `rec_my_box_impl`

warning: function `rec_MyNat_entry` should have a snake case name
   --> output.rs:224:4
    |
224 | fn rec_MyNat_entry(arg_0: Value) -> Value {
    |    ^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `rec_my_nat_entry`

warning: function `rec_MyNat_impl` should have a snake case name
   --> output.rs:240:4
    |
240 | fn rec_MyNat_impl(arg_0: Value, arg_1: Value, arg_2: Value, arg_...
    |    ^^^^^^^^^^^^^^ help: convert the identifier to snake case: `rec_my_nat_impl`

warning: 16 warnings emitted

Compilation successful. Binary 'generic_test' created.
