#V2
(lam x x)
(add (ctor Nat 1) (ctor Nat 1))
(cons Nat (succ zero) (nil Nat))
:help
(cons Nat (succ zero) (nil Nat))
:eval (and true false)
:help
:eval (and true false)
:eval (if_nat true (succ zero) zero)
:eval (cons Nat (succ zero) (nil Nat))
\\
(defmacro my_add (x y) (add x y))
:expand (my_add 1 2)
(defmacro my_add (x y) (add x y))
:expand (my_add 1 2)
;; Test match elaboration
(inductive Nat (sort 0)
(ctor zero Nat)
(ctor succ (pi n Nat Nat)))
;; Test match expression
(match (succ zero) Nat
(case (zero) zero)
(case (succ n ih) n))
(inductive Nat (sort 0)
(ctor zero Nat)
(ctor succ (pi n Nat Nat)))
zero
(inductive Nat (sort 0) (ctor zero Nat) (ctor succ (pi n Nat Nat)))
zero
(succ zero)
(inductive Nat (sort 0) (ctor zero Nat) (ctor succ (pi n Nat Nat)))
(match zero Nat (case (zero) zero) (case (succ n ih) n))
(inductive Nat (sort 0) (ctor zero Nat) (ctor succ (pi n Nat Nat)))
:eval (match zero Nat (case (zero) (succ zero)) (case (succ n ih) zero))
:eval (match (succ zero) Nat (case (zero) (succ zero)) (case (succ n ih) zero))
(defmacro id (x) x)
(inductive Nat (sort 0) (ctor zero Nat) (ctor succ (pi n Nat Nat)))
(inductive Bool (sort 0) (ctor true Bool) (ctor false Bool))
(defmacro id (x) x)
(inductive Nat (sort 0) (ctor zero Nat) (ctor succ (pi n Nat Nat)))
(def add (pi n Nat (pi m Nat Nat)) (lam n Nat (lam m Nat (match n Nat (case (zero) m) (case (succ k ih) (succ ih))))))
(inductive Nat (sort 0) (ctor zero Nat) (ctor succ (pi n Nat Nat)))
(def add (pi n Nat (pi m Nat Nat)) (lam n Nat (lam m Nat (match n Nat (case (zero) m) (case (succ k ih) (succ ih))))))
:eval ((add (succ zero)) (succ (succ zero)))
:eval ((add (succ (succ zero))) (succ zero))
(inductive Nat (sort 0) (ctor zero Nat) (ctor succ (pi n Nat Nat)))
:eval (match (succ (succ zero)) Nat (case (zero) zero) (case (succ n ih) ih))
(inductive Nat (sort 0) (ctor zero Nat) (ctor succ (pi n Nat Nat)))
(def pred (pi n Nat Nat) (lam n Nat (match n Nat (case (zero) zero) (case (succ m ih) m))))
:eval (pred (succ (succ zero)))
(inductive Nat (sort 0) (ctor zero Nat) (ctor succ (pi n Nat Nat)))
(def pred (pi n Nat Nat) (lam n Nat (match n Nat (case (zero) zero) (case (succ m ih) m))))
:eval (pred (succ (succ zero)))
:eval (pred zero)
(inductive Nat (sort 0) (ctor zero Nat) (ctor succ (pi n Nat Nat)))
(def add (pi n Nat (pi m Nat Nat)) (lam n Nat (lam m Nat (match n Nat (case (zero) m) (case (succ k ih) (succ ih))))))
:eval ((add (succ zero)) (succ (succ zero)))
:eval ((add (succ (succ zero))) zero)
(inductive List (pi T (sort 0) (sort 0)) (ctor nil (pi T (sort 0) (List T))) (ctor cons (pi T (sort 0) (pi h T (pi t (List T) (List T))))))
:eval ((add (succ (succ zero))) (succ (succ (succ zero))))
:eval (not true)
:eval (and true false)
:eval ((add (succ zero)) (succ (succ zero)))
:eval (not false)
:eval ((add (succ zero)) (succ (succ zero)))
:eval (not false)
:type zero
:type (succ zero)
:type true
:type add
:type not
:eval (add (succ zero) (succ (succ zero)))
:eval (not true)
:eval (and true false)
:eval (or false true)
(def id (pi {T (sort 1)} (pi x T T))
(lam {T} (sort 1) (lam x T x))
)
(inductive List (pi T (sort 1) (sort 1))
(ctor nil (pi {T (sort 1)} (List T)))
(ctor cons (pi {T (sort 1)} (pi h T (pi t (List T) (List T)))))
)
;; Simple non-dependent version - return nil
(def append_simple (pi {T (sort 1)} (pi l1 (List T) (pi l2 (List T) (List T))))
(lam {T} (sort 1) (lam l1 (List T) (lam l2 (List T) nil)))
)
(def x Nat 42)
x
