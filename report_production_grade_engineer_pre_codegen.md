# LRL Pre-Codegen Production-Grade Audit

Scope: pre-codegen only (kernel, frontend, MIR, CLI pipeline up to MIR). Codegen backends were not reviewed per request.

## Executive Summary
LRL has a strong structural core: NbE-based definitional equality with transparency controls, explicit totality/effect tracking, a MIR-based NLL borrow checker, and macro boundary enforcement. The largest production risks pre-codegen are not soundness bugs but scaling hazards: brittle span propagation, flat name resolution, hygiene that only supports exact scope matches, opaque-peeking in MIR lowering, and multiple layers that silently swallow errors. These will turn into correctness and diagnosability issues once the stdlib grows and macro usage becomes heavy.

The most urgent industrialization work is to stabilize identifiers and spans, make hygiene/name resolution robust, and enforce transparency boundaries in MIR lowering. Performance work (defeq caching, dataflow bitsets, macro expansion memoization) should follow immediately after correctness/diagnostics are stabilized. 

## A) Prototype Smells (Specific)
1. Path: `frontend/src/elaborator.rs`; Symbols: `term_key`, `span_map`, `copy_span_if_any`; Smell: span tracking is keyed by `Rc` pointer identity, so cloned/reconstructed terms lose spans, leading to unstable diagnostics across elaboration and lowering; Industrial alternative: assign stable `NodeId`/`TermId` at creation time and store spans keyed by that id, or embed spans in an annotated AST and preserve them through lowering.
2. Path: `mir/src/lower.rs`; Symbols: `term_key`, `term_span_for`, `span_table`, `push_statement`, `terminate`; Smell: MIR spans are recorded but never surfaced in CLI borrow/ownership diagnostics, leaving only MIR block/stmt locations; Industrial alternative: thread `MirSpanMap` into diagnostics and map `MirSpan` to source `Span` in CLI output.
3. Path: `frontend/src/desugar.rs`; Symbols: `scopes_compatible`, `resolve_binding`; Smell: hygiene resolution requires exact scope-set equality and rejects subset/superset relations, which is too weak for real macro staging and can cause accidental capture or name failure in nested macro expansions; Industrial alternative: implement a syntax-context algorithm (scope sets with marks) that resolves by maximal compatible scope subset and supports multi-scope introductions.
4. Path: `frontend/src/macro_expander.rs`; Symbols: `expand_all_macros`, `ExpansionBudget`, `DEFAULT_EXPANSION_STEP_LIMIT`, `DEFAULT_EXPANSION_DEPTH_LIMIT`; Smell: macro expansion is bounded only by global step/depth limits with no memoization or cycle detection, so expansion cost can explode with large macros and produce non-local failures; Industrial alternative: introduce expansion memoization keyed by `(macro name, args, module)` and detect recursive expansion cycles explicitly.
5. Path: `frontend/src/elaborator.rs`; Symbols: `unify_core`, `is_def_eq_in_ctx`; Smell: unification invokes full definitional equality on every constraint before structural unification, a performance cliff on large terms or many metas; Industrial alternative: use fast structural checks first, defer NbE-based defeq to needed cases, and add a per-pass defeq cache shared across unification.
6. Path: `kernel/src/nbe.rs`; Symbols: `DEFAULT_DEF_EQ_FUEL`, `defeq_fuel_policy`, `eval_with_cache`; Smell: defeq fuel is a fixed global default with only per-process override; no adaptive or per-definition budgets and no long-lived cache across typechecking, risking unpredictable failures on large defs; Industrial alternative: add size-based fuel heuristics, per-definition defeq budgets, and a shared defeq memo table scoped to a typechecking session.
7. Path: `mir/src/lib.rs`; Symbols: `Literal::Term`; Smell: MIR contains an escape hatch for kernel terms, blurring IR boundaries and forcing later phases to understand core terms; Industrial alternative: remove `Literal::Term` and require full lowering into MIR `Constant` forms or a dedicated `OpaqueConst` that is never codegenned without explicit support.
8. Path: `mir/src/lower.rs`; Symbols: `borrow_shape_unfold`, `lower_borrow_shape_general`; Smell: MIR lowering explicitly unfolds `opaque` definitions (`Transparency::All`) to detect borrow shapes, violating opacity and making borrow semantics depend on definitional details; Industrial alternative: require explicit marker/attribute on borrow wrappers and keep `opaque` truly opaque in lowering.
9. Path: `kernel/src/ast.rs`; Symbols: `DefId::new`, `stable_hash64`; Smell: definition ids are derived from a 64-bit hash of names without collision handling, which can alias definitions in large or adversarial codebases; Industrial alternative: allocate monotonic ids in a symbol table and use hashes only for debugging/serialization.
10. Path: `frontend/src/elaborator.rs`; Symbols: `resolve_name`; Smell: name resolution is flat (locals + global env), with no module/namespace qualifiers or import scopes, which will not scale with a large stdlib; Industrial alternative: introduce module-qualified names, explicit imports, and a deterministic resolution order with ambiguity reporting.
11. Path: `mir/src/analysis/nll.rs`; Symbols: `BorrowError`, `BorrowErrorContext`, `RegionConstraintChain`; Smell: NLL produces structured region explanations, but CLI prints only stringified MIR errors without source-span mapping, making diagnostics unusable; Industrial alternative: plumb `MirSpanMap` into NLL errors and render source spans with labels in CLI.
12. Path: `mir/src/lower.rs`; Symbols: `interior_mutability_kind`; Smell: `env.has_marker(..).expect("marker registry uninitialized")` panics instead of reporting a diagnostic, violating “no panics on well-typed programs”; Industrial alternative: return a `LoweringError` when marker registry is missing or inconsistent.
13. Path: `kernel/src/checker.rs`; Symbols: `check_inductive_soundness` and related errors (`NestedInductive`); Smell: nested inductive occurrences are explicitly unsupported, which is acceptable for a prototype but will block real libraries; Industrial alternative: implement positivity checking for nested inductives or formalize a restricted but explicit inductive subset.
14. Path: `mir/src/analysis/liveness.rs`; Symbols: `compute_liveness`; Smell: liveness uses `HashSet`/`HashMap` with per-iteration allocation and no bitset specialization, which will become a performance bottleneck on large MIR; Industrial alternative: replace with bitset-based dataflow or reuse `LocationSet`-style dense sets.
15. Path: `mir/src/lower.rs`; Symbols: `lower_type_general_with_scope` (uses `unwrap_or_else(|_| term.clone())`); Smell: type-lowering swallows kernel errors and proceeds with potentially invalid MIR types, risking downstream diagnostics and miscompilations; Industrial alternative: propagate these errors as `LoweringError` and fail the compilation early.

## B) Industrialization Roadmap
**Phase 1: Pre-stdlib Expansion Refactors**
Tasks: introduce stable term/node ids + span propagation; wire `MirSpanMap` into borrow/ownership diagnostics; make `opaque` truly opaque in MIR lowering by replacing `borrow_shape_unfold` with explicit borrow-wrapper markers; remove `Literal::Term` or quarantine it behind an explicit `OpaqueConst` gate; add module-qualified name resolution and import scopes. Dependencies: stable `NodeId` design and new span tables; updates in `frontend/src/elaborator.rs`, `mir/src/lower.rs`, `cli/src/compiler.rs`. Risk: medium-high (touches AST/mapping). Acceptance tests: source-span reporting for borrow/ownership errors; macro-expanded code produces correct spans; `opaque` definitions do not affect borrow checks unless explicitly marked.

**Phase 2: Performance + Determinism Upgrades**
Tasks: defeq memoization across elaboration/typechecking; size-based defeq fuel with diagnostics on exhaustion; replace HashSet-based liveness with bitsets; macro expansion memoization and cycle detection; deterministic ordering for diagnostic lists derived from HashMaps. Dependencies: Phase 1 span/ID refactor to support stable caching keys. Risk: medium. Acceptance tests: compile-time benchmark for large mutually recursive defs without defeq exhaustion; stable outputs across multiple runs; macro expansion performance tests.

**Phase 3: Tooling + Ecosystem Readiness**
Tasks: incremental compilation cache keyed by module hash; LSP-ready diagnostics schema (stable ids + spans); expand fuzzing beyond NLL (macro expansion/elaboration); create spec-level regression tests for defeq/termination/borrowck invariants. Dependencies: Phase 1/2 diagnostics and determinism. Risk: medium-low. Acceptance tests: incremental rebuild of a multi-module project touches only changed modules; LSP diagnostics map to exact spans; fuzzing finds no panics.

## C) Hard Requirements Checklist (v0.1 Pre-Codegen)
- Deterministic compilation (same input => same output): Partial. Most outputs are sorted, but several passes rely on `HashMap` traversal without explicit ordering. 
- Stable error categories and spans: Partial. Error codes exist, but spans are unstable across elaboration and MIR errors are not mapped to source spans.
- No panics from well-typed programs in the default pipeline: Partial. `expect` in marker handling and error-swallowing in MIR lowering are remaining risks.
- Clear kernel boundary (minimal TCB): Partial. MIR still uses kernel terms (`Literal::Term`) and lowering peeks into `opaque` defs.
- Definitional equality is principled (NbE or equivalent): Pass. NbE is implemented with transparency controls, but needs caching and profiling.
- Inductives/eliminators are general (no Nat/Bool/List special casing in semantics): Partial. Some builtin handling exists in MIR lowering; nested inductives are explicitly unsupported.
- Performance guardrails for defeq: Partial. Fuel exists, `opaque` exists; missing per-definition budgets and persistent caching.
- Treat `panic!` in compiler as failure: Partial. There are still `expect` paths in MIR lowering.

**Industrialization Checklist (Updated)**
- NLL-ready MIR requirements: Pass for CFG (`mir/src/lib.rs` basic blocks/terminators) and region constraints (`mir/src/analysis/nll.rs`), Partial for diagnostics (missing source-span mapping).
- Panic-free profile definition and enforcement: Partial. `mir/src/lints.rs` enforces a panic-free lint, but it is CLI-flag gated and not enforced at kernel boundary.
- Transparency defaults + escape hatches + defeq performance guardrails: Partial. `Transparency::Reducible` is default with `opaque` support and defeq fuel, but lacks profiling, per-definition budgets, and defeq caching.

## D) Concrete Proposed Changes (Top 5 Issues)
1. Stable term IDs + span propagation. Files: `kernel/src/ast.rs`, `frontend/src/elaborator.rs`, `mir/src/lower.rs`, `cli/src/compiler.rs`. Changes: add a `TermId` (u32) field to `Term` or wrap `Term` in a `SpannedTerm` with `id` + `span`; replace pointer-based `term_key` maps with `TermId` keys; update elaborator to assign `TermId` on construction; update MIR lowering to use `TermId`-based span maps; plumb `MirSpanMap` into borrow/ownership diagnostics and render source spans. Tests: new golden tests that show correct spans for borrow errors in macro-expanded code.
2. Hygiene resolution upgrade. Files: `frontend/src/desugar.rs`, `frontend/src/macro_expander.rs`, `frontend/src/surface.rs`. Changes: define a `ScopeSet` type (sorted Vec) and implement compatibility as “definition scopes ⊆ reference scopes”; update `resolve_binding` to pick the most specific compatible scope set; normalize scopes on both sides in desugaring; add tests for nested macro expansions and macro-introduced bindings. Delete/replace: current `scopes_compatible` equality checks.
3. Remove opaque peeking in MIR lowering. Files: `mir/src/lower.rs`, `kernel/src/ast.rs` (marker annotations), `stdlib/prelude.lrl`. Changes: introduce explicit marker/attribute (e.g., `#[borrow_shape]` or dedicated `Ref`/IM wrapper constructors) so borrow shapes can be detected without unfolding `opaque`; delete `borrow_shape_unfold` and the `Transparency::All` path; add tests that `opaque` aliases do not affect borrow checking unless explicitly marked.
4. Eliminate `Literal::Term` in MIR. Files: `mir/src/lib.rs`, `mir/src/lower.rs`. Changes: replace `Literal::Term` with `Literal::OpaqueConst` that is rejected unless a backend explicitly supports it; update lowering to fully lower constants or emit a hard error; add regression tests asserting no `Literal::Term` remains after lowering for stdlib programs.
5. Defeq/unification performance guardrails. Files: `kernel/src/nbe.rs`, `frontend/src/elaborator.rs`, `cli/src/lib.rs`. Changes: add a session-scoped defeq cache shared across elaboration; add term-size-based fuel heuristics and include cost metrics in `DefEqFuelDetail`; in `unify_core`, attempt structural unification before NbE unless metas block; add a `--defeq-profile` CLI flag that prints top N reductions by fuel usage. Tests: defeq micro-bench (size-scaling) + regression test for fuel exhaustion reporting.

## E) Non-goals / Deliberate Tradeoffs (For Now)
- Do not implement full dependent type inference; the current explicit annotation approach is acceptable and keeps elaboration predictable.
- Do not over-engineer a full module system with separate compilation yet; implement qualified names and deterministic imports first.
- Keep the kernel small: move optimization, borrow checking, and macro expansion improvements into frontend/MIR rather than expanding the TCB.
- Avoid prematurely adding SSA or full Polonius-style region inference; first stabilize spans, diagnostics, and deterministic behavior.

## Issue List (Proposed GitHub Issues)
1. [blocker][frontend/kernel/mir] Replace pointer-based term span tracking with stable `TermId` mapping. Acceptance: spans remain correct after elaboration/lowering; no use of `Rc::as_ptr` for span lookup.
2. [high][cli/mir] Render borrow/ownership errors with source spans using `MirSpanMap`. Acceptance: CLI diagnostics show file/line/col for NLL and ownership errors.
3. [high][frontend] Implement qualified names + deterministic import scopes in `resolve_name`. Acceptance: ambiguous names require qualification; tests for `Module.Name` resolution.
4. [high][frontend] Upgrade hygiene resolution to allow compatible scope subsets and prevent capture. Acceptance: new macro hygiene tests pass for nested expansion + shadowing.
5. [high][mir] Remove `Literal::Term` from MIR or gate it behind explicit backend support. Acceptance: lowering fails if `Literal::Term` remains; stdlib lowers without `Literal::Term`.
6. [high][mir] Remove `borrow_shape_unfold` and require explicit borrow-wrapper markers. Acceptance: `opaque` aliases do not affect borrow checking; explicit markers still work.
7. [high][kernel/frontend] Session-scoped defeq cache and size-based fuel heuristics. Acceptance: large programs no longer hit defeq fuel with default settings; defeq profile output available.
8. [med][frontend] Add macro expansion memoization and recursion cycle detection. Acceptance: recursive macro expansion error reports cycle with trace; expansion time improves on repeated macros.
9. [med][mir] Replace HashSet liveness with bitset dataflow. Acceptance: liveness runtime improves on large MIR benchmarks; results unchanged.
10. [med][mir] Convert marker-registry `expect` in lowering to diagnostics. Acceptance: missing markers produce `LoweringError` not panic.
11. [med][kernel] Replace name-hash `DefId` with monotonic ids (keep hash only for debug). Acceptance: no hash-based id collisions; stable ids within session.
12. [med][tests] Add golden tests for macro-expanded spans + borrow errors. Acceptance: tests assert span mapping across macro expansion and lowering.
13. [med][tests] Add defeq performance micro-bench and fuel regression tests. Acceptance: benchmark harness exists and fails if defeq fuel changes regress >20%.
14. [med][frontend] Add error spans for `ImplicitNonCopyUse` and other span-less elaborator errors. Acceptance: errors include spans wherever a surface term exists.
15. [med][mir] Enforce `panic_free` profile at pipeline boundary (fail compile if runtime checks inserted). Acceptance: `--panic-free` rejects any runtime check insertion.
16. [low][tooling] Sort all HashMap-derived diagnostic lists for deterministic output. Acceptance: repeated builds produce identical diagnostics order.
17. [low][fuzz] Add fuzz target for macro expansion + desugaring. Acceptance: fuzzing runs without panics for 24h corpus.
18. [low][tests] Add NLL diagnostic regression tests for constraint chain rendering. Acceptance: errors include region chain and issuing location.
19. [low][frontend] Emit structured diagnostic codes for macro expansion limit errors. Acceptance: F0106 appears with limit values.
20. [low][docs/tests] Document and test interior mutability policy (RefCell/Mutex/Atomic) across kernel markers and MIR checks. Acceptance: tests prove marker classification and runtime checks insertion.
