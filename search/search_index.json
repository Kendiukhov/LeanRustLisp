{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentation","text":"<p>Start here to learn about LeanRustLisp.</p>"},{"location":"#guides","title":"Guides","text":"<ul> <li>For Users: The Book</li> <li>For Developers: Internals</li> </ul>"},{"location":"#reference","title":"Reference","text":"<ul> <li>Language Reference</li> <li>Formal Specification</li> </ul>"},{"location":"community/","title":"Community &amp; Trust","text":""},{"location":"community/#trusted-computing-base-tcb","title":"Trusted Computing Base (TCB)","text":"<p>LRL employs a strict separation between Trusted and Untrusted components to minimize the attack surface for critical bugs.</p> Component Trust Level Role <code>kernel</code> crate Trusted The only code that must be correct for logical soundness. If the kernel has a bug, proofs may be unsound. <code>frontend</code> Untrusted Parses and elaborates code. Bugs cause compile errors, not false proofs. <code>codegen</code> Untrusted Generates Rust/MIR. Bugs may cause runtime crashes, not unsound proofs. <code>cli</code> Untrusted User interface only."},{"location":"community/#kernel-guarantees-p1p8","title":"Kernel Guarantees (P1\u2013P8)","text":"<p>These are the release bar promises that the kernel enforces. Every release is validated against these guarantees.</p>"},{"location":"community/#p1-kernel-boundary-enforcement","title":"P1: Kernel Boundary Enforcement","text":"<p>All definitions and expressions are re-checked by the kernel before acceptance. No production path can bypass kernel validation.</p> <p>What this means: Even if the elaborator or frontend has bugs, the kernel acts as a final gatekeeper. Malformed or unsound terms are rejected.</p>"},{"location":"community/#p2-totality-boundary","title":"P2: Totality Boundary","text":"<ul> <li><code>def</code> forbids general recursion (<code>fix</code>) and partial constructs (non-terminating code).</li> <li><code>partial def</code> is the only place where general recursion is allowed.</li> <li>Partial constructs cannot appear in types or definitional equality checks.</li> </ul> <p>What this means: Proofs and type-level computations are guaranteed to terminate. Only explicitly marked <code>partial def</code> can contain potentially non-terminating code.</p>"},{"location":"community/#p3-properasure-safety","title":"P3: Prop/Erasure Safety","text":"<ul> <li><code>Prop</code>-like types are correctly classified (including opaque aliases).</li> <li>Large elimination from <code>Prop</code> into runtime data is forbidden (unless explicitly allowed).</li> <li>Proof erasure cannot be bypassed via aliasing or opaque wrappers.</li> </ul> <p>What this means: Proofs are computationally irrelevant at runtime. You cannot accidentally leak proof terms into executable code.</p>"},{"location":"community/#p4-macro-boundary-hygiene","title":"P4: Macro Boundary &amp; Hygiene","text":"<ul> <li>The macro boundary <code>Deny</code> works after full expansion (including quasiquote) and cannot be bypassed.</li> <li>Hygiene behavior matches the documented policy\u2014macros cannot accidentally capture or shadow user bindings.</li> </ul> <p>What this means: Macros are sandboxed. A macro cannot smuggle unsafe constructs past the boundary, and variable capture is controlled.</p>"},{"location":"community/#p5-borrowlifetime-safety-mirnll","title":"P5: Borrow/Lifetime Safety (MIR/NLL)","text":"<ul> <li>MIR-level borrow checking rejects aliasing, deref, and projection errors.</li> <li>Lifetime labels are not laundered across kernel/MIR boundaries.</li> <li>MIR lowering does not erase types in ways that bypass borrow/move/copy enforcement.</li> </ul> <p>What this means: Memory safety is enforced at the MIR level, similar to Rust's borrow checker. Use-after-free and data races are caught before code generation.</p>"},{"location":"community/#p6-axiomnoncomputable-policy","title":"P6: Axiom/Noncomputable Policy","text":"<ul> <li>Logical axioms (like classical logic) require <code>noncomputable</code> or <code>unsafe</code> markers.</li> <li>Runtime primitives are not misclassified as logical axioms.</li> <li>Macro boundaries cannot smuggle axioms into the prelude under <code>Deny</code>.</li> </ul> <p>What this means: You always know when you're using axioms that might affect logical consistency or computability.</p>"},{"location":"community/#p7-interior-mutability-policy","title":"P7: Interior Mutability Policy","text":"<ul> <li>If <code>RefCell</code>/<code>Mutex</code> runtime checks are not implemented, safe usage must be gated or forbidden.</li> <li>If enabled, runtime checks are actually emitted (no silent no-ops in \"safe\" mode).</li> </ul> <p>What this means: Interior mutability follows Rust's model\u2014either the compiler proves safety, or runtime checks enforce it. There are no silent gaps.</p>"},{"location":"community/#p8-definitional-equality-fueltransparency","title":"P8: Definitional Equality Fuel/Transparency","text":"<ul> <li>Fuel exhaustion is diagnosable and never misreported as success.</li> <li>Opaque/transparency behavior matches documented policy.</li> </ul> <p>What this means: When the type checker gives up on proving equality (due to computation limits), it tells you clearly instead of silently accepting or rejecting.</p>"},{"location":"community/#reporting-issues","title":"Reporting Issues","text":"<p>If you find a soundness bug (e.g., you can prove <code>False</code>), please report it immediately!</p> <ul> <li>GitHub Issues: Open an Issue</li> <li>Security: See Security Policy</li> </ul>"},{"location":"community/#join-us","title":"Join Us","text":"<ul> <li>GitHub Discussions: Ask questions and share ideas.</li> <li>Contribution: See our Contributing Guide.</li> </ul> <p>We welcome all contributors interested in type theory, Rust, and compiler design.</p>"},{"location":"examples/","title":"Examples","text":"<p>A collection of examples demonstrating LeanRustLisp's capabilities.</p>"},{"location":"examples/#1-natural-numbers-recursion","title":"1. Natural Numbers &amp; Recursion","text":"<p>Demonstrates inductive types and structural recursion.</p> <pre><code>(inductive Nat (Type 0)\n  (zero Nat)\n  (succ (-&gt; Nat Nat)))\n\n(def add (-&gt; Nat Nat Nat)\n  (lam n (lam m\n    (match n\n      (zero m)\n      (succ (pred) (succ (add pred m)))))))\n</code></pre> <p>Key Concept: The kernel verifies that <code>add</code> terminates because <code>pred</code> is a structural sub-term of <code>n</code>.</p>"},{"location":"examples/#2-safe-array-access-dependent-types","title":"2. Safe Array Access (Dependent Types)","text":"<p>Demonstrates dependent types for bounds checking.</p> <pre><code>;; Vector of length n\n(inductive Vec (Type 0) (Nat)\n  (nil (Vec zero))\n  (cons (forall (n : Nat) (-&gt; Nat (Vec n) (Vec (succ n))))))\n\n;; Safe lookup (impossible to call with out-of-bounds index)\n(def lookup (forall (n : Nat) (-&gt; (Fin n) (Vec n) Nat))\n  ...)\n</code></pre> <p>Key Concept: The type system prevents out-of-bounds errors at compile time.</p>"},{"location":"examples/#3-hygienic-macros","title":"3. hygienic Macros","text":"<p>Demonstrates the macro system.</p> <pre><code>(macro unless (cond body)\n  `(if (not ,cond) ,body ()))\n\n(unless (is-empty list)\n  (process list))\n</code></pre> <p>Key Concept: Macros transform syntax before elaboration. Hygiene ensures variables don't capture accidentally.</p>"},{"location":"examples/#4-borrowing-ownership","title":"4. Borrowing &amp; Ownership","text":"<p>Demonstrates affine types and borrow checking.</p> <pre><code>(def process (-&gt; (Ref String) Unit) ...)\n\n(let s \"hello\")\n(process (borrow s)) ;; OK: borrow\n(consume s)          ;; OK: move\n;; (process (borrow s)) ;; ERROR: Use after move\n</code></pre> <p>Key Concept: Linear resources must be used exactly once (or borrowed).</p>"},{"location":"examples/#5-noncomputable-logic","title":"5. Noncomputable Logic","text":"<p>Demonstrates erasure and logical axioms.</p> <pre><code>(axiom classical_choice ...)\n\n(def my_theorem (-&gt; Prop Prop)\n  (lam p (or p (not p)))) ;; Uses classical logic\n\n;; (eval my_theorem) ;; ERROR: Cannot evaluate noncomputable definition\n</code></pre> <p>Key Concept: Logical proofs are erased at runtime and cannot pollute executable code.</p>"},{"location":"roadmap/","title":"Roadmap","text":"<p>Current status and future plans for LeanRustLisp.</p>"},{"location":"roadmap/#status-matrix","title":"Status Matrix","text":"Feature Status Notes Core Kernel Done CIC, Universes, Inductives verified. MIR &amp; NLL Done Borrow checker and Mid-level IR working. Macro System Done Hygiene, staging, quasiquotes implemented. Typed Backend Done (Subset) Typed pipeline is implemented for the documented subset; <code>auto</code> uses typed-first with dynamic fallback diagnostics. Closures In Progress Closure lowering/capture analysis and lifting paths are implemented; copyability/call-policy semantics are being tightened. Interpreter Later Pure interpreter for scripts. Package Manager Done Dependency management."},{"location":"roadmap/#milestones","title":"Milestones","text":""},{"location":"roadmap/#phase-1-foundation-completed","title":"Phase 1: Foundation (Completed)","text":"<ul> <li>[x] Syntax &amp; Parser</li> <li>[x] Core Type Checker (Kernel)</li> <li>[x] Basic Elaborator</li> </ul>"},{"location":"roadmap/#phase-2-system-current","title":"Phase 2: System (Current)","text":"<ul> <li>[x] Borrow Checking</li> <li>[x] Macro Expander</li> <li>[ ] Stdlib (List, Nat, String)</li> <li>[ ] Effects System (IO)</li> </ul>"},{"location":"roadmap/#phase-3-polish-next","title":"Phase 3: Polish (Next)","text":"<ul> <li>[ ] Language Server (LSP)</li> <li>[ ] Generics / Polymorphism in Backend</li> <li>[ ] Optimizations</li> </ul>"},{"location":"use-cases/","title":"Use Cases","text":"<p>Why LeanRustLisp? Here are the problems we solve.</p>"},{"location":"use-cases/#verified-systems-programming","title":"Verified Systems Programming","text":"<p>Problem: C/C++ are unsafe. Rust is safe but hard to verify formally.</p> <p>Solution: LRL allows you to write low-level code with integrated proofs of correctness.</p> <p>Status: Planned</p>"},{"location":"use-cases/#safe-high-performance-infrastructure","title":"Safe High-Performance Infrastructure","text":"<p>Problem: High-performance code often requires <code>unsafe</code> in Rust.</p> <p>Solution: Dependent types can express invariants (like buffer sizes or state machine transitions) that remove the need for runtime checks without <code>unsafe</code>.</p> <p>Status: Early Access</p>"},{"location":"use-cases/#dsls-and-tooling","title":"DSLs and Tooling","text":"<p>Problem: Creating a new language is hard.</p> <p>Solution: LRL's Racket-like macro system makes it a \"language for building languages.\"</p> <p>Status: Available</p>"},{"location":"use-cases/#security-sensitive-capability-code","title":"Security-Sensitive Capability Code","text":"<p>Problem: Access control is often implicit.</p> <p>Solution: Linear capability tokens (<code>IO</code>, <code>Network</code>) enforce security policies at the type level.</p> <p>Status: Designing</p>"},{"location":"use-cases/#proof-carrying-apis","title":"Proof-Carrying APIs","text":"<p>Problem: APIs rely on documentation for constraints (\"must call init first\").</p> <p>Solution: Types encode the protocol. A function strictly cannot be called in the wrong state.</p> <p>Status: Available</p>"},{"location":"use-cases/#research-education","title":"Research &amp; Education","text":"<p>Problem: PL research languages are often slow or garbage collected.</p> <p>Solution: LRL provides a playground for type theory that compiles to standard, fast systems code.</p> <p>Status: Available</p>"},{"location":"book/00-intro/","title":"Introduction","text":"<p>LeanRustLisp (LRL) is an experimental programming language designed to unify three powerful concepts:</p> <ol> <li>Lean-grade Specification: Using dependent types and inductive families to specify precise program behavior and prove correctness.</li> <li>Rust-grade Resource Discipline: Using affine types, ownership, and borrow checking to manage memory and resources safely and efficiently without garbage collection.</li> <li>Lisp-grade Extensibility: Using S-expressions and hygienic macros to allow the language to be extended and programmed by the user.</li> </ol>"},{"location":"book/00-intro/#the-three-pillars","title":"The Three Pillars","text":""},{"location":"book/00-intro/#systems-performance","title":"Systems Performance","text":"<p>LRL aims to be a systems language. By adopting Rust's ownership model, it avoids the runtime overhead of a garbage collector, making it suitable for real-time and resource-constrained environments.</p>"},{"location":"book/00-intro/#correctness","title":"Correctness","text":"<p>With a core calculus based on the Calculus of Inductive Constructions (CIC), LRL allows you to express complex invariants in your types. You can write proofs that your code satisfies these invariants, and the compiler checks them.</p>"},{"location":"book/00-intro/#extensibility","title":"Extensibility","text":"<p>The \"Lisp\" in the name isn't just about parentheses. It's about the philosophy that the language should be programmable. Macros allow you to define new syntactic forms that desugar into core concepts, making the language adaptable to your domain.</p>"},{"location":"book/00-intro/#three-small-examples","title":"Three Small Examples","text":"<pre><code>;; 1) Correctness: proof checked by type checker.\n(def zero-is-zero (Eq Nat zero zero)\n  (refl Nat zero))\n\n;; 2) Resource discipline: borrowing is explicit.\n(noncomputable shared-borrow (pi x Nat Nat)\n  (lam x Nat\n    (let r (Ref #[r] Shared Nat) (&amp; x)\n      x)))\n\n;; 3) Extensibility: syntax transformation via macro.\n(defmacro mk-inc (v)\n  (quasiquote (add (unquote v) (succ zero))))\n\n(def demo Nat (mk-inc (succ zero)))\n</code></pre> <p>These examples illustrate a recurring theme in LRL: strong static guarantees with straightforward runtime behavior.</p>"},{"location":"book/00-intro/#what-lrl-is-not","title":"What LRL is NOT","text":"<ul> <li>A Dynamic Scripting Language: While it looks like Lisp, it is statically typed and compiled.</li> <li>A General Proof Assistant: While it has proof capabilities, the focus is on verifying software, not general mathematics (though it shares the same foundations as Lean/Coq).</li> <li>Finished: LRL is currently in Alpha.</li> </ul>"},{"location":"book/01-getting-started/","title":"Getting Started","text":""},{"location":"book/01-getting-started/#prerequisites","title":"Prerequisites","text":"<p>To build LeanRustLisp (LRL), you need the standard Rust toolchain installed: 1. <code>rustc</code> 2. <code>cargo</code></p> <p>If you don't have these, install them via rustup.rs.</p>"},{"location":"book/01-getting-started/#building-from-source","title":"Building from Source","text":"<p>Clone the repository and build the workspace:</p> <pre><code>git clone https://github.com/leanrustlisp/leanrustlisp\ncd leanrustlisp\ncargo build\n</code></pre> <p>The compiled binaries will be in <code>target/debug</code>.</p>"},{"location":"book/01-getting-started/#running-the-repl","title":"Running the REPL","text":"<p>The easiest way to explore LRL is the Read-Eval-Print Loop (REPL).</p> <pre><code>cargo run -p cli\n</code></pre> <p>You should see a prompt: <pre><code>LRL&gt;\n</code></pre></p> <p>Try typing a simple expression: <pre><code>LRL&gt; (add 1 2)\n3 : Int\n// Result evaluation and type\n</code></pre></p>"},{"location":"book/01-getting-started/#running-a-file","title":"Running a File","text":"<p>To interpret an LRL file directly:</p> <pre><code>cargo run -p cli -- path/to/file.lrl\n</code></pre> <p>For example, try running one of the tests: <pre><code>cargo run -p cli -- tests/simple_test.lrl\n</code></pre></p>"},{"location":"book/01-getting-started/#your-first-program-hello-world","title":"Your First Program: Hello World","text":"<p>Let's write and understand a complete Hello World program in LRL.</p>"},{"location":"book/01-getting-started/#step-1-create-the-file","title":"Step 1: Create the File","text":"<p>Create a new file called <code>hello.lrl</code>:</p> <pre><code>;; hello.lrl - Your first LRL program\n\n(def entry Text\n  (print \"Hello, World!\"))\n</code></pre> <p>The program defines a <code>main</code> entry point that prints a greeting.</p>"},{"location":"book/01-getting-started/#step-2-run-it","title":"Step 2: Run It","text":"<pre><code>cargo run -p cli -- compile hello.lrl\n./build/output\n</code></pre> <p>You should see: <pre><code>Hello, World!\n</code></pre></p>"},{"location":"book/01-getting-started/#step-3-understanding-the-code","title":"Step 3: Understanding the Code","text":"<p>Let's break down each element:</p>"},{"location":"book/01-getting-started/#comments","title":"Comments","text":"<pre><code>;; hello.lrl - Your first LRL program\n</code></pre> <p>Lines starting with <code>;;</code> are comments. They're ignored by the compiler.</p>"},{"location":"book/01-getting-started/#string-literals","title":"String Literals","text":"<pre><code>\"Hello, World!\"\n</code></pre> <p>Text enclosed in double quotes <code>\"...\"</code> is a string literal. LRL automatically converts this into a <code>Text</code> value.</p>"},{"location":"book/01-getting-started/#the-program-structure","title":"The Program Structure","text":"<pre><code>(def entry Text\n  (print \"Hello, World!\"))\n</code></pre> <ul> <li><code>def</code> \u2014 Introduces a new definition</li> <li><code>entry</code> \u2014 The name of the definition (the last expression is evaluated)</li> <li><code>Text</code> \u2014 The return type (print returns the text it prints)</li> <li><code>(print ...)</code> \u2014 The body of the definition</li> <li><code>print</code> \u2014 A built-in function that outputs <code>Text</code> to the console</li> </ul>"},{"location":"book/01-getting-started/#a-more-interesting-example","title":"A More Interesting Example","text":"<p>Let's create a program with multiple definitions:</p> <pre><code>;; greet.lrl - A greeting program\n\n(def name Text \"LRL User\")\n\n(def entry Text\n  (print name))\n</code></pre> <p>Run it: <pre><code>cargo run -p cli -- compile greet.lrl &amp;&amp; ./build/output\n</code></pre></p> <p>Output: <pre><code>LRL User\n</code></pre></p>"},{"location":"book/01-getting-started/#defining-values","title":"Defining Values","text":"<pre><code>(def name Text \"LRL User\")\n</code></pre> <ul> <li><code>def</code> \u2014 Introduces a definition</li> <li><code>name</code> \u2014 The identifier</li> <li><code>Text</code> \u2014 The type (required)</li> <li><code>\"LRL User\"</code> \u2014 The value</li> </ul>"},{"location":"book/01-getting-started/#printing-numbers","title":"Printing Numbers","text":"<p>You can also print numbers directly:</p> <pre><code>;; numbers.lrl - Print some numbers\n\n(def answer Nat (+ 2 3))\n(print_nat answer)\n</code></pre> <p>Output: <pre><code>5\n</code></pre></p>"},{"location":"book/01-getting-started/#understanding-nat","title":"Understanding Nat","text":"<ul> <li><code>Nat</code> \u2014 Natural numbers (0, 1, 2, ...)</li> <li><code>+</code> \u2014 Addition operator (prefix notation)</li> <li><code>print_nat</code> \u2014 Prints a natural number</li> </ul> <p>LRL also supports signed integers (<code>Int</code>) and floating-point numbers (<code>Float</code>):</p> <pre><code>(def x Int (- 3 5))       ;; -2 (signed subtraction)\n(def y Float (+f 1.5 2.5)) ;; 4.0 (float addition)\n</code></pre>"},{"location":"book/01-getting-started/#why-s-expressions","title":"Why S-Expressions?","text":"<p>You might wonder why LRL uses parentheses everywhere. This is called S-expression syntax (from Lisp). The benefits:</p> <ol> <li>Homoiconicity \u2014 Code is data, making macros natural</li> <li>Unambiguous parsing \u2014 No precedence rules to remember</li> <li>Easy to extend \u2014 Adding new syntax forms is trivial</li> </ol> <p>Once you get used to it, <code>(+ 1 2)</code> reads just as naturally as <code>1 + 2</code>.</p>"},{"location":"book/01-getting-started/#compiling-to-binary","title":"Compiling to Binary","text":"<p>To compile an LRL program to a standalone executable:</p> <pre><code>cargo run -p cli -- compile path/to/file.lrl -o my_program\n./my_program\n</code></pre>"},{"location":"book/01-getting-started/#debugging-and-inspection","title":"Debugging and inspection","text":"<p>LRL provides several flags to help you understand what the compiler is doing.</p>"},{"location":"book/01-getting-started/#macro-expansion","title":"Macro Expansion","text":"<p>To see how your macros expand, use specific flags. Note that you must provide a file argument.</p> <ul> <li><code>--expand-1</code>: Expands top-level macros one step.</li> <li><code>--expand-full</code>: Fully expands all macros.</li> <li><code>--trace-expand</code>: Shows the expansion process step-by-step.</li> </ul> <pre><code>cargo run -p cli -- --expand-1 path/to/file.lrl\n</code></pre>"},{"location":"book/01-getting-started/#trace-macros","title":"Trace Macros","text":"<p>To see macro expansion traces while running or compiling: <pre><code>cargo run -p cli -- --trace-macros path/to/file.lrl\n</code></pre></p>"},{"location":"book/01-getting-started/#definitional-equality-fuel","title":"Definitional Equality Fuel","text":"<p>If you hit recursion limits during type checking, you can increase the \"fuel\" for the definitional equality checker: <pre><code>cargo run -p cli -- --defeq-fuel 1000000 path/to/file.lrl\n</code></pre></p>"},{"location":"book/02-language-tour/","title":"A Tour of LeanRustLisp","text":"<p>This chapter takes you through a whirlwind tour of LRL's core features.</p>"},{"location":"book/02-language-tour/#1-defining-inductive-types","title":"1. Defining Inductive Types","text":"<p>LRL uses inductive types to define data structures. Here is the classic definition of natural numbers.</p> <pre><code>(inductive Nat (sort 1)\n  (ctor zero Nat)\n  (ctor succ (pi n Nat Nat)))\n</code></pre> <ul> <li><code>Nat</code> is the type name.</li> <li><code>(sort 1)</code> is its universe.</li> <li><code>zero</code> is a constructor that is a <code>Nat</code>.</li> <li><code>succ</code> is a constructor that takes a <code>Nat</code> and returns a <code>Nat</code>.</li> </ul>"},{"location":"book/02-language-tour/#2-defining-functions","title":"2. Defining Functions","text":"<p>We can define functions using <code>def</code> and <code>lam</code> (lambda).</p> <pre><code>(def one Nat (succ zero))\n\n(def inc (pi n Nat Nat)\n  (lam n Nat\n    (succ n)))\n</code></pre>"},{"location":"book/02-language-tour/#3-pattern-matching","title":"3. Pattern Matching","text":"<p>We use <code>match</code> to deconstruct inductive types.</p> <pre><code>(def is-zero (pi n Nat Bool)\n  (lam n Nat\n    (match n Bool\n      (case (zero) true)\n      (case (succ m ih) false))))\n</code></pre> <p>Note: <code>Bool</code>, <code>true</code>, and <code>false</code> are defined in the standard prelude.</p>"},{"location":"book/02-language-tour/#4-evaluation","title":"4. Evaluation","text":"<p>You can evaluate expressions in the REPL or at the top level of a file (which prints the result).</p> <pre><code>(is-zero zero)\n;; Output: true : Bool\n\n(is-zero (succ zero))\n;; Output: false : Bool\n</code></pre>"},{"location":"book/02-language-tour/#5-macro-expansion","title":"5. Macro Expansion","text":"<p>Macros allow you to extend syntax at compile time. A simple example:</p> <pre><code>(defmacro plus_two (x)\n  (quasiquote (add (unquote x) (succ (succ zero)))))\n\n(def x Nat (succ zero))\n(def y Nat (plus_two x))\n;; Expands to: (add x (succ (succ zero)))\n</code></pre> <p>Macros operate on syntax objects (<code>x</code> is syntax) and return new syntax.</p>"},{"location":"book/02-language-tour/#6-dependent-types","title":"6. Dependent Types","text":"<p>LRL is dependently typed: types can mention values. <code>Eq</code> in the prelude is a simple indexed family.</p> <pre><code>(def zero-is-zero (Eq Nat zero zero)\n  (refl Nat zero))\n</code></pre>"},{"location":"book/02-language-tour/#7-positive-properties-at-a-glance","title":"7. Positive Properties at a Glance","text":"<p>This small group of definitions shows three useful guarantees.</p> <pre><code>;; 1) Total structural recursion.\n(def nat-pred (pi n Nat Nat)\n  (lam n Nat\n    (match n Nat\n      (case (zero) zero)\n      (case (succ n-prev ih) n-prev))))\n\n;; 2) Hygienic macro expansion (no accidental capture).\n(defmacro m1 (body) (lam x Nat body))\n(def y0 Nat 10)\n(def still-y0 Nat (app (m1 y0) 99)) ;; evaluates to 10\n\n;; 3) Proof-carrying API: proof is checked statically.\n(def with-self-eq\n  (pi n Nat (pi p (Eq Nat n n) Nat))\n  (lam n Nat\n    (lam p (Eq Nat n n)\n      n)))\n\n(def checked-one Nat\n  (with-self-eq (succ zero) (refl Nat (succ zero))))\n</code></pre> <p>The compiler checks each property (termination shape, hygiene, and proof typing) before runtime.</p>"},{"location":"book/03-basic-syntax/","title":"Basic Syntax","text":"<p>LRL uses S-expressions (symbolic expressions, or \"sexprs\") as its surface syntax. If you've used Lisp or Scheme, this will feel familiar. If not, don't worry\u2014it's very simple.</p>"},{"location":"book/03-basic-syntax/#atoms-and-lists","title":"Atoms and Lists","text":"<p>The code is made of atoms and lists.</p>"},{"location":"book/03-basic-syntax/#atoms","title":"Atoms","text":"<ul> <li>Integers: <code>0</code>, <code>42</code>, <code>-123</code></li> <li>Strings: <code>\"Hello world\"</code></li> <li>Symbols: <code>foo</code>, <code>Nat</code>, <code>add</code>, <code>+</code></li> <li>Keywords: There are a few reserved keywords like <code>def</code>, <code>lam</code>, <code>match</code>, but most \"keywords\" are just symbols that macros recognize.</li> </ul>"},{"location":"book/03-basic-syntax/#lists","title":"Lists","text":"<p>A list is parentheses surrounding zero or more elements separated by whitespace. - <code>()</code> : The empty list (nil). - <code>(add 1 2)</code> : A list with three elements. - <code>(lam x (sort 0) x)</code> : Nested lists.</p>"},{"location":"book/03-basic-syntax/#comments","title":"Comments","text":"<p>Line comments start with <code>;</code>. <pre><code>; This is a comment\n(def x Nat zero) ; This is also a comment\n</code></pre></p>"},{"location":"book/03-basic-syntax/#binding-forms","title":"Binding Forms","text":""},{"location":"book/03-basic-syntax/#lambda-lam","title":"Lambda (<code>lam</code>)","text":"<p>Constructs an anonymous function. <pre><code>(lam parameter type body)\n</code></pre> Example: <pre><code>(lam x Nat (succ x))\n</code></pre></p>"},{"location":"book/03-basic-syntax/#let-let","title":"Let (<code>let</code>)","text":"<p>Local bindings. <pre><code>(let x 1\n  (add x x))\n</code></pre> Note: <code>let</code> syntax might vary depending on macro definition in prelude, but conceptually it binds a value to a name in a scope.</p>"},{"location":"book/03-basic-syntax/#definitions-def","title":"Definitions (<code>def</code>)","text":"<p>Top-level definitions bind a name to a value globally. <pre><code>(def name type value)\n</code></pre> Example: <pre><code>(def my-num Nat (succ zero))\n</code></pre></p>"},{"location":"book/03-basic-syntax/#reading-error-messages","title":"Reading Error Messages","text":"<p>LRL tries to provide helpful error spans.</p> <pre><code>Error: Type mismatch\n  --&gt; my_file.lrl:10:5\n   |\n10 | (add true 1)\n   |      ^^^^\n   |\n   = Expected type: Int\n   = Found type: Bool\n</code></pre> <p>When macros are involved, the error might point to the expansion or the original source, depending on where the error was detected. Use <code>--trace-macros</code> if you are confused about where an error is coming form.</p>"},{"location":"book/04-types-terms/","title":"Types and Terms","text":"<p>In LRL, terms and types are unified (to an extent). However, there is a strict hierarchy of universes.</p>"},{"location":"book/04-types-terms/#prop-and-type","title":"Prop and Type","text":"<p>LRL distinguishes between logical propositions and computational data.</p> <ul> <li><code>Prop</code>: The universe of logical propositions. Elements of <code>Prop</code> are erased at runtime.</li> <li><code>Type n</code>: The universe of computational types at level <code>n</code>. <code>Type 0</code> is the type of ordinary data types like <code>Nat</code> and <code>Bool</code>. <code>Type 1</code> is the type of <code>Type 0</code>, and so on.</li> </ul>"},{"location":"book/04-types-terms/#functions-pi-types","title":"Functions (Pi Types)","text":"<p>The type of a function is written as a Pi type (dependent product).</p> <pre><code>(pi (x A) B)\n</code></pre> <p>If <code>B</code> does not depend on <code>x</code>, this is a simple function arrow <code>A -&gt; B</code>.</p> <pre><code>(-&gt; Nat Nat)  ; Simple function\n(pi (n Nat) (Vec Nat n)) ; Dependent function\n</code></pre>"},{"location":"book/04-types-terms/#dependent-types","title":"Dependent Types","text":"<p>Dependent types allow types to depend on values. A classic existence proof is \"safe vector access\" or \"vectors of a specific length\".</p>"},{"location":"book/04-types-terms/#example-polymorphic-identity","title":"Example: Polymorphic Identity","text":"<pre><code>(def id (pi (A (Type 0)) (-&gt; A A))\n  (lam A (Type 0) (lam x A x)))\n\n(id Nat zero) \n;; A is explicitly passed as Nat\n</code></pre> <p>Note: In future versions, implicit arguments will make this less verbose.</p>"},{"location":"book/04-types-terms/#definitional-equality","title":"Definitional Equality","text":"<p>The type checker considers two terms equal if they reduce to the same normal form. This includes:</p> <ul> <li>Beta (\u03b2) reduction: Applying a lambda <code>(lam x t) u</code> reduces to <code>t[x/u]</code>.</li> <li>Delta (\u03b4) reduction: Unfolding a definition. <code>id</code> reduces to its body.</li> <li>Iota (\u03b9) reduction: Pattern matching reduction (e.g., <code>match (succ n)</code> reduces to the succ branch).</li> </ul> <p>This means you don't need to manually prove that <code>(add 1 2)</code> equals <code>3</code>. They are definitionally equal.</p>"},{"location":"book/05-inductives-match/","title":"Inductives and Matching","text":"<p>Inductive types are the fundamental way to define data in LRL.</p>"},{"location":"book/05-inductives-match/#defining-inductives","title":"Defining Inductives","text":"<p>Use the <code>inductive</code> form.</p> <pre><code>(inductive List (-&gt; (Type 0) (Type 0))\n  (nil (List A))\n  (cons (-&gt; A (List A) (List A))))\n</code></pre> <ul> <li>Parameters: <code>List</code> takes a parameter <code>(Type 0)</code> implicitly by the kind signature.</li> <li>Constructors: list the constructors and their full types.</li> </ul>"},{"location":"book/05-inductives-match/#pattern-matching","title":"Pattern Matching","text":"<p>The <code>match</code> expression allows you to branch on constructors.</p> <pre><code>(def length (-&gt; (List Nat) Nat)\n  (lam l (List Nat)\n    (match l\n      (nil zero)\n      (cons h t (succ (length t))))))\n</code></pre>"},{"location":"book/05-inductives-match/#recursion","title":"Recursion","text":"<p>Recursive functions like <code>length</code> are allowed, but the kernel checks termination. The simplest form of termination is structural recursion on an inductive argument.</p>"},{"location":"book/05-inductives-match/#pitfalls","title":"Pitfalls","text":"<ul> <li>Missing Cases: All constructors must be covered.</li> <li>Erasure: You cannot pattern match on a <code>Prop</code> (proof) to produce a <code>Type</code> (data) result. This is a fundamental restriction to ensure proofs can be erased.</li> </ul>"},{"location":"book/06-definitions-modules/","title":"Definitions and Modules","text":""},{"location":"book/06-definitions-modules/#definitions","title":"Definitions","text":"<p>You've already seen <code>def</code>.</p> <pre><code>(def name type value)\n</code></pre> <p>Definitions are opaque if you mark them as <code>opaque</code> (future feature), but by default, they are transparent\u2014the type checker can unfold them to see their value.</p>"},{"location":"book/06-definitions-modules/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Types/Inductives: CamelCase (e.g., <code>Nat</code>, <code>List</code>, <code>MyType</code>).</li> <li>Functions/Values: kebab-case (e.g., <code>add</code>, <code>is-valid</code>, <code>my-function</code>).</li> <li>Constructors: kebab-case or CamelCase depending on preference (stdlib usually uses lowercase for constructors like <code>zero</code>, <code>succ</code>, <code>true</code>, <code>false</code>).</li> </ul>"},{"location":"book/06-definitions-modules/#modules-planned","title":"Modules (Planned)","text":"<p>LRL has a preliminary concept of modules based on files.</p> <ul> <li>Each file is a module.</li> <li><code>prelude</code> is implicitly imported.</li> </ul> <p>Note: The module system is currently under active development. Expect changes here.</p>"},{"location":"book/06-definitions-modules/#the-standard-library","title":"The Standard Library","text":"<p>The standard library is located in <code>stdlib/</code>.</p> <ul> <li><code>stdlib/prelude_api.lrl</code>: Shared public prelude contract (names/types/functions).</li> <li><code>stdlib/prelude_impl_dynamic.lrl</code>: Dynamic backend platform layer.</li> <li><code>stdlib/prelude_impl_typed.lrl</code>: Typed/auto backend platform layer.</li> </ul> <p>User code should target the API contract, not backend-specific prelude files. Shared logic belongs in <code>prelude_api.lrl</code>; impl preludes are for backend-dependent runtime/platform wiring.</p>"},{"location":"book/07-effects-io/","title":"Effects and IO","text":"<p>LRL separates pure logic from side effects.</p>"},{"location":"book/07-effects-io/#the-io-effect","title":"The <code>IO</code> Effect","text":"<p>Conceptually, IO is not \"just another value transform\"; it marks interaction with the outside world.</p> <p>Note: The effect system is still in early alpha. Currently, we largely model IO via monads, but a full algebraic effect system is planned.</p>"},{"location":"book/07-effects-io/#purity","title":"Purity","text":"<p>LRL, like Lean/Coq, is pure. A function <code>Nat -&gt; Nat</code> always returns the same output for the same input and has no observable side effects.</p> <pre><code>(def double (pi n Nat Nat)\n  (lam n Nat\n    (add n n)))\n</code></pre>"},{"location":"book/07-effects-io/#current-alpha-surface","title":"Current Alpha Surface","text":"<p>In current builds, common effectful operations are exposed through prelude functions such as <code>print</code>, <code>read_file</code>, and <code>write_file</code>.</p> <pre><code>(def echo-file Text\n  (let contents Text (read_file \"input.txt\")\n    (write_file \"output.txt\" contents)))\n\n(def entry Text\n  (print \"Hello, world!\"))\n</code></pre>"},{"location":"book/07-effects-io/#why-separation","title":"Why separation?","text":"<p>Strict separation allows the compiler to erase proofs and pure computations that aren't needed at runtime, while guaranteeing that \"safe\" code doesn't accidentally wipe your hard drive.</p> <p>It also gives a practical benefit today: the same source can be validated in a more pure/dynamic environment and then compiled on the typed backend where platform hooks perform real side effects.</p>"},{"location":"book/08-ownership-borrowing/","title":"Ownership and Borrowing","text":"<p>LRL adopts Rust's ownership model to manage memory without a garbage collector.</p>"},{"location":"book/08-ownership-borrowing/#ownership","title":"Ownership","text":"<p>Every value in LRL has a single owner. When you pass a non-<code>Copy</code> value to a function, you move it, transferring ownership.</p> <pre><code>(inductive Resource (sort 1)\n  (ctor acquire Resource))\n\n(def use-resource (pi r Resource Nat)\n  (lam r Resource zero))\n\n(def create-and-use Nat\n  (use-resource acquire))\n</code></pre>"},{"location":"book/08-ownership-borrowing/#copy-types","title":"Copy Types","text":"<p>Simple types like <code>Nat</code> and <code>Bool</code> are <code>Copy</code>. They are duplicated when passed, so the original remains usable.</p>"},{"location":"book/08-ownership-borrowing/#borrowing","title":"Borrowing","text":"<p>You can allow temporary access to a value via references.</p> <ul> <li><code>&amp;T</code>: Shared (immutable) reference. Many allowed.</li> <li><code>&amp;mut T</code>: Mutable reference. Only one allowed (exclusive).</li> </ul> <p>Borrow-centric examples often use <code>noncomputable</code> because references are lowered by the MIR phase.</p>"},{"location":"book/08-ownership-borrowing/#the-rules-of-borrowing","title":"The Rules of Borrowing","text":"<ol> <li>At any given time, you can have either one mutable reference or any number of immutable references.</li> <li>References must always be valid.</li> </ol>"},{"location":"book/08-ownership-borrowing/#positive-example-multiple-shared-borrows","title":"Positive Example: Multiple Shared Borrows","text":"<pre><code>(noncomputable use-shared (pi r (Ref #[r] Shared Nat) Nat)\n  (lam r (Ref #[r] Shared Nat) zero))\n\n(noncomputable shared-borrows-ok (pi x Nat Nat)\n  (lam x Nat\n    (let r1 (Ref #[r] Shared Nat) (&amp; x)\n      (let r2 (Ref #[r] Shared Nat) (&amp; x)\n        (use-shared r1)))))\n</code></pre> <p>This is accepted: multiple shared borrows can coexist.</p>"},{"location":"book/08-ownership-borrowing/#positive-example-branch-local-borrows","title":"Positive Example: Branch-Local Borrows","text":"<pre><code>(noncomputable use-mut (pi r (Ref #[r] Mut Nat) Nat)\n  (lam r (Ref #[r] Mut Nat) zero))\n\n(noncomputable branch-borrow-ok (pi x Nat (pi n Nat Nat))\n  (lam x Nat\n    (lam n Nat\n      (match n Nat\n        (case (zero)\n          (let r (Ref #[r] Shared Nat) (&amp; x)\n            (use-shared r)))\n        (case (succ k)\n          (let m (Ref #[r] Mut Nat) (&amp;mut x)\n            (use-mut m)))))))\n</code></pre> <p>This is also accepted: borrows scoped inside separate match branches do not conflict.</p>"},{"location":"book/08-ownership-borrowing/#rejected-example-shared-then-mutable","title":"Rejected Example: Shared Then Mutable","text":"<pre><code>(noncomputable borrow-then-mutate (pi x Nat Nat)\n  (lam x Nat\n    (let r (Ref #[r] Shared Nat) (&amp; x)\n      (let m (Ref #[r] Mut Nat) (&amp;mut x)\n        (use-shared r)))))\n</code></pre> <p><code>borrow-then-mutate</code> is rejected: mutable and shared borrows overlap on the same value.</p> <p>This discipline prevents data races and iterator invalidation at compile time.</p>"},{"location":"book/09-macros-metaprogramming/","title":"Macros and Metaprogramming","text":"<p>LRL is a Lisp, so code is data. Macros allow you to transform code at compile time.</p>"},{"location":"book/09-macros-metaprogramming/#defining-macros","title":"Defining Macros","text":"<p>Use <code>defmacro</code>.</p> <pre><code>(defmacro mk-inc (val)\n  (quasiquote (add (unquote val) (succ zero))))\n</code></pre> <p>Example use:</p> <pre><code>(def x Nat (succ (succ zero)))\n(def y Nat (mk-inc x))\n;; expands to: (add x (succ zero))\n</code></pre> <p>Macro expansion runs before type checking.</p>"},{"location":"book/09-macros-metaprogramming/#hygiene","title":"Hygiene","text":"<p>LRL macros are hygienic. This means variables introduced by macros don't accidentally capture variables from the user's code, and vice versa.</p> <pre><code>(defmacro m1 (body) (lam x Nat body))\n(def y Nat 10)\n(def always-y (pi _ Nat Nat) (m1 y))\n(def r1 Nat (app always-y 99)) ;; 10\n\n(defmacro m2 () (lam x Nat x))\n(def x Nat 5)\n(def id-from-macro (pi _ Nat Nat) (m2))\n(def r2 Nat (app id-from-macro 100)) ;; 100\n\n(def z Nat 7)\n(defmacro m3 () z)\n(def r3 Nat (app (lam z Nat (m3)) 8)) ;; 7\n</code></pre> <p>In <code>r1</code>, the macro's internal binder does not capture <code>y</code>. In <code>r2</code>, call-site <code>x</code> does not capture the macro-generated <code>x</code>. In <code>r3</code>, local <code>z</code> does not capture macro <code>z</code>.</p>"},{"location":"book/09-macros-metaprogramming/#debugging-macros","title":"Debugging Macros","text":"<p>If a macro behaves unexpectedly, inspect expansions:</p> <pre><code>cargo run -p cli -- --expand-1 my_file.lrl\ncargo run -p cli -- --expand-full my_file.lrl\ncargo run -p cli -- --trace-macros my_file.lrl\n</code></pre> <p>This gives a deterministic view of exactly what code the type checker receives.</p>"},{"location":"book/10-proofs-tactics/","title":"Proofs and Tactics","text":"<p>LRL follows the Curry-Howard correspondence: Propositions are Types and Proofs are Programs.</p>"},{"location":"book/10-proofs-tactics/#propositions-are-types","title":"Propositions are Types","text":"<p>To prove a statement <code>P</code>, you define a type <code>P</code> and construct a term <code>t : P</code>.</p> <pre><code>;; Proposition: 0 = 0\n(def zero-is-zero (Eq Nat zero zero)\n  (refl Nat zero))\n</code></pre>"},{"location":"book/10-proofs-tactics/#checked-proof-arguments","title":"Checked Proof Arguments","text":"<p>You can require proofs in APIs:</p> <pre><code>(def with-self-eq\n  (pi n Nat (pi p (Eq Nat n n) Nat))\n  (lam n Nat\n    (lam p (Eq Nat n n)\n      n)))\n\n(def one Nat (succ zero))\n(def one-is-one (Eq Nat one one)\n  (refl Nat one))\n\n(def checked-one Nat\n  (with-self-eq one one-is-one))\n</code></pre> <p><code>checked-one</code> only exists if the proof term type-checks.</p>"},{"location":"book/10-proofs-tactics/#proof-erasure","title":"Proof Erasure","text":"<p>Terms in <code>Prop</code> are erased at runtime. In practice, this means proof-heavy APIs can compile down to the same runtime behavior as proof-free equivalents.</p>"},{"location":"book/10-proofs-tactics/#why-this-is-useful","title":"Why This Is Useful","text":"<ul> <li>You can enforce invariants statically.</li> <li>You avoid runtime checks for those invariants when they are proven.</li> <li>You keep runtime code lean while still carrying strong compile-time guarantees.</li> </ul> <p>Note: tactics are planned but not yet implemented. Today, proofs are written as explicit terms.</p>"},{"location":"book/11-ffi-unsafe/","title":"FFI and Unsafe","text":"<p>Just like Rust, LRL has an <code>unsafe</code> keyword that allows you to bypass certain checks.</p>"},{"location":"book/11-ffi-unsafe/#unsafe","title":"Unsafe","text":"<p><code>unsafe</code> blocks allow you to: - Call <code>extern</code> functions (FFI). - Dereference raw pointers. - Implement <code>unsafe</code> traits.</p> <pre><code>(unsafe\n  (call-external-function args))\n</code></pre>"},{"location":"book/11-ffi-unsafe/#foreign-function-interface-ffi","title":"Foreign Function Interface (FFI)","text":"<p>LRL can link against C ABI libraries.</p> <pre><code>(extern \"C\" {\n  (def put-char (-&gt; Int Int))\n})\n</code></pre>"},{"location":"book/11-ffi-unsafe/#safe-wrappers","title":"Safe Wrappers","text":"<p>The idiomatic way to handle unsafe code is to wrap it in a safe interface that enforces the invariants that the compiler can't check.</p> <pre><code>(def print-secure (-&gt; String Unit)\n  (lam s String\n    (unsafe\n       ;; ... low level implementation ...\n       unit)))\n</code></pre>"},{"location":"book/12-performance-debugging/","title":"Performance and Debugging","text":""},{"location":"book/12-performance-debugging/#performance-model","title":"Performance Model","text":"<p>LRL compiles to native code via Rust.</p> <ul> <li>Erasure: Everything in <code>Prop</code> is erased.</li> <li>Monomorphization: Generic functions are typically monomorphized (like Rust), leading to efficient code but larger binaries.</li> <li>Reference Counting: Currently, some structures may use RC, but the goal is affine types minimizing this overhead.</li> </ul>"},{"location":"book/12-performance-debugging/#positive-property-examples","title":"Positive Property Examples","text":""},{"location":"book/12-performance-debugging/#proof-carrying-api-without-runtime-proof-cost","title":"Proof-Carrying API Without Runtime Proof Cost","text":"<pre><code>(def with-self-eq\n  (pi n Nat (pi p (Eq Nat n n) Nat))\n  (lam n Nat\n    (lam p (Eq Nat n n)\n      (add n n))))\n\n(def entry Nat\n  (with-self-eq (succ (succ zero))\n                (refl Nat (succ (succ zero)))))\n</code></pre> <p><code>p</code> is checked by the type checker but erased at runtime.</p>"},{"location":"book/12-performance-debugging/#predictable-structural-cost","title":"Predictable Structural Cost","text":"<pre><code>(def sum-list (pi xs (List Nat) Nat)\n  (lam xs (List Nat)\n    (match xs Nat\n      (case (nil) zero)\n      (case (cons h t ih) (add h ih)))))\n</code></pre> <p><code>sum-list</code> does one recursive step per element. No hidden tracing GC pauses are introduced by this definition pattern.</p>"},{"location":"book/12-performance-debugging/#debugging","title":"Debugging","text":""},{"location":"book/12-performance-debugging/#inspecting-generated-code","title":"Inspecting Generated Code","text":"<p>If you compile with: <pre><code>cargo run -p cli -- compile file.lrl -o out --backend typed\n</code></pre> The compiler currently generates an intermediate Rust file <code>output.rs</code> in <code>build/</code>. You can inspect this to see exactly what LRL is producing.</p> <p>Useful companions while debugging:</p> <pre><code>cargo run -p cli -- compile-mir file.lrl\ncargo run -p cli -- --expand-full file.lrl\n</code></pre> <ul> <li><code>compile-mir</code> helps verify borrow/lifetime lowering.</li> <li><code>--expand-full</code> lets you inspect macro output before type checking.</li> </ul>"},{"location":"book/12-performance-debugging/#profiling","title":"Profiling","text":"<p>(Future) Integration with standard profilers like <code>perf</code> or <code>Instruments</code> is planned.</p>"},{"location":"book/13-idioms-style/","title":"Idioms and Style","text":""},{"location":"book/13-idioms-style/#style-guidelines","title":"Style Guidelines","text":"<ul> <li>Indent: 2 spaces.</li> <li>Line Length: 80-100 characters.</li> <li>Parentheses: Don't leave dangling parentheses.</li> <li>Good: <code>(list 1 2 3)</code></li> <li>Bad: <code>(list 1 2 3 )</code></li> </ul>"},{"location":"book/13-idioms-style/#macro-discipline","title":"Macro Discipline","text":"<p>Don't use macros just because you can. - Use Functions when possible. They are easier to type-check and debug. - Use Macros for control flow (like <code>if</code>, <code>match</code>), binding forms, or DSLs.</p>"},{"location":"book/13-idioms-style/#proofs","title":"Proofs","text":"<p>Keep proofs separate from logic where possible, or use the <code>Prop</code> universe to ensure they don't impact runtime performance.</p>"},{"location":"book/90-faq/","title":"FAQ","text":""},{"location":"book/90-faq/#why-is-inference-limited","title":"Why is inference limited?","text":"<p>Full type inference for dependent types is undecidable. LRL relies on bidirectional typing, which requires annotations in top-level definitions and some other places, but infers types for most expressions.</p>"},{"location":"book/90-faq/#why-cant-types-depend-on-partial-code","title":"Why can't types depend on partial code?","text":"<p>If a type depends on a function that loops forever, the type checker would loop forever. Logic requires total functions.</p>"},{"location":"book/90-faq/#why-does-borrow-checking-exist-if-we-transpile-to-rust","title":"Why does borrow checking exist if we transpile to Rust?","text":"<p>LRL's borrow checker runs on MIR before codegen. It mirrors Rust's rules to ensure that the generated Rust code is valid and safe, providing error messages in terms of LRL source code rather than confusing Rust compiler errors.</p>"},{"location":"book/90-faq/#how-do-i-do-dynamic-stuff","title":"How do I do dynamic stuff?","text":"<p>Use the <code>Dyn</code> type or <code>Any</code>. We support a \"dynamic backend\" which is more permissive, but the \"typed backend\" enforces static discipline.</p>"},{"location":"book/99-glossary/","title":"Glossary","text":"<ul> <li>Kernel: The trusted core component that verifies fully elaborated terms.</li> <li>Elaboration: The process of converting surface syntax (with implicit arguments) into fully explicit core terms.</li> <li>Definitional Equality: Two terms are definitionally equal if they reduce to the same form.</li> <li>Prop: The universe of propositions. Elements are proofs and are erased at runtime.</li> <li>Type: The universe of types. Elements are data and are preserved at runtime (mostly).</li> <li>Motive: The return type function for a recursor/match expression.</li> <li>Eliminator: A function that destructs an inductive value (like <code>Nat.rec</code>).</li> <li>MIR: Mid-level Intermediate Representation. A control-flow graph representation used for optimizations and borrow checking.</li> <li>Region: A static scope in the program (lifetime).</li> <li>Hygiene: The property of macros that prevents accidental variable capture.</li> <li>Staging: The separation of compile-time (macro expansion) and runtime execution.</li> <li>Capability: A token representing permission to perform an effect.</li> </ul>"},{"location":"book/SUMMARY/","title":"Summary","text":"<ul> <li>Introduction</li> <li>Getting Started</li> <li>Language Tour</li> <li>Basic Syntax</li> <li>Types and Terms</li> <li>Inductives and Matching</li> <li>Definitions and Modules</li> <li>Effects and IO</li> <li>Ownership and Borrowing</li> <li>Macros and Metaprogramming</li> <li>Proofs and Tactics</li> <li>FFI and Unsafe</li> <li>Performance and Debugging</li> <li>Idioms and Style</li> <li>FAQ</li> <li>Glossary</li> </ul>"},{"location":"dev/architecture/","title":"Compiler Architecture (Deterministic IDs + Pipeline Spine)","text":"<p>This document captures architectural invariants needed for typed backends and stable builds.</p>"},{"location":"dev/architecture/#deterministic-id-registry","title":"Deterministic ID Registry","text":"<p>A single registry mints nominal IDs during declaration loading/elaboration. IDs are derived from: - PackageId (name + version + source + hash) - ModulePath - ItemName - Disambiguator (only when required)</p> <p>Definitions: - DefId: top-level definition (functions, constants, axioms) - AdtId: inductive type definition - CtorId: (AdtId, ctor_index) - FieldId: (CtorId, field_index)</p> <p>Rules: - IDs are deterministic and build-stable. - IDs are not minted in MIR passes. - No semantic pass (borrowck/codegen/typing) depends on raw strings.</p>"},{"location":"dev/architecture/#phase-spine-single-pipeline","title":"Phase Spine (Single Pipeline)","text":"<p>Source \u2192 parse \u2192 macro-expand \u2192 elaborate \u2192 kernel check \u2192 lower to MIR \u2192 NLL borrow check \u2192 codegen</p> <p>Notes: - Macros are syntax-only and do not mint semantic IDs. - Elaboration resolves identifiers and assigns DefId/AdtId/CtorId/FieldId. - MIR and downstream passes consume IDs and metadata only.</p>"},{"location":"dev/architecture/#runtime-layout-policy","title":"Runtime Layout Policy","text":"<p>Dependent indices do not affect runtime layout. Runtime-dependent indices must be explicit fields in the runtime representation.</p>"},{"location":"dev/architecture/#interior-mutability-policy","title":"Interior Mutability Policy","text":"<p>Interior mutability is expressed by marker traits/attributes resolved to DefId-based flags during elaboration. The panic-free profile rejects any interior mutability (RefCell/Mutex/Atomic).</p>"},{"location":"dev/architecture/#sanity-rule","title":"Sanity Rule","text":"<p>Borrow checking, MIR typing, and codegen must never depend on raw strings for semantic identity. All semantics are keyed by IDs (including PackageId).</p>"},{"location":"dev/backend_conformance_report/","title":"Backend Conformance Report","text":""},{"location":"dev/backend_conformance_report/#scope","title":"Scope","text":"<ul> <li>Harness: <code>/Volumes/Crucial X6/MacBook/Code/leanrustlisp/cli/tests/backend_conformance.rs</code></li> <li>Subset spec: <code>/Volumes/Crucial X6/MacBook/Code/leanrustlisp/docs/dev/backend_conformance_subset.md</code></li> <li>Overlap tests: <code>/Volumes/Crucial X6/MacBook/Code/leanrustlisp/tests/backend_conformance/cases/overlap</code></li> <li>Excluded tests: <code>/Volumes/Crucial X6/MacBook/Code/leanrustlisp/tests/backend_conformance/cases/excluded</code></li> </ul>"},{"location":"dev/backend_conformance_report/#results","title":"Results","text":"<p>Command: - <code>cargo test -p cli --test backend_conformance -- --test-threads=1</code></p> <p>Current status: - Overlap-subset tests: 13 total, 13 matching, 0 failing - Excluded tests: 4 (documented exclusions, not compared)</p>"},{"location":"dev/backend_conformance_report/#mismatch-triage-history-and-fixes","title":"Mismatch Triage History and Fixes","text":"<p>Initial conformance run found overlap mismatches in dynamic backend execution. Root causes and fixes:</p> <ol> <li>Bool/Nat discriminant semantics mismatch</li> <li>Minimal repros:</li> <li><code>/Volumes/Crucial X6/MacBook/Code/leanrustlisp/tests/backend_conformance/cases/overlap/bool_not.lrl</code></li> <li><code>/Volumes/Crucial X6/MacBook/Code/leanrustlisp/tests/backend_conformance/cases/overlap/bool_to_nat.lrl</code></li> <li>Observed:</li> <li>Dynamic backend interpreted builtin discriminants inconsistently with ctor indices.</li> <li>Fix:</li> <li>Added <code>runtime_discriminant</code> and switched MIR discriminant/switch lowering to it in <code>/Volumes/Crucial X6/MacBook/Code/leanrustlisp/mir/src/codegen.rs</code>.</li> <li>Regression coverage:</li> <li> <p>Bool and Nat overlap cases above now pass.</p> </li> <li> <p>Builtin field projection mismatch (Nat/List)</p> </li> <li>Minimal repros:</li> <li><code>/Volumes/Crucial X6/MacBook/Code/leanrustlisp/tests/backend_conformance/cases/overlap/nat_pred.lrl</code></li> <li><code>/Volumes/Crucial X6/MacBook/Code/leanrustlisp/tests/backend_conformance/cases/overlap/nat_add_recursive.lrl</code></li> <li><code>/Volumes/Crucial X6/MacBook/Code/leanrustlisp/tests/backend_conformance/cases/overlap/nat_double.lrl</code></li> <li><code>/Volumes/Crucial X6/MacBook/Code/leanrustlisp/tests/backend_conformance/cases/overlap/nested_match_maybe.lrl</code></li> <li><code>/Volumes/Crucial X6/MacBook/Code/leanrustlisp/tests/backend_conformance/cases/overlap/tree_sum_three.lrl</code></li> <li>Observed:</li> <li>Dynamic backend projected fields only from <code>Value::Inductive</code>, but builtin runtime values (<code>Nat</code>, <code>List</code>) use specialized representations.</li> <li>Fix:</li> <li>Added <code>runtime_project_field</code> and routed field projection through it in <code>/Volumes/Crucial X6/MacBook/Code/leanrustlisp/mir/src/codegen.rs</code>.</li> <li>Regression coverage:</li> <li>Nat recursion and nested/user-ADT overlap cases above now pass.</li> </ol>"},{"location":"dev/backend_conformance_report/#conformance-decision","title":"Conformance Decision","text":"<ul> <li>For the defined overlap subset, typed and dynamic backends are currently conformant to validated MIR semantics.</li> <li>Remaining excluded areas are intentionally documented and not treated as conformance failures.</li> </ul>"},{"location":"dev/backend_conformance_subset/","title":"Backend Conformance Subset","text":"<p>This document defines the stable, testable overlap used to compare dynamic and typed backends.</p>"},{"location":"dev/backend_conformance_subset/#mir-semantic-truth-for-this-subset","title":"MIR Semantic Truth (for this subset)","text":"<p>A program is in conformance when all of the following hold after MIR validation (typing + ownership + NLL):</p> <ol> <li>The same validated MIR is used for both backends.</li> <li>Observable behavior matches expected semantics:</li> <li>Exit code matches expected exit code.</li> <li>Canonical final result matches expected result (<code>nat:N</code> or <code>bool:true|false</code>).</li> <li>Non-result stdout lines match exactly.</li> <li>Dynamic and typed backend observables are identical for the same MIR.</li> </ol> <p>Harness location: - <code>/Volumes/Crucial X6/MacBook/Code/leanrustlisp/cli/tests/backend_conformance.rs</code></p>"},{"location":"dev/backend_conformance_subset/#prelude-compatibility-policy","title":"Prelude Compatibility Policy","text":"<p>By default, conformance tests use a minimal compatibility prelude: - <code>/Volumes/Crucial X6/MacBook/Code/leanrustlisp/tests/backend_conformance/conformance_prelude.lrl</code></p> <p>This prelude intentionally defines only shared core data needed by the subset (<code>Nat</code>, <code>Bool</code>).</p> <p>Case-level prelude override is supported via metadata: - <code>;;! prelude: &lt;path&gt;</code></p> <p>This is used for targeted API-layer checks when needed (for example, shared prelude <code>append</code> behavior).</p> <p>Rationale: - Full API+platform stacks still differ in runtime-oriented boundaries (<code>Dyn</code>/<code>EvalCap</code>/<code>eval</code>, runtime checks). - The mission compares backend faithfulness to MIR semantics in the overlap, not prelude feature parity.</p>"},{"location":"dev/backend_conformance_subset/#included-constructs-overlap-subset","title":"Included Constructs (Overlap Subset)","text":"<p>Included and required to match: - <code>Nat</code>, <code>Bool</code> - Non-parameterized user ADTs - Constructor application - <code>match</code> / <code>switch</code> - Nested <code>match</code> - <code>let</code> and simple function calls - Basic recursion over <code>Nat</code></p> <p>Current overlap corpus: - <code>/Volumes/Crucial X6/MacBook/Code/leanrustlisp/tests/backend_conformance/cases/overlap</code></p>"},{"location":"dev/backend_conformance_subset/#excluded-constructs","title":"Excluded Constructs","text":"<p>Excluded from conformance matching (documented as tagged tests): - Dynamic eval boundary (<code>Dyn</code>/<code>EvalCap</code> semantics) - Interior mutability runtime checks (<code>RefCell</code>/<code>Mutex</code>/<code>Atomic</code> behavior) - Indexed/runtime-check lowering edge cases not jointly stabilized - Higher-order closure capture modes outside stable overlap - Any program relying on known prelude representation differences</p> <p>Excluded corpus: - <code>/Volumes/Crucial X6/MacBook/Code/leanrustlisp/tests/backend_conformance/cases/excluded</code></p>"},{"location":"dev/backend_conformance_subset/#why-these-exclusions-exist","title":"Why These Exclusions Exist","text":"<ul> <li>They require additional runtime contracts or backend-specific machinery that is not yet jointly specified and stabilized.</li> <li>Including them now would mix conformance bugs with intentionally incomplete feature work, reducing signal quality.</li> </ul>"},{"location":"dev/build/","title":"Build Instructions","text":""},{"location":"dev/build/#requirements","title":"Requirements","text":"<ul> <li>Rust (latest stable).</li> </ul>"},{"location":"dev/build/#commands","title":"Commands","text":"<pre><code>cargo build --release\ncargo test\ncargo run -p cli -- compile tests/file.lrl\n</code></pre>"},{"location":"dev/build/#environment-variables","title":"Environment Variables","text":"<ul> <li><code>LRL_DEFEQ_FUEL</code>: Control kernel fuel.</li> <li><code>RUST_LOG</code>: Enable logging (if env_logger is configured).</li> </ul>"},{"location":"dev/contributing/","title":"Contributing to LeanRustLisp","text":""},{"location":"dev/contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the repo.</li> <li><code>cargo test</code> to ensure everything is working.</li> <li>Pick an issue or start a discussion.</li> </ol>"},{"location":"dev/contributing/#pull-requests","title":"Pull Requests","text":"<ul> <li>Keep PRs focused.</li> <li>Add tests for new features (<code>tests/*.lrl</code>).</li> <li>Run <code>cargo fmt</code> and <code>cargo clippy</code>.</li> </ul>"},{"location":"dev/prelude_api_parity_report/","title":"Prelude API Parity Report","text":""},{"location":"dev/prelude_api_parity_report/#scope","title":"Scope","text":"<p>This report compares:</p> <ul> <li>shared API layer: <code>stdlib/prelude_api.lrl</code></li> <li>dynamic platform layer: <code>stdlib/prelude_impl_dynamic.lrl</code></li> <li>typed platform layer: <code>stdlib/prelude_impl_typed.lrl</code></li> </ul> <p>and classifies divergences.</p>"},{"location":"dev/prelude_api_parity_report/#shared-api-coverage","title":"Shared API Coverage","text":"<p>The following are provided through <code>prelude_api.lrl</code> for both backend stacks:</p> <ul> <li>Core types: <code>Nat</code>, <code>Bool</code>, <code>False</code>, <code>List</code>, <code>Comp</code>, <code>Eq</code></li> <li>Core functions: <code>add</code>, <code>append</code>, <code>not</code>, <code>if_nat</code>, <code>and</code>, <code>or</code>, <code>print_nat</code>, <code>print_bool</code></li> <li>Borrow/index boundaries: <code>Shared</code>, <code>Mut</code>, <code>Ref</code>, <code>borrow_shared</code>, <code>borrow_mut</code>, <code>VecDyn</code>, <code>Slice</code>, <code>Array</code>, <code>index_*</code></li> <li>Interior mutability declarations: <code>RefCell</code>, <code>Mutex</code>, <code>Atomic</code></li> <li>Marker axioms: <code>interior_mutable</code>, <code>may_panic_on_borrow_violation</code>, <code>concurrency_primitive</code>, <code>atomic_primitive</code>, <code>indexable</code></li> </ul>"},{"location":"dev/prelude_api_parity_report/#divergences","title":"Divergences","text":"Item Dynamic Typed Classification Note <code>Dyn</code>, <code>EvalCap</code>, <code>eval</code> Axiom-based placeholders Concrete typed ADTs + identity <code>eval</code> Feature-gated (explicit) Kept backend-specific until effect/runtime model converges"},{"location":"dev/prelude_api_parity_report/#api-notes","title":"API notes","text":"<ul> <li><code>append</code> is executable in <code>prelude_api.lrl</code> and shared by both backends.</li> <li>Current signature is Nat-list focused: <code>append : List Nat -&gt; List Nat -&gt; List Nat</code>.</li> <li>Backend impl preludes do not redefine <code>append</code>; they only provide platform-layer substrate.</li> </ul>"},{"location":"dev/prelude_api_parity_report/#temporarily-gated-features","title":"Temporarily Gated Features","text":"<ul> <li>Interior mutability runtime behavior (<code>RefCell</code>/<code>Mutex</code> checks): declared in API, runtime behavior still backend/runtime-gated.</li> <li>Dynamic boundary (<code>Dyn</code>/<code>EvalCap</code>/<code>eval</code>): backend-specific representation and execution model.</li> <li>Axiom execution: blocked by default; enabled only under <code>--allow-axioms</code>, with loud warnings and artifact metadata.</li> </ul>"},{"location":"dev/prelude_api_parity_report/#platform-layer-status","title":"Platform Layer Status","text":"<p>Current impl layers are restricted to runtime substrate declarations (<code>Dyn</code>, <code>EvalCap</code>, <code>eval</code>) and no longer carry shared stdlib algorithms.</p>"},{"location":"dev/prelude_api_parity_report/#stdlib-ownership","title":"Stdlib Ownership","text":"<p>Public contract ownership:</p> <ul> <li><code>prelude_api.lrl</code> owns the exported prelude contract (names and signatures visible to user code).</li> <li>User code must rely on this contract, not on backend impl files.</li> </ul> <p>Implementation ownership:</p> <ul> <li><code>prelude_impl_dynamic.lrl</code> and <code>prelude_impl_typed.lrl</code> own only platform-dependent runtime substrate.</li> <li>They must not become duplicate stdlib layers.</li> </ul> <p>Shared-library ownership:</p> <ul> <li>Backend-neutral algorithms belong in shared stdlib modules (<code>stdlib/std/*</code>) as migration proceeds.</li> <li>Until migration completes, shared algorithms may remain in <code>prelude_api.lrl</code>, but must still be defined once and never duplicated in impl preludes.</li> </ul> <p>Policy classification:</p> <ul> <li>Must fix for 0.1: accidental shared algorithm duplication in impl preludes.</li> <li>Allowed divergence (documented): <code>Dyn</code>/<code>EvalCap</code>/<code>eval</code> representation and execution model.</li> <li>Feature-gated: interior mutability runtime checks and executable axioms.</li> </ul>"},{"location":"dev/release/","title":"Release Process","text":"<ol> <li>Update version in <code>Cargo.toml</code>.</li> <li>Update <code>docs/reference/versioning.md</code> if language version changes.</li> <li>Run full test suite.</li> <li>Tag release on GitHub.</li> <li>Publish to crates.io (future).</li> </ol>"},{"location":"dev/roadmap/","title":"Roadmap","text":""},{"location":"dev/roadmap/#phase-1-core-kernel-done","title":"Phase 1: Core Kernel (Done)","text":"<ul> <li>CIC, Universes, Inductives.</li> </ul>"},{"location":"dev/roadmap/#phase-2-frontend-macros-in-progress","title":"Phase 2: Frontend &amp; Macros (In Progress)","text":"<ul> <li>Parser, Elaborator, Hygienic Macros.</li> </ul>"},{"location":"dev/roadmap/#phase-3-codegen-in-progress","title":"Phase 3: Codegen (In Progress)","text":"<ul> <li>Tyed backend lowering to Rust.</li> </ul>"},{"location":"dev/roadmap/#future","title":"Future","text":"<ul> <li>Package Manager.</li> <li>Language Server (LSP).</li> <li>Stdlib expansion (<code>List</code>, <code>String</code>, <code>IO</code>).</li> <li>Algebraic Effects.</li> </ul>"},{"location":"dev/security/","title":"Security Policy","text":""},{"location":"dev/security/#reporting-vulnerabilities","title":"Reporting Vulnerabilities","text":"<p>Please report security issues via GitHub Security Advisories or email maintainers directly.</p>"},{"location":"dev/security/#trusted-base","title":"Trusted Base","text":"<p>The <code>kernel</code> crate is the critical component for logical soundness. Bugs in <code>frontend</code> or <code>codegen</code> may cause crashes or wrong output but should not compromise the logical TCB of the verifier itself.</p>"},{"location":"dev/standard_library_plan/","title":"Standard Library Development Plan (LRL 0.1 -&gt; 0.2)","text":""},{"location":"dev/standard_library_plan/#purpose","title":"Purpose","text":"<p>Define a concrete, testable roadmap to move from a prelude-centric alpha setup to a real standard library with:</p> <ul> <li>one public API contract (<code>prelude_api</code>)</li> <li>tiny backend platform shims (<code>prelude_impl_dynamic</code>, <code>prelude_impl_typed</code>)</li> <li>shared backend-neutral stdlib modules for user-facing logic</li> <li>compact, readable syntax conventions suitable for day-to-day programming</li> </ul> <p>This plan assumes current backend architecture and ownership/type/NLL rules remain authoritative.</p>"},{"location":"dev/standard_library_plan/#current-baseline-as-of-this-plan","title":"Current Baseline (as of this plan)","text":"<ul> <li>Prelude architecture already exists:</li> <li><code>stdlib/prelude_api.lrl</code> (public contract)</li> <li><code>stdlib/prelude_impl_dynamic.lrl</code> (dynamic platform layer)</li> <li><code>stdlib/prelude_impl_typed.lrl</code> (typed platform layer)</li> <li>Shared API contains core types/functions (<code>Nat</code>, <code>Bool</code>, <code>List</code>, <code>add</code>, <code>append</code>, etc.).</li> <li>Platform layers are small and mostly runtime-boundary definitions (<code>Dyn</code>, <code>EvalCap</code>, <code>eval</code>).</li> <li>Function application already accepts multiple arguments in one form:</li> <li><code>(f a b c)</code> parses/desugars as chained application.</li> <li>Function definition type/binder syntax is still mostly unary/curried at core level:</li> <li>explicit nested <code>lam</code>/<code>pi</code> style remains canonical.</li> </ul>"},{"location":"dev/standard_library_plan/#design-principles","title":"Design Principles","text":"<ol> <li>Single public contract</li> <li>User code targets API names/types, not backend-specific files.</li> <li> <p>No user program should import or depend on <code>prelude_impl_*</code>.</p> </li> <li> <p>One stdlib, two tiny platforms</p> </li> <li>Shared algorithms live once under <code>stdlib/std/*</code>.</li> <li> <p><code>prelude_impl_dynamic.lrl</code> and <code>prelude_impl_typed.lrl</code> stay platform-only.</p> </li> <li> <p>Backend-neutral semantics first</p> </li> <li>Any function in shared stdlib must compile under both backends.</li> <li> <p>Differences are allowed only for explicitly documented platform boundaries.</p> </li> <li> <p>Strictly test-driven migration</p> </li> <li>Every moved/added stdlib function gets compile + behavior checks.</li> <li> <p>Conformance tests gate dynamic/typed parity for overlap subset.</p> </li> <li> <p>Syntax compactness without semantic shortcuts</p> </li> <li>Keep core calculus unchanged (curried semantics).</li> <li>Add/desugar ergonomic sugar to reduce boilerplate where safe.</li> </ol>"},{"location":"dev/standard_library_plan/#target-stdlib-layout","title":"Target Stdlib Layout","text":"<pre><code>stdlib/\n  prelude_api.lrl\n  prelude_impl_dynamic.lrl\n  prelude_impl_typed.lrl\n  std/\n    core/\n      bool.lrl\n      nat.lrl\n      logic.lrl\n    data/\n      list.lrl\n      option.lrl\n      result.lrl\n      pair.lrl\n    control/\n      comp.lrl\n      maybe.lrl\n    text/\n      show_nat.lrl\n      show_bool.lrl\n    laws/\n      eq.lrl\n      order.lrl\n</code></pre> <p>Notes: - <code>prelude_api.lrl</code> should expose minimal bootstrap names and import/open stable std modules as needed. - Keep <code>print_*</code> and runtime-boundary hooks near prelude/API layer until IO surface is stabilized.</p>"},{"location":"dev/standard_library_plan/#scope-definition","title":"Scope Definition","text":""},{"location":"dev/standard_library_plan/#in-scope-01-02","title":"In scope (0.1 -&gt; 0.2)","text":"<ul> <li>Core data + algorithms that are backend-neutral:</li> <li><code>Bool</code>, <code>Nat</code>, <code>List</code>, <code>Option</code>, <code>Result</code>, <code>Pair</code></li> <li>list operations (<code>length</code>, <code>map</code>, <code>foldl</code>, <code>foldr</code>, <code>reverse</code>, <code>filter</code>)</li> <li>Nat utilities (<code>pred</code>, <code>sub</code> bounded, comparisons)</li> <li>boolean combinators and conditionals</li> <li>Effect-safe helpers around existing <code>Comp</code> API.</li> <li>Documentation of stable API signatures and behavior laws.</li> <li>Syntax ergonomics for multi-argument definitions (sugar/desugar level).</li> </ul>"},{"location":"dev/standard_library_plan/#explicitly-out-of-scope-for-this-phase","title":"Explicitly out of scope for this phase","text":"<ul> <li>New kernel features.</li> <li>Ownership rule relaxation.</li> <li>Runtime redesign of interior mutability.</li> <li>Full trait/typeclass ecosystem.</li> <li>Full numeric hierarchy beyond <code>Nat</code>.</li> </ul>"},{"location":"dev/standard_library_plan/#multi-argument-functions-and-syntax-compactness","title":"Multi-Argument Functions and Syntax Compactness","text":""},{"location":"dev/standard_library_plan/#status-today","title":"Status today","text":"<ul> <li>Call side already compact:</li> <li><code>(f a b c)</code> works as chained application.</li> <li>Definition side is verbose:</li> <li>nested <code>(lam x T (lam y U ...))</code></li> <li>nested <code>(pi x T (pi y U ...))</code></li> </ul>"},{"location":"dev/standard_library_plan/#plan","title":"Plan","text":"<ol> <li>Add accepted sugar (desugars to current core forms):</li> <li><code>(lam (x T) (y U) body)</code> -&gt; nested unary <code>lam</code></li> <li> <p><code>(pi (x T) (y U) R)</code> -&gt; nested unary <code>pi</code></p> </li> <li> <p>Optional sugar for compact stdlib authoring:</p> </li> <li>Arrow shorthand for non-dependent function spaces (if parser/desugar already prepared):</li> <li> <p><code>(-&gt; A B C)</code> -&gt; <code>(pi _ A (pi _ B C))</code></p> </li> <li> <p>Keep canonical lowering unchanged:</p> </li> <li>Core term representation remains curried/unary.</li> <li> <p>No MIR/codegen special-cases for multi-arg functions.</p> </li> <li> <p>Formatting guidance for compactness:</p> </li> <li>Prefer one-screen definitions.</li> <li>Prefer shared helpers over deeply nested matches.</li> <li>Keep binder lists short and explicit.</li> </ol>"},{"location":"dev/standard_library_plan/#phase-plan","title":"Phase Plan","text":""},{"location":"dev/standard_library_plan/#phase-s0-bootstrap-and-invariants","title":"Phase S0: Bootstrap and invariants","text":"<p>Deliverables: - <code>docs/spec/prelude_api.md</code> updated with stdlib migration boundary. - <code>docs/dev/prelude_api_parity_report.md</code> includes \"stdlib ownership\" section. - New guard: <code>prelude_impl_*</code> must not define shared algorithms.</p> <p>Acceptance: - CI fails if platform preludes add non-platform algorithms.</p>"},{"location":"dev/standard_library_plan/#phase-s1-module-scaffolding","title":"Phase S1: Module scaffolding","text":"<p>Deliverables: - Create <code>stdlib/std/core</code>, <code>stdlib/std/data</code>, <code>stdlib/std/control</code>. - Move current pure definitions from <code>prelude_api.lrl</code> into modules where possible. - Keep compatibility exports in <code>prelude_api.lrl</code>.</p> <p>Acceptance: - Existing programs compile unchanged. - No API symbol disappearance.</p>"},{"location":"dev/standard_library_plan/#phase-s2-core-data-apis","title":"Phase S2: Core data APIs","text":"<p>Deliverables: - <code>std/core/bool.lrl</code>: <code>not</code>, <code>and</code>, <code>or</code>, <code>if_nat</code> variants. - <code>std/core/nat.lrl</code>: <code>add</code>, <code>pred</code>, bounded <code>sub</code>, comparisons. - <code>std/data/list.lrl</code>: <code>append</code>, <code>length</code>, <code>map</code>, <code>foldr</code>, <code>foldl</code>.</p> <p>Acceptance: - Unit-style compile tests for each module. - Dynamic/typed parity tests for pure overlap subset.</p>"},{"location":"dev/standard_library_plan/#phase-s3-optionresultpair-and-ergonomics","title":"Phase S3: Option/Result/Pair and ergonomics","text":"<p>Deliverables: - <code>std/data/option.lrl</code>, <code>std/data/result.lrl</code>, <code>std/data/pair.lrl</code>. - Basic combinators: <code>map</code>, <code>and_then</code>/<code>bind</code>, <code>unwrap_or</code> equivalents. - Multi-binder <code>lam</code>/<code>pi</code> sugar shipped for stdlib authoring.</p> <p>Acceptance: - Syntax contract updated. - Parser/desugar tests for new sugar. - No backend divergence introduced.</p>"},{"location":"dev/standard_library_plan/#phase-s4-control-and-effect-adapters","title":"Phase S4: Control and effect adapters","text":"<p>Deliverables: - <code>std/control/comp.lrl</code> utilities around <code>Comp</code>. - Explicit boundary docs for <code>Dyn</code>/<code>EvalCap</code>/<code>eval</code> platform differences.</p> <p>Acceptance: - Shared modules compile under both backends. - Any backend-specific behavior documented and test-gated.</p>"},{"location":"dev/standard_library_plan/#phase-s5-law-docs-and-quality-bar","title":"Phase S5: Law docs and quality bar","text":"<p>Deliverables: - Behavioral docs for core functions (identity/associativity-like laws where relevant). - Complexity notes (e.g., <code>append</code> linear in left list). - Examples curated for both interpreter and compile modes.</p> <p>Acceptance: - Documentation coverage checklist passes. - Conformance suite includes representative stdlib functions.</p>"},{"location":"dev/standard_library_plan/#testing-strategy","title":"Testing Strategy","text":"<ol> <li>API conformance</li> <li> <p>Verify required symbols/types after loading API + backend impl.</p> </li> <li> <p>Stdlib module compile tests</p> </li> <li> <p>Compile each module and representative import/usage programs.</p> </li> <li> <p>Backend conformance</p> </li> <li> <p>For overlap subset, run same programs under dynamic + typed and compare observable output.</p> </li> <li> <p>Corpus checks</p> </li> <li>All <code>tests/**/*.lrl</code> classified as expected pass/fail.</li> <li> <p>Ensure stdlib migration does not increase unexpected failures.</p> </li> <li> <p>Syntax sugar tests</p> </li> <li>Snapshot tests for desugaring <code>(lam (x T) (y U) ...)</code> and <code>(pi ...)</code> multi-binder forms.</li> </ol>"},{"location":"dev/standard_library_plan/#migration-rules-important","title":"Migration Rules (important)","text":"<ol> <li>Do not break existing names in <code>prelude_api</code> during 0.1.</li> <li>If moving a function from prelude to module, keep a stable exported alias.</li> <li>Any semantic change requires:</li> <li>changelog note</li> <li>conformance evidence</li> <li>regression test</li> </ol>"},{"location":"dev/standard_library_plan/#risks-and-mitigations","title":"Risks and Mitigations","text":"<ol> <li>Risk: accidental dual-stdlib drift</li> <li> <p>Mitigation: enforce platform-layer guard + parity report in CI.</p> </li> <li> <p>Risk: syntax sugar introduces ambiguity</p> </li> <li> <p>Mitigation: desugar-only implementation with strict grammar tests.</p> </li> <li> <p>Risk: backend divergence in recursive/container functions</p> </li> <li> <p>Mitigation: conformance tests per function family (<code>append</code>, <code>map</code>, <code>fold*</code>).</p> </li> <li> <p>Risk: oversized prelude_api</p> </li> <li>Mitigation: prelude_api remains contract/export surface, logic moves to <code>stdlib/std/*</code>.</li> </ol>"},{"location":"dev/standard_library_plan/#concrete-02-success-criteria","title":"Concrete 0.2 Success Criteria","text":"<ul> <li>Shared stdlib modules exist and hold most pure algorithms.</li> <li>Platform impl preludes remain tiny and backend-specific only.</li> <li>Multi-arg definition sugar is available and documented.</li> <li>At least 20 stdlib-focused conformance tests pass under both backends.</li> <li>User guidance clearly states a single prelude API contract and stable stdlib entrypoints.</li> </ul>"},{"location":"dev/standard_library_plan/#immediate-next-steps","title":"Immediate Next Steps","text":"<ol> <li>Create <code>stdlib/std/core</code> and <code>stdlib/std/data</code> module files with current pure functions.</li> <li>Add parser/desugar support tests for multi-binder <code>lam</code>/<code>pi</code> sugar.</li> <li>Wire compatibility exports from <code>prelude_api.lrl</code> to new stdlib modules.</li> <li>Extend conformance suite with stdlib function programs (<code>append</code>, <code>length</code>, <code>map</code>, <code>pred</code>).</li> </ol>"},{"location":"dev/style/","title":"Style Guide","text":""},{"location":"dev/style/#rust-code","title":"Rust Code","text":"<ul> <li>Follow standard Rust formatting (<code>rustfmt</code>).</li> <li>Use <code>clippy</code> to catch common issues.</li> </ul>"},{"location":"dev/style/#lrl-code","title":"LRL Code","text":"<ul> <li>Lisp-style indentation (usually 2 spaces).</li> <li><code>kebab-case</code> for identifiers.</li> <li><code>CamelCase</code> for Types/Constructors.</li> </ul>"},{"location":"internals/INDEX/","title":"Internals Documentation","text":"<p>Documentation for LRL contributors.</p> <ul> <li>Architecture</li> <li>Trusted Base</li> <li>Kernel Guide</li> <li>Elaborator Guide</li> <li>Macro Expander Guide</li> <li>MIR &amp; BC Guide</li> <li>Codegen Guide</li> <li>Testing Guide</li> </ul>"},{"location":"internals/architecture/","title":"Architecture Overview","text":"<p>The LeanRustLisp (LRL) compiler is structured as a pipeline of distinct crates, each with a specific responsibility. This separation is crucial for the \"trusted kernel\" architecture.</p>"},{"location":"internals/architecture/#high-level-pipeline","title":"High-Level Pipeline","text":"<ol> <li>Source (<code>.lrl</code>) is parsed into a Syntax Tree (<code>frontend</code>).</li> <li>Macros are expanded to produce a fully expanded Syntax Tree (<code>frontend</code>).</li> <li>Desugaring converts Syntax to Surface Terms (<code>frontend</code>).</li> <li>Elaboration converts Surface Terms to Core Terms (<code>kernel</code>), handling type inference and implicit arguments.</li> <li>Kernel verifies the Core Terms (type checking, definitional equality).</li> <li>MIR Lowering converts Core Terms to Mid-level Intermediate Representation (MIR) (<code>mir</code>).</li> <li>Borrow Checking enforces ownership and lifetimes on MIR (<code>mir</code>).</li> <li>Codegen translates MIR to target code (Rust/Binary) (<code>codegen</code>).</li> </ol>"},{"location":"internals/architecture/#crate-responsibilities","title":"Crate Responsibilities","text":""},{"location":"internals/architecture/#kernel-the-trusted-base","title":"<code>kernel</code> (The Trusted Base)","text":"<ul> <li>Role: The minimal, trusted core that verifies the correctness of the program.</li> <li>Key Modules:</li> <li><code>ast</code>: Defines the Core Calculus (terms, inductives, universes).</li> <li><code>checker</code>: Implements type checking rules.</li> <li><code>nbe</code>: Normalization by Evaluation (for definitional equality).</li> <li><code>ownership</code>: Core ownership definitions.</li> </ul>"},{"location":"internals/architecture/#frontend-untrusted","title":"<code>frontend</code> (Untrusted)","text":"<ul> <li>Role: User-facing features, parsing, and elaborating into the core.</li> <li>Key Modules:</li> <li><code>parser</code>: S-expression parser.</li> <li><code>macro_expander</code>: Hygienic macro system implementation.</li> <li><code>elaborator</code>: Type inference and bidirectional typing to produce Core Terms.</li> <li><code>diagnostics</code>: Error reporting.</li> </ul>"},{"location":"internals/architecture/#mir-optimization-safety","title":"<code>mir</code> (Optimization &amp; Safety)","text":"<ul> <li>Role: Intermediate representation for analysis and optimization.</li> <li>Key Features:</li> <li>Control-flow graph construction.</li> <li>Borrow checker (NLL-style).</li> <li>Optimizations.</li> </ul>"},{"location":"internals/architecture/#codegen-backend","title":"<code>codegen</code> (Backend)","text":"<ul> <li>Role: Emitting executable code.</li> <li>Targets:</li> <li>Rust (transpilation).</li> <li>LLVM (future).</li> </ul>"},{"location":"internals/architecture/#cli-driver","title":"<code>cli</code> (Driver)","text":"<ul> <li>Role: Command-line interface and REPL.</li> <li>Features:</li> <li>Orchestrates the pipeline.</li> <li>Manages compiler flags and modes.</li> </ul>"},{"location":"internals/architecture/#data-structures","title":"Data Structures","text":"<ul> <li>Syntax: <code>frontend::surface::Syntax</code> (S-expressions with spans).</li> <li>SurfaceTerm: <code>frontend::surface::Term</code> (Desugared, unresolved names).</li> <li>CoreTerm: <code>kernel::ast::Term</code> (Fully explicit, dependently typed calculus).</li> <li>Env: <code>kernel::checker::Env</code> (Global environment of definitions and inductives).</li> </ul>"},{"location":"internals/codegen-guide/","title":"Codegen Guide","text":""},{"location":"internals/codegen-guide/#overview","title":"Overview","text":"<p>The <code>codegen</code> crate translates MIR to Rust.</p>"},{"location":"internals/codegen-guide/#pipeline","title":"Pipeline","text":"<ol> <li>Lowering: MIR types/statements -&gt; Rust AST.</li> <li>Runtime Support: Linking against <code>lrl_rt</code> (runtime library) which provides <code>Nat</code>, closures, etc.</li> <li>Output: Generates a <code>.rs</code> file which is then compiled by <code>rustc</code>.</li> </ol>"},{"location":"internals/codegen-guide/#erasure","title":"Erasure","text":"<p>Ensure <code>Prop</code> elements are erased to <code>()</code> or dropped entirely.</p>"},{"location":"internals/elaborator-guide/","title":"Elaborator Guide","text":""},{"location":"internals/elaborator-guide/#overview","title":"Overview","text":"<p>The <code>elaborator</code> in <code>frontend/src/elaborator.rs</code> converts surface syntax into kernel terms.</p>"},{"location":"internals/elaborator-guide/#responsibilities","title":"Responsibilities","text":"<ol> <li>Name Resolution: Managing scopes and resolving identifiers.</li> <li>Type Inference: Generating metavariables (<code>?m</code>) for holes and solving them via unification.</li> <li>Implicit Arguments: Inserting code for implicit arguments.</li> <li>Desugaring: Converting <code>match</code> to <code>Rec</code> applications.</li> </ol>"},{"location":"internals/elaborator-guide/#unification","title":"Unification","text":"<p>Bidirectional unification is used. If unification fails, an error is reported with distinct expected vs actual types.</p>"},{"location":"internals/kernel-guide/","title":"Kernel Architecture Guide","text":""},{"location":"internals/kernel-guide/#overview","title":"Overview","text":"<p>The <code>kernel</code> crate is the Trusted Computing Base (TCB).</p>"},{"location":"internals/kernel-guide/#key-modules","title":"Key Modules","text":"<ul> <li><code>ast.rs</code>: Core term definitions (<code>Term</code>, <code>Level</code>).</li> <li><code>checker.rs</code>: Type checker and definitional equality (<code>def_eq</code>).</li> <li><code>nbe.rs</code>: Normalization by Evaluation (the engine for <code>def_eq</code>).</li> <li><code>inductives.rs</code>: Inductive type validity checks (positivity, universe levels).</li> </ul>"},{"location":"internals/kernel-guide/#debugging","title":"Debugging","text":"<p>Use <code>LRL_DEFEQ_FUEL</code> to adjust the fuel limit if the kernel seems to hang (which implies a non-terminating reduction or huge term).</p>"},{"location":"internals/macro-expander-guide/","title":"Macro Expander Guide","text":""},{"location":"internals/macro-expander-guide/#overview","title":"Overview","text":"<p>Macro expansion happens before elaboration.</p>"},{"location":"internals/macro-expander-guide/#mechanism","title":"Mechanism","text":"<ol> <li>The parser produces a <code>Syntax</code> tree.</li> <li>The expander traverses the tree.</li> <li>If it encounters a macro, it invokes the macro function (interpreted).</li> <li>Hygiene is maintained by tracking <code>ScopeId</code>s on syntax nodes.</li> </ol>"},{"location":"internals/macro-expander-guide/#adding-macros","title":"Adding Macros","text":"<p>Macros are defined in standard libraries or user code. The expander must be able to load these definitions (bootstrapping).</p>"},{"location":"internals/mir-bc-guide/","title":"MIR and Bytecode Guide","text":""},{"location":"internals/mir-bc-guide/#mir","title":"MIR","text":"<p>Mid-level IR used for optimization and borrow checking. - Constructed from elaborated terms. - Explicit control flow (CFG).</p>"},{"location":"internals/mir-bc-guide/#bytecode-bc","title":"Bytecode (BC)","text":"<p>Interpreter bytecode used for: - REPL execution. - Macro expansion. - <code>const</code> evaluation.</p> <p>The BC virtual machine is distinct from the compiled output.</p>"},{"location":"internals/testing-guide/","title":"Testing Guide","text":""},{"location":"internals/testing-guide/#test-suites","title":"Test Suites","text":"<ul> <li><code>cargo test</code>: Unit tests for Rust components.</li> <li><code>tests/*.lrl</code>: Integration tests compiled by the CLI.</li> <li><code>compile_test.lrl</code>: Basic compilation check.</li> </ul>"},{"location":"internals/testing-guide/#adding-tests","title":"Adding Tests","text":"<ol> <li>Create a new <code>.lrl</code> file in <code>tests/</code>.</li> <li>Add a <code>RUN</code> directive or similar harness (if applicable) or verify it compiles via <code>cargo run -p cli -- compile tests/new_test.lrl</code>.</li> </ol>"},{"location":"internals/trusted-base/","title":"Trusted Computing Base (TCB)","text":"<p>In LeanRustLisp, the correctness of the entire system relies on a small set of core components known as the Trusted Computing Base (TCB). If the TCB is correct, then all checked programs are type-safe and adhere to the language's logical consistency.</p>"},{"location":"internals/trusted-base/#the-kernel","title":"The Kernel","text":"<p>The primary component of the TCB is the <code>kernel</code> crate.</p> <ul> <li>Type Checker: The rules for type checking (Dependent Pi, Inductives, Sorts) are implemented here.</li> <li>Definitional Equality: The logic for determining if two terms are definitionally equal (beta-reduction, etc.) must be correct.</li> <li>Inductive Validity: The checks for positivity and universe consistency for new inductive types.</li> </ul>"},{"location":"internals/trusted-base/#what-is-not-trusted","title":"What is NOT Trusted","text":"<ul> <li>Frontend: The parser, macro expander, and elaborator are not trusted. If they produce an invalid Core Term, the Kernel will reject it.</li> <li>Type Inference: Inference heuristics in the elaborator are a convenience; the result is always verified by the Kernel.</li> </ul>"},{"location":"internals/trusted-base/#auditing","title":"Auditing","text":"<p>Changes to the <code>kernel</code> directory should be audited with extreme care.</p>"},{"location":"reference/INDEX/","title":"LeanRustLisp Reference","text":"<p>This section provides the normative definition of the LeanRustLisp language.</p> <p>Version: 0.1 Alpha</p>"},{"location":"reference/INDEX/#conformance","title":"Conformance","text":"<p>Implementations MUST adhere to the rules in this section. If the behavior of the compiler contradicts this reference, it is a bug in the compiler (unless this reference is outdated, which is also a bug).</p>"},{"location":"reference/INDEX/#formal-specification","title":"Formal Specification","text":"<p>For the mathematical definitions of the core calculus, see the Spec.</p>"},{"location":"reference/concurrency/","title":"Concurrency","text":"<p>LRL provides primitives for safe concurrency, relying on the type system to prevent data races.</p>"},{"location":"reference/concurrency/#primitives","title":"Primitives","text":"<p>Concurrency support is provided by runtime primitives marked with specific attributes: - <code>concurrency_primitive</code>: Mutexes, Channels. - <code>atomic_primitive</code>: Atomic integers/booleans.</p>"},{"location":"reference/concurrency/#safety","title":"Safety","text":"<p>The type system (and future <code>Send</code>/<code>Sync</code> traits) ensures that mutable data cannot be shared across threads without synchronization (Mutex). - Interior Mutability: Types like <code>RefCell</code> or <code>Mutex</code> allow mutation through shared references (<code>&amp;T</code>). - Markers: The kernel tracks interior mutability via the <code>interior_mutable</code> marker to ensure <code>Copy</code> safety (types with interior mutability cannot be trivially <code>Copy</code> unless safe).</p>"},{"location":"reference/definitional-equality/","title":"Definitional Equality","text":"<p>Definitional equality is the equivalence relation used by the type checker.</p>"},{"location":"reference/definitional-equality/#reductions","title":"Reductions","text":"<ul> <li>Beta (\u03b2): Function application. <code>(\\x. b) a \u2261 b[x/a]</code>.</li> <li>Delta (\u03b4): Constant unfolding. If <code>def x := v</code>, then <code>x \u2261 v</code>.</li> <li>Unfolding is controlled by Transparency. <code>Opaque</code> definitions are not unfolded.</li> <li>Fuel: The checker uses a fuel metric to prevent infinite loops during unfolding of partial or cyclic terms.</li> <li>Iota (\u03b9): Inductive elimination. The application of a recursor <code>Rec</code> to a constructor <code>Ctor</code> reduces to the corresponding minor premise.</li> <li>Eta (\u03b7): Extensionality. <code>(\\x. f x) \u2261 f</code>.</li> <li>Zeta (\u03b6): Let-expansion. <code>let x := v in b \u2261 b[x/v]</code>.</li> </ul>"},{"location":"reference/definitional-equality/#totality","title":"Totality","text":"<p>Only Total definitions are legally unfolded during type checking. Partial definitions cannot be unfolded (to prevent unsoundness/loops in the type checker).</p>"},{"location":"reference/diagnostics/","title":"Diagnostics","text":""},{"location":"reference/diagnostics/#error-codes","title":"Error Codes","text":""},{"location":"reference/diagnostics/#kernel-kxxxx","title":"Kernel (Kxxxx)","text":"<p>Errors dealing with the core logic and type system. - <code>K0001</code>: Unknown variable. - <code>K0002</code>: Type mismatch. - <code>K0005</code>: Unknown inductive. - <code>K0015</code>: Non-positive inductive occurrence. - <code>K0018</code>: Non-terminating recursion. - <code>K0021</code>: Ownership violation.</p>"},{"location":"reference/diagnostics/#frontend-fxxxx","title":"Frontend (Fxxxx)","text":"<p>Errors in parsing or elaboration. - <code>F0001</code>: Unexpected EOF. - <code>F0200</code>: Unbound variable. - <code>F0202</code>: Ambiguous constructor. - <code>F0211</code>: Non-exhaustive match.</p>"},{"location":"reference/diagnostics/#flags","title":"Flags","text":"<ul> <li><code>--trace-macros</code>: Print macro expansion steps.</li> <li><code>--trace-elaboration</code>: Print elaboration trace.</li> <li><code>-D &lt;code/category&gt;</code>: Deny warning.</li> <li><code>-A &lt;code/category&gt;</code>: Allow warning.</li> </ul>"},{"location":"reference/elaboration/","title":"Elaboration","text":"<p>Elaboration is the process of converting the user-friendly surface syntax into the fully explicit core calculus.</p>"},{"location":"reference/elaboration/#type-inference","title":"Type Inference","text":"<p>LRL uses bidirectional type checking. - Inference: Computing the type of a term from its structure. - Checking: Verifying a term against a known expected type.</p> <p>Top-level definitions <code>(def name type val)</code> are checked against the provided signature.</p>"},{"location":"reference/elaboration/#holes-_","title":"Holes (<code>_</code>)","text":"<p>The underscore <code>_</code> allows you to ask the compiler to infer a term or type. - In expressions: <code>(cons 1 _)</code> (infers the tail is nil/empty if constrained). - In types: <code>(Vec _ n)</code> (infers the element type).</p> <p>If the elaborator cannot solve a hole (unresolved metavariable), it reports an error.</p>"},{"location":"reference/elaboration/#implicit-arguments","title":"Implicit Arguments","text":"<p>Functions can declare implicit arguments (syntax to be finalized, usually <code>{x : A}</code>). The elaborator attempts to insert these arguments automatically at call sites.</p>"},{"location":"reference/ffi/","title":"Foreign Function Interface","text":"<p>Interfacing with other languages.</p>"},{"location":"reference/ffi/#extern-blocks","title":"Extern Blocks","text":"<p>Primitive constants can be declared without value.</p> <pre><code>(def my-c-func (-&gt; Int Int))\n</code></pre> <p>To actually link, these must be mapped to native symbols in the backend.</p>"},{"location":"reference/ffi/#unsafe","title":"Unsafe","text":"<p>Calling foreign functions is generally <code>unsafe</code> because the FFI cannot guarantee LRL's invariants (validity, total functions, etc).</p> <p><code>unsafe</code> blocks allow: - Calling external primitives. - Bypassing some memory safety checks.</p>"},{"location":"reference/grammar/","title":"Grammar","text":"<p>This EBNF describes the surface syntax (S-expressions) produced by the parser.</p> <pre><code>program ::= expression*\n\nexpression ::= atom\n             | list\n             | braced_list\n             | quote\n             | quasiquote\n             | unquote\n             | unquote_splicing\n             | index_expr\n\natom ::= INTEGER | STRING | SYMBOL | HOLE\n\nlist ::= '(' expression* ')'\n\nbraced_list ::= '{' expression* '}'\n\nquote ::= \"'\" expression\n\nquasiquote ::= \"`\" expression\n\nunquote ::= \",\" expression\n\nunquote_splicing ::= \",@\" expression\n\nindex_expr ::= expression '[' expression ']' \n/* Parsed as (kind: Index, expr, index) */\n\nINTEGER ::= [0-9]+\nSTRING  ::= '\"' (CHARS | ESCAPE)* '\"'\nHOLE    ::= \"_\"\nSYMBOL  ::= [^ \\t\\n\\r()\\[\\]{}\"',`]+  /* excluding HOLE */\n</code></pre>"},{"location":"reference/inductives/","title":"Inductives","text":"<p>Inductive reference.</p>"},{"location":"reference/inductives/#declaration","title":"Declaration","text":"<pre><code>(inductive Name (Sort u)\n  (ctor1 (-&gt; Arg1 Name))\n  ...)\n</code></pre>"},{"location":"reference/inductives/#universes","title":"Universes","text":"<p>Inductives can live in <code>Prop</code> or <code>Type u</code>. - Prop Inductives: Must not have large elimination (cannot eliminate to <code>Type</code> unless singleton/empty). - Strict Positivity: Recursive occurrences of the inductive type in constructors must be strictly positive (nested to the left of arrows).</p>"},{"location":"reference/inductives/#eliminators","title":"Eliminators","text":"<p>For every inductive <code>T</code>, the kernel generates a recursor <code>T.rec</code>. Surface <code>match</code> expressions are elaborated into applications of <code>T.rec</code>.</p>"},{"location":"reference/io/","title":"Input/Output","text":"<p>LRL encapsulates side effects.</p>"},{"location":"reference/io/#the-io-type","title":"The <code>IO</code> Type","text":"<p><code>IO A</code> is a primitive opaque type representing a computation that performs effects and produces an <code>A</code>.</p>"},{"location":"reference/io/#execution","title":"Execution","text":"<p>The <code>main</code> function must have type <code>IO Unit</code>. The runtime executes this action.</p> <p>(Note: The current IO model is a placeholder. Future versions may use algebraic effects or monad transformers).</p>"},{"location":"reference/lexical/","title":"Lexical Structure","text":"<p>LRL source files must be UTF-8 encoded.</p>"},{"location":"reference/lexical/#whitespace","title":"Whitespace","text":"<p>Whitespace is defined as any character for which <code>char::is_whitespace()</code> returns true (includes spaces, tabs, newlines). Whitespace separates tokens but is otherwise ignored.</p>"},{"location":"reference/lexical/#comments","title":"Comments","text":"<p>Comments start with <code>;</code> and extend to the end of the line.</p> <pre><code>; This is a comment\n(add 1 2) ; Comment at end of line\n</code></pre>"},{"location":"reference/lexical/#identifiers-symbols","title":"Identifiers (Symbols)","text":"<p>Symbols are sequences of characters that are NOT: - Whitespace - Delimiters: <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>{</code>, <code>}</code> - Quotes: <code>'</code>, <code>`</code>, <code>,</code></p> <p>Examples: <code>foo</code>, <code>foo-bar</code>, <code>+</code>, <code>-&gt;</code>, <code>Foo.Bar</code>.</p> <p>Note: The symbol <code>_</code> is reserved as a \"Hole\".</p>"},{"location":"reference/lexical/#literals","title":"Literals","text":""},{"location":"reference/lexical/#integers","title":"Integers","text":"<p>Currently, only unsigned integers fitting in <code>usize</code> are supported by the parser. Regex: <code>[0-9]+</code></p>"},{"location":"reference/lexical/#strings","title":"Strings","text":"<p>Strings are enclosed in double quotes <code>\"</code>. Supported escapes: - <code>\\n</code> (newline) - <code>\\r</code> (carriage return) - <code>\\t</code> (tab) - <code>\\\"</code> (quote) - <code>\\\\</code> (backslash)</p>"},{"location":"reference/lexical/#delimiters","title":"Delimiters","text":"<ul> <li><code>(...)</code>: Standard lists (S-expressions).</li> <li><code>{...}</code>: Braced lists (often used for implicit arguments or blocks, semantically equivalent to lists at parse time).</li> <li><code>[...]</code>: Indexing (postfix). <code>a[b]</code> parses as <code>(index a b)</code>.</li> </ul>"},{"location":"reference/macro-system/","title":"Macro System","text":"<p>LRL provides a hygienic macro system where macros operate on AST nodes (<code>Syntax</code>).</p>"},{"location":"reference/macro-system/#staging","title":"Staging","text":"<p>Macro expansion happens before desugaring and type checking. Macros are executed in a separate interpreter/evaluator environment, but currently share the same process.</p>"},{"location":"reference/macro-system/#hygiene","title":"Hygiene","text":"<p>LRL macros are hygienic by default. - Variables introduced by a macro are marked with a fresh \"scope\". - Variables passed to a macro retain their original scopes.</p> <p>This prevents accidental variable capture (\"the Lisp-1 problem\").</p>"},{"location":"reference/macro-system/#breaking-hygiene","title":"Breaking Hygiene","text":"<p>A macro can intentionally break hygiene by constructing raw symbols without scopes using <code>(datum-&gt;syntax quote-syntax 'symbol)</code>. (API subject to change).</p>"},{"location":"reference/macro-system/#expansion-order","title":"Expansion Order","text":"<p>Macros are expanded outside-in (top-down), but arguments to macros are not expanded before the macro is called (standard Lisp macro behavior).</p>"},{"location":"reference/macro-system/#determinism","title":"Determinism","text":"<p>Macro expansion MUST be deterministic. The same input source code must produce the same output syntax tree.</p>"},{"location":"reference/modules-packages/","title":"Modules and Packages","text":""},{"location":"reference/modules-packages/#files-as-modules","title":"Files as Modules","text":"<p>Every <code>.lrl</code> file is a module. The module name is derived from the filename.</p>"},{"location":"reference/modules-packages/#packages","title":"Packages","text":"<p>(Future Specification) Packages will be managed by a package manager (likely integrated into the CLI), defining dependencies and workspaces.</p>"},{"location":"reference/modules-packages/#visibility","title":"Visibility","text":"<p>Currently, top-level definitions in a module are visible to any module that imports it. (Future: <code>private</code> / <code>pub</code> visibility modifiers).</p>"},{"location":"reference/name-resolution/","title":"Name Resolution","text":"<p>LRL allows breaking programs into modules (files) and managing namespaces.</p>"},{"location":"reference/name-resolution/#scoping-rules","title":"Scoping Rules","text":"<p>Scopes are lexical. Local variables shadow outer variables. Definitions in the same module are visible everywhere in that module (order-independent for top-level <code>def</code>, though the kernel requires valid dependency ordering).</p>"},{"location":"reference/name-resolution/#modules-and-imports","title":"Modules and Imports","text":"<p>Each file is a module. - <code>use &lt;module&gt;</code> opens a module, making its definitions available unqualified. - <code>use &lt;module&gt; as &lt;alias&gt;</code> adds a qualified alias.</p>"},{"location":"reference/name-resolution/#ambiguity","title":"Ambiguity","text":"<p>If two opened modules export the same name, using that name unqualified is an error (<code>AmbiguousName</code>). You must use the qualified name <code>Module.name</code>.</p>"},{"location":"reference/ownership-borrowing/","title":"Ownership and Borrowing","text":"<p>LRL enforces affine usage of linear resources.</p>"},{"location":"reference/ownership-borrowing/#usage-modes","title":"Usage Modes","text":"<p>The system tracks variable usage in three modes: 1. Consuming: The value is moved. It cannot be used again. 2. MutBorrow: The value is mutably borrowed. Exclusive access. 3. Observational: The value is read. Shared access.</p>"},{"location":"reference/ownership-borrowing/#move-semantics","title":"Move Semantics","text":"<p>By default, passing a non-<code>Copy</code> value to a function <code>(f x)</code> is a move (Consuming usage). Subsequent use of <code>x</code> is a compile-time error (<code>UseAfterMove</code>).</p>"},{"location":"reference/ownership-borrowing/#copy-types","title":"Copy Types","text":"<p>Types like <code>Nat</code> and <code>Bool</code> are <code>Copy</code>. They can be used multiple times; each usage is a copy.</p>"},{"location":"reference/ownership-borrowing/#closures-and-capture","title":"Closures and Capture","text":"<p>Closures capture variables from their environment. The capture mode is inferred based on usage in the body. Code that attempts to capture a moved variable is rejected.</p>"},{"location":"reference/pattern-matching/","title":"Pattern Matching","text":"<p>Pattern matching is a surface-level feature that compiles to recursors.</p>"},{"location":"reference/pattern-matching/#exhaustiveness","title":"Exhaustiveness","text":"<p>Matches must differ cover all constructors of the inductive type. Missing cases result in a compile-time error.</p>"},{"location":"reference/pattern-matching/#redundancy","title":"Redundancy","text":"<p>Unreachable patterns (shadowed by earlier ones) are compile-time errors.</p>"},{"location":"reference/pattern-matching/#compilation","title":"Compilation","text":"<p>The <code>match</code> construct is desugared into a tree of <code>Rec</code> applications (decision tree compilation). This ensures that all pattern matching constitutes valid structural recursion (or well-founded recursion if specified).</p>"},{"location":"reference/runtime-model/","title":"Runtime Model","text":""},{"location":"reference/runtime-model/#data-representation","title":"Data Representation","text":"<ul> <li>Nat: Arbitrary precision integers (BigInt).</li> <li>Inductives: Tagged unions or struct pointers.</li> <li>Closures: <code>(Result, Environment)</code> pairs.</li> </ul>"},{"location":"reference/runtime-model/#erasure","title":"Erasure","text":"<p>The compiler performs full erasure of: - <code>Prop</code> types and values. - Type parameters (polymorphism is monomorphized or erased depending on backend). - <code>PhantomData</code>.</p>"},{"location":"reference/runtime-model/#memory-management","title":"Memory Management","text":"<p>LRL uses Affine Types to minimize GC. - Unique data is managed manually (drop flags). - Shared data may use Reference Counting (Ref/Shared).</p>"},{"location":"reference/stdlib/","title":"Standard Library Reference","text":"<p>The LeanRustLisp standard library provides core types, data structures, and algorithms for building verified software.</p>"},{"location":"reference/stdlib/#architecture","title":"Architecture","text":"<pre><code>stdlib/\n\u251c\u2500\u2500 prelude_api.lrl          # Public API contract (all backends)\n\u251c\u2500\u2500 prelude_impl_dynamic.lrl # Dynamic backend platform layer\n\u251c\u2500\u2500 prelude_impl_typed.lrl   # Typed backend platform layer\n\u2514\u2500\u2500 std/\n    \u251c\u2500\u2500 core/                # Primitives: Bool, Nat, Int, Float\n    \u251c\u2500\u2500 data/                # Collections: List, Option, Result, Pair\n    \u2514\u2500\u2500 control/             # Effects: Comp\n</code></pre> <p>Important: User code should target <code>prelude_api</code> only. Never import <code>prelude_impl_*</code> directly.</p>"},{"location":"reference/stdlib/#numeric-types","title":"Numeric Types","text":""},{"location":"reference/stdlib/#nat","title":"Nat","text":"<p>Natural numbers (non-negative integers) with Peano encoding.</p> <pre><code>(inductive copy Nat (sort 1)\n  (ctor zero Nat)\n  (ctor succ (pi n Nat Nat)))\n</code></pre>"},{"location":"reference/stdlib/#functions","title":"Functions","text":"Function Type Description <code>add</code> / <code>+</code> <code>Nat \u2192 Nat \u2192 Nat</code> Addition <code>nat_mul</code> / <code>*</code> <code>Nat \u2192 Nat \u2192 Nat</code> Multiplication <code>nat_div</code> / <code>/</code> <code>Nat \u2192 Nat \u2192 Nat</code> Floor division (div by 0 \u2192 0) <code>nat_pred</code> <code>Nat \u2192 Nat</code> Saturating predecessor (0 for zero) <code>nat_sub</code> <code>Nat \u2192 Nat \u2192 Nat</code> Bounded subtraction (clamps to 0) <code>nat_is_zero</code> <code>Nat \u2192 Bool</code> Test if zero <code>nat_eq</code> <code>Nat \u2192 Nat \u2192 Bool</code> Equality <code>nat_lt</code> <code>Nat \u2192 Nat \u2192 Bool</code> Less than <code>nat_le</code> <code>Nat \u2192 Nat \u2192 Bool</code> Less or equal <code>nat_gt</code> <code>Nat \u2192 Nat \u2192 Bool</code> Greater than <code>nat_ge</code> <code>Nat \u2192 Nat \u2192 Bool</code> Greater or equal"},{"location":"reference/stdlib/#int","title":"Int","text":"<p>Signed integers represented as sign + magnitude.</p> <pre><code>(inductive copy Int (sort 1)\n  (ctor int_pos (pi n Nat Int))   ;; Positive or zero\n  (ctor int_neg (pi n Nat Int)))  ;; Negative\n</code></pre>"},{"location":"reference/stdlib/#functions_1","title":"Functions","text":"Function Type Description <code>int_from_nat</code> <code>Nat \u2192 Int</code> Convert Nat to positive Int <code>int_to_nat</code> <code>Int \u2192 Nat</code> Clamp to Nat (negative \u2192 0) <code>int_abs</code> <code>Int \u2192 Nat</code> Absolute value <code>int_negate</code> <code>Int \u2192 Int</code> Negate sign <code>int_normalize</code> <code>Int \u2192 Int</code> Normalize (\u22120 \u2192 +0) <code>int_add</code> / <code>+i</code> <code>Int \u2192 Int \u2192 Int</code> Addition <code>int_sub</code> / <code>-i</code> <code>Int \u2192 Int \u2192 Int</code> Subtraction <code>int_mul</code> / <code>*i</code> <code>Int \u2192 Int \u2192 Int</code> Multiplication <code>int_div</code> / <code>/i</code> <code>Int \u2192 Int \u2192 Int</code> Truncating division (toward zero) <code>-</code> <code>Nat \u2192 Nat \u2192 Int</code> Subtraction returning signed result"},{"location":"reference/stdlib/#float","title":"Float","text":"<p>Half-precision floating point (IEEE-754 binary16).</p> <pre><code>(inductive copy Float (sort 1)\n  (ctor float16 (pi bits Nat Float)))  ;; 16-bit payload in Nat\n</code></pre>"},{"location":"reference/stdlib/#functions_2","title":"Functions","text":"Function Type Description <code>float_from_bits</code> <code>Nat \u2192 Float</code> Create from IEEE-754 bits <code>float_to_bits</code> <code>Float \u2192 Nat</code> Extract IEEE-754 bits <code>+f</code> <code>Float \u2192 Float \u2192 Float</code> Addition <code>-f</code> <code>Float \u2192 Float \u2192 Float</code> Subtraction <code>*f</code> <code>Float \u2192 Float \u2192 Float</code> Multiplication <code>/f</code> <code>Float \u2192 Float \u2192 Float</code> Division <p>Note: Float arithmetic is implemented as backend builtins. The bodies in std are placeholders.</p>"},{"location":"reference/stdlib/#boolean-type","title":"Boolean Type","text":""},{"location":"reference/stdlib/#bool","title":"Bool","text":"<p>Boolean type with standard logical operations.</p> <pre><code>(inductive copy Bool (sort 1)\n  (ctor true Bool)\n  (ctor false Bool))\n</code></pre>"},{"location":"reference/stdlib/#functions_3","title":"Functions","text":"Function Type Description <code>not</code> <code>Bool \u2192 Bool</code> Logical negation <code>and</code> <code>Bool \u2192 Bool \u2192 Bool</code> Logical AND <code>or</code> <code>Bool \u2192 Bool \u2192 Bool</code> Logical OR <code>xor</code> <code>Bool \u2192 Bool \u2192 Bool</code> Exclusive OR <code>implies</code> <code>Bool \u2192 Bool \u2192 Bool</code> Logical implication (a \u2192 b) <code>bool_eq</code> <code>Bool \u2192 Bool \u2192 Bool</code> Boolean equality <code>if_nat</code> <code>Bool \u2192 Nat \u2192 Nat \u2192 Nat</code> Conditional for Nat <code>if_bool</code> <code>Bool \u2192 Bool \u2192 Bool \u2192 Bool</code> Conditional for Bool"},{"location":"reference/stdlib/#data-structures","title":"Data Structures","text":""},{"location":"reference/stdlib/#list","title":"List","text":"<p>Polymorphic linked list.</p> <pre><code>(inductive copy List (pi T (sort 1) (sort 1))\n  (ctor nil (pi {T (sort 1)} (List T)))\n  (ctor cons (pi {T (sort 1)} (pi h T (pi t (List T) (List T))))))\n</code></pre>"},{"location":"reference/stdlib/#functions_4","title":"Functions","text":"Function Type Description <code>append</code> <code>List Nat \u2192 List Nat \u2192 List Nat</code> Concatenate lists <code>length</code> <code>List Nat \u2192 Nat</code> Compute list length <code>map</code> <code>(Nat \u2192 Nat) \u2192 List Nat \u2192 List Nat</code> Apply function to each element <code>foldr</code> <code>(Nat \u2192 Nat \u2192 Nat) \u2192 Nat \u2192 List Nat \u2192 Nat</code> Right fold <code>foldl</code> <code>(Nat \u2192 Nat \u2192 Nat) \u2192 Nat \u2192 List Nat \u2192 Nat</code> Left fold <code>reverse</code> <code>List Nat \u2192 List Nat</code> Reverse list order <code>filter</code> <code>(Nat \u2192 Bool) \u2192 List Nat \u2192 List Nat</code> Keep matching elements"},{"location":"reference/stdlib/#option","title":"Option","text":"<p>Optional values for computations that may fail.</p> <pre><code>(inductive copy Option (pi T (sort 1) (sort 1))\n  (ctor none (pi {T (sort 1)} (Option T)))\n  (ctor some (pi {T (sort 1)} (pi x T (Option T)))))\n</code></pre>"},{"location":"reference/stdlib/#functions_5","title":"Functions","text":"Function Type Description <code>option_map</code> <code>(A \u2192 B) \u2192 Option A \u2192 Option B</code> Map over Some <code>option_and_then</code> <code>Option A \u2192 (A \u2192 Option B) \u2192 Option B</code> Monadic bind <code>option_flat_map</code> <code>Option A \u2192 (A \u2192 Option B) \u2192 Option B</code> Alias for and_then <code>option_unwrap_or</code> <code>A \u2192 Option A \u2192 A</code> Default value for None <code>option_or</code> <code>Option A \u2192 Option A \u2192 Option A</code> Left-biased choice <code>option_is_some</code> <code>Option A \u2192 Bool</code> Test for Some <code>option_is_none</code> <code>Option A \u2192 Bool</code> Test for None"},{"location":"reference/stdlib/#result","title":"Result","text":"<p>Error handling with typed errors.</p> <pre><code>(inductive copy Result (pi E (sort 1) (pi T (sort 1) (sort 1)))\n  (ctor err (pi {E (sort 1)} (pi {T (sort 1)} (pi e E (Result E T)))))\n  (ctor ok (pi {E (sort 1)} (pi {T (sort 1)} (pi x T (Result E T))))))\n</code></pre>"},{"location":"reference/stdlib/#functions_6","title":"Functions","text":"Function Type Description <code>result_map</code> <code>(A \u2192 B) \u2192 Result E A \u2192 Result E B</code> Map over Ok <code>result_map_err</code> <code>(E1 \u2192 E2) \u2192 Result E1 A \u2192 Result E2 A</code> Map over Err <code>result_and_then</code> <code>Result E A \u2192 (A \u2192 Result E B) \u2192 Result E B</code> Monadic bind <code>result_unwrap_or</code> <code>A \u2192 Result E A \u2192 A</code> Default for Err <code>result_or</code> <code>Result E A \u2192 Result E A \u2192 Result E A</code> Left-biased choice <code>result_is_ok</code> <code>Result E A \u2192 Bool</code> Test for Ok <code>result_is_err</code> <code>Result E A \u2192 Bool</code> Test for Err"},{"location":"reference/stdlib/#pair","title":"Pair","text":"<p>Product types (tuples).</p> <pre><code>(inductive copy Pair (pi A (sort 1) (pi B (sort 1) (sort 1)))\n  (ctor mk_pair (pi {A (sort 1)} (pi {B (sort 1)} (pi fst A (pi snd B (Pair A B)))))))\n</code></pre>"},{"location":"reference/stdlib/#functions_7","title":"Functions","text":"Function Type Description <code>pair_fst</code> <code>Pair A B \u2192 A</code> First projection <code>pair_snd</code> <code>Pair A B \u2192 B</code> Second projection <code>pair_map</code> <code>(Nat \u2192 Nat) \u2192 (Nat \u2192 Nat) \u2192 Pair Nat Nat \u2192 Pair Nat Nat</code> Map both <code>pair_map_fst</code> <code>(Nat \u2192 Nat) \u2192 Pair Nat Nat \u2192 Pair Nat Nat</code> Map first <code>pair_map_snd</code> <code>(Nat \u2192 Nat) \u2192 Pair Nat Nat \u2192 Pair Nat Nat</code> Map second"},{"location":"reference/stdlib/#text-and-io","title":"Text and I/O","text":""},{"location":"reference/stdlib/#text","title":"Text","text":"<p>UTF-32 encoded string type.</p> <pre><code>(inductive copy Text (sort 1)\n  (ctor text (pi data (List Nat) Text)))\n</code></pre>"},{"location":"reference/stdlib/#functions_8","title":"Functions","text":"Function Type Description <code>print</code> <code>Text \u2192 Text</code> Print text to stdout <code>print_text</code> <code>Text \u2192 Text</code> Print text (typed backend) <code>print_nat</code> <code>Nat \u2192 Nat</code> Print Nat to stdout <code>print_bool</code> <code>Bool \u2192 Bool</code> Print Bool to stdout <code>print_float</code> <code>Float \u2192 Float</code> Print Float to stdout <code>read_file</code> <code>Text \u2192 Text</code> Read file contents <code>write_file</code> <code>Text \u2192 Text \u2192 Text</code> Write contents to file"},{"location":"reference/stdlib/#special-types","title":"Special Types","text":""},{"location":"reference/stdlib/#borrowing-primitives","title":"Borrowing Primitives","text":"<pre><code>(axiom Shared (sort 1))    ;; Shared reference mode\n(axiom Mut (sort 1))       ;; Mutable reference mode\n(axiom Ref (pi k (sort 1) (pi A (sort 1) (sort 1))))\n(axiom borrow_shared (pi {A (sort 1)} (pi x A (Ref Shared A))))\n(axiom borrow_mut (pi {A (sort 1)} (pi x A (Ref Mut A))))\n</code></pre>"},{"location":"reference/stdlib/#container-types","title":"Container Types","text":"Type Attributes Description <code>VecDyn T</code> <code>indexable</code> Dynamic vector <code>Slice T</code> <code>indexable</code> Borrowed slice <code>Array T</code> <code>indexable</code> Fixed-size array <code>RefCell T</code> <code>interior_mutable</code> Runtime-checked mutable cell <code>Mutex T</code> <code>concurrency_primitive</code> Thread-safe lock <code>Atomic T</code> <code>atomic_primitive</code> Atomic value"},{"location":"reference/stdlib/#logical-types","title":"Logical Types","text":"<pre><code>(inductive False (sort 0))  ;; Empty type (absurdity)\n\n(inductive Eq (pi A (sort 1) (pi a A (pi b A (sort 0))))\n  (ctor refl (pi A (sort 1) (pi a A (Eq A a a)))))\n</code></pre>"},{"location":"reference/stdlib/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/stdlib/#hello-world","title":"Hello World","text":"<pre><code>;; Print text to console\n(print (text (cons 72 (cons 101 (cons 108 (cons 108 (cons 111 nil)))))))\n</code></pre>"},{"location":"reference/stdlib/#basic-arithmetic","title":"Basic Arithmetic","text":"<pre><code>(def two Nat (succ (succ zero)))\n(def four Nat (+ two two))           ;; Using operator alias\n(def product Nat (* two four))       ;; Multiplication\n(def quotient Nat (/ product two))   ;; Division\n</code></pre>"},{"location":"reference/stdlib/#signed-integer-arithmetic","title":"Signed Integer Arithmetic","text":"<pre><code>;; Create negative numbers\n(def neg_five Int (int_neg (succ (succ (succ (succ (succ zero)))))))\n\n;; Arithmetic with Int\n(def sum Int (+i (int_pos two) neg_five))  ;; -3\n(def diff Int (- (succ zero) two))         ;; -1 (Nat subtraction returning Int)\n</code></pre>"},{"location":"reference/stdlib/#floating-point","title":"Floating Point","text":"<pre><code>(def x Float (float16 (succ (succ zero))))  ;; Create float from bits\n(def y Float (+f x x))                       ;; Add floats\n(def z Float (*f x (float16 zero)))          ;; Multiply\n</code></pre>"},{"location":"reference/stdlib/#list-operations","title":"List Operations","text":"<pre><code>(def nums (List Nat) (cons (succ zero) (cons (succ (succ zero)) nil)))\n(def len Nat (length nums))\n(def doubled (List Nat) (map (lam #[fn] x Nat (+ x x)) nums))\n</code></pre>"},{"location":"reference/stdlib/#option-handling","title":"Option Handling","text":"<pre><code>(def maybe_val (Option Nat) (some (succ (succ zero))))\n(def result Nat (option_unwrap_or Nat zero maybe_val))\n</code></pre>"},{"location":"reference/stdlib/#result-chaining","title":"Result Chaining","text":"<pre><code>(def success (Result Nat Nat) (ok (succ zero)))\n(def doubled (Result Nat Nat) \n  (result_map Nat Nat Nat \n    (lam #[fn] x Nat (+ x x)) \n    success))\n</code></pre>"},{"location":"reference/surface-syntax/","title":"Surface Syntax","text":"<p>This document lists the special forms recognized by the desugarer and compiler.</p>"},{"location":"reference/surface-syntax/#binding-forms","title":"Binding Forms","text":""},{"location":"reference/surface-syntax/#lam","title":"<code>lam</code>","text":"<p>Lambda abstraction. <pre><code>(lam &lt;name&gt; &lt;type&gt; &lt;body&gt;)\n</code></pre></p>"},{"location":"reference/surface-syntax/#let","title":"<code>let</code>","text":"<p>Local binding. <pre><code>(let &lt;name&gt; &lt;value&gt; &lt;body&gt;)\n</code></pre></p>"},{"location":"reference/surface-syntax/#top-level-declarations","title":"Top-Level Declarations","text":""},{"location":"reference/surface-syntax/#def","title":"<code>def</code>","text":"<p>Global definition. <pre><code>(def &lt;name&gt; &lt;type&gt; &lt;value&gt;)\n</code></pre></p>"},{"location":"reference/surface-syntax/#inductive","title":"<code>inductive</code>","text":"<p>Inductive type definition. <pre><code>(inductive &lt;name&gt; &lt;type&gt; &lt;constructor&gt;*)\n</code></pre> Where constructor is <code>(&lt;name&gt; &lt;type&gt;)</code>.</p>"},{"location":"reference/surface-syntax/#defmacro","title":"<code>defmacro</code>","text":"<p>Macro definition. <pre><code>(defmacro &lt;name&gt; (&lt;args&gt;*) &lt;body&gt;)\n</code></pre></p>"},{"location":"reference/surface-syntax/#control-flow","title":"Control Flow","text":""},{"location":"reference/surface-syntax/#match","title":"<code>match</code>","text":"<p>Pattern matching. <pre><code>(match &lt;scrutinee&gt;\n  (&lt;pattern&gt; &lt;body&gt;)*)\n</code></pre></p>"},{"location":"reference/surface-syntax/#types","title":"Types","text":""},{"location":"reference/surface-syntax/#pi-","title":"<code>pi</code> / <code>-&gt;</code>","text":"<p>Function types. <pre><code>(pi (&lt;name&gt; &lt;type&gt;) &lt;body&gt;)\n(-&gt; &lt;type&gt; ... &lt;ret_type&gt;)\n</code></pre></p>"},{"location":"reference/surface-syntax/#sort-type-prop","title":"<code>sort</code> / <code>Type</code> / <code>Prop</code>","text":"<p>Universes. <pre><code>(sort &lt;level&gt;)\n(Type &lt;level&gt;) ; sugar for (sort (succ level)) ??? Check implementation\nProp           ; sugar for (sort 0)\n</code></pre></p>"},{"location":"reference/type-system/","title":"Type System","text":"<p>The core of LRL is a Calculus of Inductive Constructions (CIC).</p>"},{"location":"reference/type-system/#universes","title":"Universes","text":"<p>There is a hierarchy of universes: - <code>Prop</code> (Sort 0): Logical propositions. Erased at runtime. - <code>Type 0</code> (Sort 1): Basics types (Nat, Bool). - <code>Type n</code> (Sort n+1): Higher universes.</p> <p><code>Prop</code> is impredicative. <code>Type</code> levels are predicative.</p>"},{"location":"reference/type-system/#dependent-products-pi","title":"Dependent Products (Pi)","text":"<p>The fundamental type constructor is <code>Pi</code> (\u03a0). <code>forall (x : A), B x</code>. If <code>B</code> is constant, this is <code>A -&gt; B</code>.</p>"},{"location":"reference/type-system/#definitional-equality","title":"Definitional Equality","text":"<p>Two terms are definitionally equal if they compute to the same normal form. The kernel checks this by normalizing both terms (with limits on \"fuel\").</p> <p>Reductions: - Beta: <code>(\\x. b) a ~~&gt; b[x/a]</code> - Delta: <code>def x := v</code> -&gt; <code>x ~~&gt; v</code> - Iota: Recursor reduction (pattern matching). - Eta: <code>(\\x. f x) ~~&gt; f</code> (for functions).</p>"},{"location":"reference/type-system/#inductive-types","title":"Inductive Types","text":"<p>Inductive types are defined by their introduction rules (constructors). Their elimination rule (recursor) is automatically generated. Recursion must be well-founded (guarded by structural decrease or a measure).</p>"},{"location":"reference/unsafe-ffi/","title":"Unsafe","text":"<p>LRL allows bypassing safety checks in designated blocks.</p>"},{"location":"reference/unsafe-ffi/#the-unsafe-keyword","title":"The <code>unsafe</code> keyword","text":"<p>The <code>unsafe</code> block allows: - Dereferencing raw pointers. - Calling functions marked <code>unsafe</code> (including FFI). - Implementing <code>unsafe</code> traits.</p>"},{"location":"reference/unsafe-ffi/#invariants","title":"Invariants","text":"<p>It is the programmer's responsibility to ensure that unsafe code maintains the logical invariants of the system: - Memory safety (no invalid pointers). - Type safety (casting must be valid). - Thread safety (no data races).</p>"},{"location":"reference/versioning/","title":"Versioning","text":""},{"location":"reference/versioning/#language-versions","title":"Language Versions","text":"<p>LRL follows semantic versioning.</p> <ul> <li>Major: Breaking changes to the core calculus or surface syntax.</li> <li>Minor: New features, backwards-compatible additions.</li> <li>Patch: Bug fixes.</li> </ul>"},{"location":"reference/versioning/#stability-guarantees","title":"Stability Guarantees","text":"<p>As of 0.1 Alpha: - No stability guarantees are provided. Syntax and features may change breakingly between commits.</p>"},{"location":"reference/versioning/#editions","title":"Editions","text":"<p>Future versions may support \"Editions\" (like Rust) to allow breaking syntactic changes while maintaining compatibility for old code.</p>"},{"location":"spec/INDEX/","title":"Specification","text":"<p>This directory contains the formal specification of LeanRustLisp.</p>"},{"location":"spec/INDEX/#core-calculus","title":"Core Calculus","text":"<ul> <li>Core Calculus: The trusted kernel logic.</li> <li>Function Kinds: Fn, FnMut, FnOnce.</li> <li>Impredicative Prop: Logical universe.</li> </ul>"},{"location":"spec/INDEX/#intermediate-representations","title":"Intermediate Representations","text":"<ul> <li>MIR: Mid-level Intermediate Representation.</li> </ul>"},{"location":"spec/INDEX/#system-boundaries","title":"System Boundaries","text":"<ul> <li>Kernel Boundary</li> <li>Mode Boundaries</li> <li>Phase Boundaries</li> </ul>"},{"location":"spec/INDEX/#contracts","title":"Contracts","text":"<ul> <li>Syntax Contract</li> </ul>"},{"location":"spec/core_calculus/","title":"Core Calculus Specification","text":""},{"location":"spec/core_calculus/#1-kernel-calculus-base","title":"1. Kernel Calculus Base","text":"<p>The kernel is based on the Calculus of Inductive Constructions (CIC) dependent type theory, closely aligned with Lean's kernel.</p>"},{"location":"spec/core_calculus/#2-universes","title":"2. Universes","text":"<ul> <li><code>Prop</code> (Sort 0): The universe of computationally irrelevant propositions.<ul> <li>Impredicative: <code>Prop</code> is impredicative. The universe level of a Pi-type <code>\u03a0 (x : A), B</code> is <code>Prop</code> if <code>B : Prop</code>, regardless of the universe of <code>A</code>.</li> <li>Erasure: Terms in <code>Prop</code> are proofs and are erased at runtime.</li> </ul> </li> <li><code>Type u</code> (Sort u+1): A cumulative hierarchy of computational types, indexed by universe levels <code>u</code>.<ul> <li>Predicative: The universe level of <code>\u03a0 (x : A), B</code> where <code>B : Type v</code> is <code>max(level(A), v)</code>.</li> </ul> </li> </ul>"},{"location":"spec/core_calculus/#3-function-kinds-ownership","title":"3. Function Kinds (Ownership)","text":"<p><code>Pi</code> and <code>Lam</code> carry a function-kind annotation (<code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code>) that controls ownership and call semantics for runtime values. The kind is part of type identity (no definitional equality across kinds). Beta reduction is unchanged. See <code>docs/spec/function_kinds.md</code> for the full specification.</p> <p>Core grammar excerpt:</p> <pre><code>FnKind ::= Fn | FnMut | FnOnce\nPi(ty, body, binder_info, fn_kind)\nLam(ty, body, binder_info, fn_kind)\n</code></pre>"},{"location":"spec/core_calculus/#4-inductive-types-and-elimination","title":"4. Inductive Types and Elimination","text":"<p>The kernel supports inductive definitions.</p> <ul> <li>Large Elimination Restriction: To maintain proof irrelevance, elimination from an inductive type in <code>Prop</code> to a type in <code>Type u</code> (where <code>u &gt; 0</code>) is restricted.<ul> <li>Allowed only if the inductive type has zero constructors (e.g., <code>False</code>) or one constructor where all constructor fields are in <code>Prop</code> (e.g., <code>True</code>).</li> <li>Exception: inductives matching the equality shape <code>(A : Type u) -&gt; (a : A) -&gt; (b : A) -&gt; Prop</code> with <code>refl : (A : Type u) -&gt; (a : A) -&gt; Eq A a a</code> may eliminate into <code>Type</code> (transport/J), even though their parameters are in <code>Type</code>.</li> <li>Elimination from <code>Prop</code> to <code>Prop</code> is always allowed.</li> </ul> </li> <li>Explicit Recursor Universes: Recursor terms must carry explicit universe levels (e.g., <code>Rec Nat [u]</code>). The kernel rejects <code>Rec</code> with missing levels. The elaborator computes the level from the motive type and supplies it.</li> </ul>"},{"location":"spec/core_calculus/#5-definitional-equality-and-unfolding","title":"5. Definitional Equality and Unfolding","text":"<p>Definitional equality (<code>a \u2261 b</code>) is decided by a Normalization-by-Evaluation (NbE) engine.</p> <ul> <li>Transparency: Definitions carry a transparency hint.<ul> <li>Transparent (Reducible): The default. Unfolded during standard type checking.</li> <li>Opaque (Irreducible): Unfolded only when explicitly requested (e.g., by tactics or specialized reduction modes), effectively abstracting the implementation details.</li> </ul> </li> <li>Reduction: Includes Beta (\u03bb), Iota (recursion), Zeta (let), and Delta (definition unfolding based on transparency).</li> <li>Default policy: Type checking uses transparency mode <code>Reducible</code> (respecting <code>opaque</code>).</li> <li>Fuel / budget: Definitional equality is fuel-bounded to keep normalization predictable. The default fuel is <code>100_000</code>, configurable via <code>LRL_DEFEQ_FUEL</code> or the CLI flag <code>--defeq-fuel &lt;N&gt;</code> (the CLI flag overrides the env var). When fuel is exhausted, the kernel reports an error with context; marking large definitions as <code>opaque</code> reduces unfolding pressure.</li> <li>Fix unfolding: <code>fix</code> (general recursion) is never unfolded during definitional equality. Use <code>partial</code> for general recursion and <code>opaque</code> to keep it out of reductions in type checking.</li> <li>Safety classification: Prop classification respects <code>opaque</code> by default; explicit contexts can opt in to unfolding for checks like large elimination and Prop-in-data. MIR lowering may still peek through opaque aliases to detect <code>Ref</code>/interior mutability. These classification checks do not make <code>opaque</code> transparent for definitional equality.</li> </ul>"},{"location":"spec/core_calculus/#6-axioms-and-classical-logic","title":"6. Axioms and Classical Logic","text":"<p>The kernel supports classical logic via axioms (e.g., Excluded Middle, Choice).</p> <ul> <li>Explicit Tracking: Axioms must be declared explicitly.</li> <li>Explicit Classification: Axioms may carry tags (e.g., <code>classical</code>) that the kernel uses to classify dependencies; no name-based heuristics are used.<ul> <li>Surface syntax attaches tags via <code>(axiom classical name ty)</code> or <code>(axiom (classical) name ty)</code>. Untagged axioms are treated as non-classical.</li> </ul> </li> <li>Dependency Tracking: Every definition tracks the set of axioms it depends on (transitively). This allows users to know if a theorem relies on classical logic or specific axioms.</li> <li><code>import classical</code> introduces the axiom <code>classical_choice</code> with type <code>\u03a0 (P : Prop), ((P \u2192 False) \u2192 False) \u2192 P</code> (double-negation elimination), tagged as classical.</li> </ul>"},{"location":"spec/core_calculus/#7-completeness-totality","title":"7. Completeness &amp; Totality","text":"<ul> <li>Total Fragment: Definitions involved in types must be terminating.<ul> <li>Structural recursion (via <code>Rec</code>) or well-founded recursion (via <code>Acc</code>) is enforced.</li> <li>General recursion (<code>fix</code>) is rejected in total definitions.</li> </ul> </li> <li>Partial Fragment: General recursion is allowed and cannot participate in definitional equality during type checking. Partial definitions must return an effect type (e.g., <code>Comp A</code>), and the kernel enforces this requirement.<ul> <li><code>fix</code> is the only general-recursion form; it is permitted only in <code>partial</code> defs.</li> </ul> </li> </ul>"},{"location":"spec/function_kinds/","title":"Function and Closure Kinds","text":"<p>This document specifies function/closure kinds, capture rules, and ownership semantics. It is the source of truth for downstream implementation streams.</p>"},{"location":"spec/function_kinds/#goals","title":"Goals","text":"<ul> <li>Prevent unsound duplication of closures that capture linear values.</li> <li>Match Rust-style calling semantics (shared vs mutable vs consuming calls).</li> <li>Provide explicit syntax and a stable core representation.</li> </ul>"},{"location":"spec/function_kinds/#1-kinds","title":"1. Kinds","text":"<p>LRL defines three function kinds:</p> <ul> <li>Fn: callable with a shared borrow of its environment.</li> <li>FnMut: callable with a mutable borrow of its environment.</li> <li>FnOnce: callable by consuming its environment.</li> </ul> <p>These are ordered by capability:</p> <pre><code>Fn &lt; FnMut &lt; FnOnce\n</code></pre> <p>A value of a smaller kind can be used where a larger kind is expected (coercion rules below).</p>"},{"location":"spec/function_kinds/#2-surface-syntax","title":"2. Surface Syntax","text":"<p>Function kinds are optional annotations on <code>lam</code> and <code>pi</code>. If omitted, the default is <code>fn</code>. In v0, inference-only is acceptable; the annotation form is reserved for future control and clearer errors.</p> <p>Preferred (attribute) form:</p> <pre><code>(lam #[once] x A body)\n(lam #[fn] x A body)\n(lam #[mut] x A body)\n\n(pi #[once] x A B)\n(pi #[fn] x A B)\n(pi #[mut] x A B)\n</code></pre> <p>Legacy sugar (accepted during migration):</p> <pre><code>(lam x A body)                 ; default fn\n(lam fn x A body)\n(lam fnmut x A body)\n(lam fnonce x A body)\n\n(pi x A B)                      ; default fn\n(pi fn x A B)\n(pi fnmut x A B)\n(pi fnonce x A B)\n</code></pre> <p>Implicit binders keep the same brace syntax:</p> <pre><code>(lam fn {x} A body)\n(pi fnonce {x} A B)\n(lam #[once] {x} A body)\n(lam #[mut] {x} A body)\n(pi #[once] {x} A B)\n(pi #[mut] {x} A B)\n</code></pre> <p>Legacy sugar is desugared to the attribute form during elaboration.</p>"},{"location":"spec/function_kinds/#21-lifetime-labels-for-references","title":"2.1 Lifetime Labels for References","text":"<p>Function types may label reference lifetimes by attaching an attribute to <code>Ref</code> in the signature. The label becomes a named region parameter; reusing the same label ties lifetimes together.</p> <p>Example (return tied to the first argument):</p> <pre><code>(pi a (Ref #[a] Shared Nat)\n  (pi b (Ref #[b] Shared Nat)\n    (Ref #[a] Shared Nat)))\n</code></pre> <p>Elision rule (Rust\u2011style): if a signature contains exactly one distinct reference lifetime among its inputs, unlabeled return references are assigned that lifetime. Otherwise, return references must be explicitly labeled.</p> <p>Elision as sugar: An elided label is treated as a fresh implicit label variable during elaboration. If an expected type provides an explicit label, the elided label may unify to that explicit label; explicit-to-explicit mismatches remain errors. After elaboration, labels are concrete and compared strictly by defeq.</p>"},{"location":"spec/function_kinds/#3-core-representation","title":"3. Core Representation","text":"<p>Extend core terms with a function kind annotation:</p> <pre><code>FnKind ::= Fn | FnMut | FnOnce\n\nLam(ty, body, binder_info, fn_kind)\nPi(ty, body, binder_info, fn_kind)\n</code></pre> <p><code>fn_kind</code> is part of the type identity. <code>Pi^Fn</code> is not definitionally equal to <code>Pi^FnOnce</code>; coercions must be explicit or inserted by elaboration.</p>"},{"location":"spec/function_kinds/#4-capture-inference","title":"4. Capture Inference","text":"<p>The elaborator infers the minimal required kind from free-variable usage inside a lambda. Each captured variable is classified by capture mode:</p> <ul> <li>By shared borrow: only read; no mutation or move.</li> <li>By mutable borrow: mutated or requires <code>&amp;mut</code> access.</li> <li>By move: consumed, moved out, or stored in a non-Copy position.</li> <li>By copy: moved in a position where the value is Copy (treated as read).</li> </ul> <p>Kind inference rule (take the maximum over captures):</p> <ul> <li>Any move capture =&gt; <code>FnOnce</code></li> <li>Else any mutable borrow capture =&gt; <code>FnMut</code></li> <li>Else =&gt; <code>Fn</code></li> </ul> <p>An explicit annotation must be at least the inferred kind (annotating with a more permissive kind is allowed; annotating with a smaller kind is an error).</p> <p>Inference occurs in elaboration; the kernel validates the resulting kind annotations and rejects mismatches.</p>"},{"location":"spec/function_kinds/#41-implicit-binders-are-observational-only","title":"4.1 Implicit binders are observational-only","text":"<p>Implicit binders (<code>{x}</code>) are inference markers, not a license to consume resources. In v0, implicit value binders are restricted to observational usage:</p> <ul> <li>They may appear freely in types and in <code>Prop</code> (erased usage).</li> <li>At runtime they may only be read or copied; they must not be moved,   mutably borrowed, or stored in non-Copy positions.</li> <li>Passing an implicit argument to a parameter that consumes or mutably   borrows it is an error.</li> </ul> <p>If a value needs to be consumed, make the binder explicit. This rule lets kind inference treat implicit arguments as non-consuming; any consuming use is rejected rather than silently upgrading the closure kind.</p>"},{"location":"spec/function_kinds/#5-coercions-and-subtyping","title":"5. Coercions and Subtyping","text":"<p>Coercions follow the kind ordering:</p> <ul> <li><code>Fn</code> can be used as <code>FnMut</code>.</li> <li><code>FnMut</code> can be used as <code>FnOnce</code>.</li> <li>(<code>Fn</code> can be used as <code>FnOnce</code> via the above.)</li> </ul> <p>No coercion exists in the other direction. The elaborator may insert eta-wrappers or coercion nodes to account for expected kinds.</p>"},{"location":"spec/function_kinds/#6-call-semantics-and-ownership","title":"6. Call Semantics and Ownership","text":"<p>Function application borrows or consumes the function value based on its kind:</p> <ul> <li>Fn call: shared-borrow the closure environment.</li> <li>FnMut call: mutable-borrow the closure environment.</li> <li>FnOnce call: move the closure environment (consumes it).</li> </ul> <p>This ensures:</p> <ul> <li><code>Fn</code> values can be called multiple times without requiring <code>Copy</code>.</li> <li><code>FnOnce</code> values can be called at most once.</li> </ul> <p>Borrow checking enforces the required aliasing rules for <code>Fn</code> calls.</p> <p>Lowering to MIR should preserve call mode explicitly (e.g., <code>CallShared</code> for <code>Fn</code>, <code>CallConsume</code> for <code>FnOnce</code>).</p>"},{"location":"spec/function_kinds/#7-copy-rules-for-function-values-current-policy","title":"7. Copy Rules for Function Values (Current Policy)","text":"<p>Function types (<code>Pi</code>) are not <code>Copy</code>. Function items (top-level non\u2011capturing definitions) are <code>Copy</code> by default. Closures are non\u2011Copy by default, even when their kind is <code>Fn</code>/<code>FnMut</code> and all captures are <code>Copy</code>. Repeated calls are still allowed because <code>Fn</code> calls borrow the environment, while <code>FnOnce</code> calls consume it.</p> <p>If you need to duplicate a closure value today, pass it by shared reference or lift it to a top-level definition (no captured environment). A future extension may allow capture\u2011aware Copy for closures.</p>"},{"location":"spec/function_kinds/#8-dependent-types-and-erasure","title":"8. Dependent Types and Erasure","text":"<p><code>FnKind</code> is tracked uniformly in <code>Pi</code> even when the binder is implicit or the function lives in <code>Prop</code>. The kind does not affect beta-reduction or erasure; it only affects ownership/borrow semantics for runtime values.</p>"},{"location":"spec/function_kinds/#9-examples-for-tests","title":"9. Examples (for Tests)","text":"<p>These examples are intended to seed regression tests. They illustrate kind inference, explicit annotations, and coercions. The syntax here matches the surface syntax in this spec.</p> <p>When <code>#[once]</code>/<code>#[fn]</code> (or legacy <code>pi fn</code>/<code>pi fnonce</code>) appears, it is an explicit annotation; removing it should still infer the same kind.</p>"},{"location":"spec/function_kinds/#91-inferred-fn-read-only-capture","title":"9.1 Inferred <code>Fn</code> (read-only capture)","text":"<pre><code>(def make_adder\n  (pi x Nat (pi fn y Nat Nat))\n  (lam x Nat\n    ;; `x` is read-only =&gt; inferred Fn.\n    (lam y Nat (add x y))))\n</code></pre>"},{"location":"spec/function_kinds/#92-inferred-fnonce-move-capture","title":"9.2 Inferred <code>FnOnce</code> (move capture)","text":"<pre><code>(inductive Box (pi A (sort 1) (sort 1))\n  (ctor mk_box (pi {A (sort 1)} (pi x A (Box A)))))\n\n(def make_once\n  (pi b (Box Nat) (pi #[once] _ Nat (Box Nat)))\n  (lam b (Box Nat)\n    ;; Captures `b` by move =&gt; inferred FnOnce (even if not annotated).\n    (lam #[once] _ Nat b)))\n</code></pre>"},{"location":"spec/function_kinds/#93-inferred-fnmut-mutable-capture","title":"9.3 Inferred <code>FnMut</code> (mutable capture)","text":"<pre><code>;; Assume a primitive that mutates a mutable reference.\n(axiom unsafe set_ref\n  (pi {A (sort 1)} (pi r (Ref Mut A) (pi v A Nat))))\n\n(def make_counter\n  (pi r (Ref Mut Nat) (pi #[mut] _ Nat Nat))\n  (lam r (Ref Mut Nat)\n    ;; Mutates through `r` =&gt; inferred FnMut.\n    (lam #[mut] _ Nat (set_ref r zero))))\n</code></pre>"},{"location":"spec/function_kinds/#94-explicit-kind-too-small-error","title":"9.4 Explicit Kind Too Small (error)","text":"<pre><code>(def bad_kind\n  (pi b (Box Nat) (pi #[fn] _ Nat (Box Nat)))\n  (lam b (Box Nat)\n    ;; ERROR: inferred FnOnce, annotated as Fn.\n    (lam #[fn] _ Nat b)))\n</code></pre>"},{"location":"spec/function_kinds/#95-coercion-fn-to-fnonce","title":"9.5 Coercion: <code>Fn</code> to <code>FnOnce</code>","text":"<pre><code>(def apply_once\n  (pi f (pi #[once] x Nat Nat) (pi v Nat Nat))\n  (lam f (pi #[once] x Nat Nat)\n    (lam v Nat (f v))))\n\n(def add_one\n  (pi #[fn] x Nat Nat)\n  (lam x Nat (succ x)))\n\n;; Should coerce `add_one : Fn` into `FnOnce`.\n(def test_coercion Nat (apply_once add_one zero))\n</code></pre>"},{"location":"spec/impredicative_prop/","title":"Design Note: Impredicative Prop in LRL Kernel","text":"<p>This document outlines the design and implementation of an impredicative <code>Prop</code> type in the LeanRustLisp (LRL) kernel, following the guidance in <code>agents/tasks/impredicative_loop.md</code>.</p>"},{"location":"spec/impredicative_prop/#1-prop-and-universe-level-conventions","title":"1. <code>Prop</code> and Universe Level Conventions","text":"<p>In this kernel, we establish the following universe level conventions to distinguish between propositions (proofs) and types (data):</p> <ul> <li> <p><code>Prop</code>: The sort of propositions. It is represented at the lowest universe level, <code>Sort(Level::Zero)</code>. Terms of type <code>Prop</code> are proofs, which are intended to be erasable during code generation.</p> </li> <li> <p><code>Type u</code>: The sort of types at a specific universe level <code>u</code>. It is represented as <code>Sort(Level::Succ(u))</code>.</p> <ul> <li><code>Type 0</code> corresponds to <code>Sort(Succ(Zero))</code>, which is the first universe level above <code>Prop</code>. It contains \"small\" types like <code>Nat</code> and <code>Bool</code>.</li> <li><code>Type 1</code> corresponds to <code>Sort(Succ(Succ(Zero)))</code>, and so on.</li> </ul> </li> </ul> <p>This hierarchy is essential for maintaining consistency and preventing paradoxes while allowing <code>Prop</code> to be impredicative.</p>"},{"location":"spec/impredicative_prop/#2-the-impredicative-type-universe-rule","title":"2. The Impredicative \u03a0-Type Universe Rule","text":"<p>To make <code>Prop</code> impredicative, we introduce a special universe-level computation rule for \u03a0-types (dependent functions). The universe level of a \u03a0-type <code>\u03a0 (x : A), B</code> is determined by the universe levels of its domain <code>A</code> and codomain <code>B</code>.</p> <p>Let <code>A : Sort u</code> and <code>B : Sort v</code>. The resulting sort of <code>\u03a0 (x : A), B</code> is <code>Sort(level_imax(u, v))</code>, where <code>level_imax</code> is defined as:</p> <pre><code>level_imax(u, v) := if v is Level::Zero then Level::Zero else Level::max(u, v)\n</code></pre> <p>Rule Explanation:</p> <ol> <li> <p>Impredicativity: If the codomain <code>B</code> is in <code>Prop</code> (i.e., <code>v</code> is <code>Level::Zero</code>), then the entire \u03a0-type is also in <code>Prop</code>. This allows for quantification over types of any universe level while remaining within <code>Prop</code>. For example, <code>\u03a0 (A : Type 0), (\u03a0 (p : Prop), p)</code> is itself a <code>Prop</code>. This is the core of Lean-style impredicativity.</p> </li> <li> <p>Predicativity: If the codomain <code>B</code> is in <code>Type</code> (i.e., <code>v</code> is not <code>Level::Zero</code>), then the resulting universe level is the standard maximum of the domain and codomain levels. For example, <code>\u03a0 (A : Type 0), A</code> resides in <code>Type 1</code> because its codomain can be a large type. Similarly, <code>\u03a0 (A : Type 0), Prop</code> resides in <code>Type 1</code> because <code>Prop</code> itself is a type (inhabiting <code>Type 0</code>), not a proposition.</p> </li> </ol> <p>This <code>level_imax</code> function will be the single source of truth for calculating the universe level of \u03a0-types in the kernel's type checker.</p>"},{"location":"spec/impredicative_prop/#3-elimination-from-prop-into-type","title":"3. Elimination from <code>Prop</code> into <code>Type</code>","text":"<p>A critical restriction is required to maintain logical consistency and enable proof erasure: a term of type <code>Prop</code> (a proof) cannot be used to compute a term of type <code>Type</code> (data).</p> <p>Planned Restriction:</p> <p>The kernel will forbid pattern matching on a term whose type is in <code>Prop</code> to produce a result that is in <code>Type</code>. For example, if <code>p : MyProp</code>, where <code>MyProp : Prop</code>, one cannot write a <code>match p with ...</code> expression that returns a <code>Nat</code>.</p> <p>This restriction, often called \"non-informative proofs,\" is fundamental. Without it, one could \"prove\" <code>False</code> and then use that proof to produce any data value, leading to a trivial and inconsistent system. While the full implementation of a <code>match</code> expression and this check may be deferred, the design acknowledges this restriction as a foundational principle. The checker will eventually be equipped to reject such invalid eliminations.</p>"},{"location":"spec/impredicative_prop/#4-difference-from-predicative-prop","title":"4. Difference from Predicative <code>Prop</code>","text":"<p>A predicative system would treat <code>Prop</code> like any other universe level. In a predicative system, the universe rule for \u03a0-types would always be <code>Level::max(u, v)</code>.</p> <p>This would mean that <code>\u03a0 (A : Type 0), (\u2200 p:Prop, p)</code> would have the sort <code>Type 0</code>, not <code>Prop</code>. While simpler, a predicative <code>Prop</code> significantly reduces the expressiveness of the logic, making it cumbersome to state certain higher-order properties.</p> <p>By choosing an impredicative <code>Prop</code>, we gain expressive power, allowing us to quantify over all types to form a proposition, a hallmark of the Calculus of Inductive Constructions (CIC) upon which Lean is based. The trade-off is the added complexity of the <code>level_imax</code> rule and the strict requirement for restricting eliminations from <code>Prop</code> to <code>Type</code>.</p>"},{"location":"spec/kernel_boundary/","title":"Kernel Boundary and Trust Model","text":"<p>This document defines the boundary of the Trusted Computing Base (TCB) for LeanRustLisp.</p>"},{"location":"spec/kernel_boundary/#1-trusted-core-the-kernel","title":"1. Trusted Core (The Kernel)","text":"<p>The kernel is the minimal set of components that must be correct for the system to be sound.</p>"},{"location":"spec/kernel_boundary/#components","title":"Components","text":"<ol> <li>Type Checker (<code>checker.rs</code>):<ul> <li>Verifies type correctness of terms.</li> <li>Validates core invariants on incoming terms (e.g., no metas, explicit recursor levels) and checks     <code>ty : Sort</code> plus <code>value : ty</code> (when provided) before admission. Closedness is enforced implicitly     by type-checking in an empty context, not by a separate syntactic pass.</li> <li>Enforces universe levels (including impredicative <code>Prop</code>).</li> <li>Enforces termination (structural/well-founded) for total definitions.</li> <li>Enforces effect boundaries (Total vs Partial vs Unsafe).</li> <li>Enforces elimination restrictions (Prop -&gt; Type).</li> <li>Enforces ownership/linearity on values.</li> <li>Validates function kind annotations on <code>Lam</code>/<code>Pi</code> (Fn/FnMut/FnOnce) and     rejects misuse without an explicit coercion.</li> <li>Validates capture-mode annotations only for structural correctness     (closure id exists, capture indices reference actual free variables). It     does not enforce capture-mode strength.</li> <li>Tracks axiom dependencies.</li> </ul> </li> <li>Definitional Equality (<code>nbe.rs</code>):<ul> <li>Implements conversion checking via Normalization-by-Evaluation.</li> <li>Respects transparency settings (unfolding vs opaque).</li> <li>Uses fuel-bounded evaluation to keep defeq total; fuel is configurable via <code>LRL_DEFEQ_FUEL</code>.     Fuel exhaustion is reported with guidance to mark large definitions <code>opaque</code> or raise the fuel.</li> </ul> </li> <li>AST (<code>ast.rs</code>):<ul> <li>Defines the core term structure (CIC with De Bruijn indices).</li> </ul> </li> </ol>"},{"location":"spec/kernel_boundary/#policies","title":"Policies","text":"<ul> <li>Transparency: Default is transparent. Opaque definitions hide implementation details from the kernel's automatic unfolding, but can be forced open if needed (e.g. by reflective tools, though standard checking respects opacity). Prop classification respects <code>opaque</code> by default; explicit contexts can opt in to unfolding for checks like large elimination and Prop-in-data. MIR lowering may peek through opaque aliases to detect <code>Ref</code>/interior mutability for borrow checking; these checks do not affect definitional equality.</li> <li>Proof Irrelevance: Proofs (terms in <code>Prop</code>) are computationally irrelevant. They cannot influence the runtime behavior of programs (except via their existence as a precondition).</li> <li>Axiom Tracking: The kernel does not forbid axioms, but strictly tracks their usage. Classical     classification is explicit: axioms carry tags (e.g., <code>classical</code>), and dependency analysis only uses     those tags (no name-based heuristics). A \"proven\" theorem depending on a tagged axiom is tainted.     This includes implicit unsafe axioms introduced by explicit Copy instances     (<code>copy_instance(TypeName)</code> with the <code>unsafe</code> tag).</li> <li>Reserved primitives: Names like <code>Ref</code>, <code>Shared</code>, <code>Mut</code>, <code>borrow_shared</code>, <code>borrow_mut</code>,     and <code>index_*</code> are reserved. These are treated as compiler intrinsics during MIR lowering.     The kernel only admits them as axioms with fixed signatures (intended for the prelude); user     code must not define them.     <code>Ref</code>/<code>Shared</code>/<code>Mut</code> define the reference type constructor and mutability tags used in     ownership checks. <code>borrow_shared</code>/<code>borrow_mut</code> are safe primitives usable in total code, with     safety enforced by the MIR borrow checker. <code>index_*</code> remain <code>unsafe</code> axioms until their safety     contract is enforced.</li> <li>Capture modes (TCB note): Capture-mode strength is enforced in MIR lowering     (which recomputes required capture modes from usage). The kernel only checks that     capture annotations are well-formed and does not trust them for safety; this places     capture-mode strength in the periphery until/unless the kernel adopts a conservative     validator.</li> </ul>"},{"location":"spec/kernel_boundary/#prelude-and-macro-boundary","title":"Prelude and Macro Boundary","text":"<ul> <li>Prelude stack is trusted: compile paths load <code>stdlib/prelude_api.lrl</code> plus a backend platform     layer (<code>stdlib/prelude_impl_dynamic.lrl</code> or <code>stdlib/prelude_impl_typed.lrl</code>) before user code.     These prelude files are part of the TCB and are compiled with reserved primitives enabled.     They may define unsafe/classical axioms that user code cannot introduce silently.</li> <li>Macro boundary is strict for prelude stack: prelude files are compiled with     <code>MacroBoundaryPolicy::Deny</code>, so macro expansion cannot introduce unsafe/classical forms unless     the macro is explicitly allowlisted in the compiler. Any such forms must appear explicitly in     the prelude source or via an allowlisted macro.</li> <li>User code defaults to Deny: <code>--macro-boundary-warn</code> downgrades macro boundary violations to     warnings for user code (not for the prelude).</li> </ul>"},{"location":"spec/kernel_boundary/#2-untrusted-periphery","title":"2. Untrusted Periphery","text":"<p>These components verify properties or transform code, but their correctness is not critical for the logical consistency of the kernel (though bugs here can produce invalid code that the kernel rejects, or runtime bugs).</p> <ol> <li>Elaborator: Infers types, implicit arguments, universe levels, and function kinds. Produces full kernel terms, including explicit universe levels on recursors (kernel rejects missing levels).</li> <li>Parser: Converts text to surface syntax.</li> <li>Code Generator: Compiles core terms to Rust/binary. Relies on the kernel's erasure of proofs.</li> <li>Borrow Checker: Implemented in the <code>mir</code> crate as NLL-style analysis. It is outside the TCB     but enforces the safety contract for <code>borrow_shared</code>/<code>borrow_mut</code> in compiled code. It also     enforces function-call borrow semantics: <code>Fn</code> calls take a shared borrow of the closure     environment, <code>FnMut</code> calls take a mutable borrow, and <code>FnOnce</code> calls consume the closure.     Release-bar invariant: the production pipeline must run MIR typing + NLL for top-level     user-defined bodies and derived closure bodies. Canonical constructor aliases are excluded:     constructors are resolved as constructor values from inductive metadata and are not admitted     as ordinary kernel definitions.</li> </ol>"},{"location":"spec/kernel_boundary/#3-interaction","title":"3. Interaction","text":"<p>The periphery constructs <code>Definition</code> objects and submits them to the kernel (<code>Env::add_definition</code>). The kernel accepts them only if they pass its add-time checks (core invariants, type correctness, ownership, termination/effects for total definitions), and defeq/whnf are fuel-bounded to avoid divergence. The environment does not expose mutable access to definitions in the public API, so kernel checks cannot be skipped by untrusted frontends. Once accepted, a definition is trusted and immutable.</p> <p>For detailed phase contracts and elaboration invariants, see <code>docs/spec/phase_boundaries.md</code>.</p>"},{"location":"spec/kernel_definition/","title":"Minimal Kernel Definition and Trust Boundary","text":""},{"location":"spec/kernel_definition/#1-trusted-computing-base-tcb","title":"1. Trusted Computing Base (TCB)","text":"<p>To ensure \"soundness you can bet a civilization on\", the TCB must be minimal.</p>"},{"location":"spec/kernel_definition/#trusted-components","title":"Trusted Components","text":"<ol> <li>Kernel Type Checker: Implements the typing rules for the core calculus.</li> <li>Definitional Equality Engine: Decides conversion (<code>a \u2261 b</code>). Usually implements Normalization-by-Evaluation (NbE).</li> <li>Core Primitives: Axiomatic semantics for <code>Nat</code>, <code>Eq</code>, and fundamental inductive types.</li> </ol> <p>Everything else is outside the TCB.</p>"},{"location":"spec/kernel_definition/#2-untrusted-components-but-checkable","title":"2. Untrusted Components (But Checkable)","text":"<p>These components can be large and complex, but they must produce artifacts that the trusted kernel or a validator can check.</p> <ol> <li>Elaborator: Translates surface syntax (implicit args, inference) into fully explicit core terms. The kernel rejects invalid terms.</li> <li>Borrow Checker: Analyzes ownership and lifetimes.<ul> <li>Strategy: Emits region/lifetime evidence or passes annotated IR to a small validator. The borrow checker logic itself is not trusted, only its output.</li> </ul> </li> <li>Optimizer: LLVM/MLIR passes.</li> <li>Macro System: Expands syntax. Since macros produce surface syntax which is then refined to core terms, they cannot break soundness (only validity).</li> <li>Code Generator: Lowers to machine code.</li> </ol>"},{"location":"spec/kernel_definition/#3-trust-strategy","title":"3. Trust Strategy","text":"<ul> <li>Proof Erasure: <code>Prop</code> terms are erased.</li> <li>Separation of Concerns: The kernel does not know about memory layout or borrow checking constraints, other than verifying the evidence provided.</li> </ul>"},{"location":"spec/macro_system/","title":"Macro System Specification","text":""},{"location":"spec/macro_system/#overview","title":"Overview","text":"<p>LeanRustLisp (LRL) provides a hygienic, procedural macro system based on syntax objects. The goal is to allow users to extend the language syntax without accidentally capturing variables (hygiene) and without compromising the trusted kernel.</p>"},{"location":"spec/macro_system/#decision-note-2026-02-02","title":"Decision Note (2026-02-02)","text":"<p>Macro expansion target: Macros expand Syntax -&gt; Syntax only. Any lowering to <code>SurfaceTerm</code> (or directly to <code>CoreTerm</code>) is a separate pass (desugaring/elaboration). This enforces a clean phase boundary: macro expansion is purely syntactic and untrusted; elaboration is semantic and type-aware.</p> <p>Rationale: This matches the small-kernel philosophy, improves tooling (<code>:expand</code> shows post-macro syntax), keeps hygiene tied to syntax objects, and simplifies determinism (structural rewriting with predictable caching).</p> <p>Current Syntax -&gt; SurfaceTerm behavior: treat as desugaring (rename/module split), not macro expansion.</p> <p>Quasiquote semantics: quasiquote builds syntax objects (macro-time) rather than runtime lists. Runtime list construction should be expressed explicitly in surface code.</p> <p>Semantic identity: Macros do not mint DefId/AdtId/CtorId/FieldId. Semantic IDs are assigned during elaboration by a deterministic registry. Macro output is plain syntax; any marker traits/attributes are resolved after expansion, not by string matching.</p>"},{"location":"spec/macro_system/#syntax-objects","title":"Syntax Objects","text":"<p>Macros operate on Syntax Objects, not raw S-expressions. A Syntax Object bundles: *   Datum: The structural content (List, Symbol, Int, String). *   Span: Source location information for error reporting. *   Scopes: A set of scope identifiers (marks) used for hygiene.</p> <pre><code>struct Syntax {\n    kind: SyntaxKind,\n    span: Span,\n    scopes: Vec&lt;ScopeId&gt;,\n}\n</code></pre>"},{"location":"spec/macro_system/#hygiene-model","title":"Hygiene Model","text":"<p>LRL uses a Scope Sets model (simplified for this stage).</p>"},{"location":"spec/macro_system/#principles","title":"Principles","text":"<ol> <li>Lexical Scoping: Identifiers are resolved based on their name and their active scopes.</li> <li>Fresh Scopes: Every macro invocation generates a fresh <code>ScopeId</code>.</li> <li>Scope Propagation:<ul> <li>Syntax explicitly introduced by the macro body acquires the fresh <code>ScopeId</code>.</li> <li>Syntax passed as arguments to the macro retains its original scopes (it does not get the fresh scope).</li> </ul> </li> <li>Binder Logic:<ul> <li>A binder (like <code>lam x</code>) binds a name <code>x</code> with a specific set of scopes.</li> <li>A usage <code>x</code> refers to that binder when the binder's normalized scope set is a subset of the usage scope set.</li> <li>Unscoped binders are only resolved by unscoped usages (scoped references do not fall back to unscoped names).</li> </ul> </li> </ol>"},{"location":"spec/macro_system/#example","title":"Example","text":"<p><pre><code>(defmacro m () x) ;; x here has scopes {Module}\n\n(let x 1 (m))\n</code></pre> *   The <code>let</code> binder <code>x</code> has scopes <code>{Module}</code>. *   The <code>(m)</code> expands to <code>x</code> with scopes <code>{Module, MacroScope}</code>. *   Macro-introduced references do not accidentally bind to unrelated unscoped/local binders; the extra macro scope prevents fallback to unscoped names. *   Note: Hygiene resolution is subset-based with deterministic tie-breaking, not strict equality. Nested macro invocations do not implicitly capture binders from outer macro expansions unless scope propagation makes that binder visible.</p>"},{"location":"spec/macro_system/#nested-macro-example-current-behavior","title":"Nested Macro Example (Current Behavior)","text":"<p><pre><code>(defmacro inner () x)\n(defmacro outer (e) `(let x Nat 0 ,e))\n(outer (inner))\n</code></pre> Defined behavior: <code>inner</code> resolves to the global <code>x</code> (or remains unbound), not the <code>x</code> introduced by <code>outer</code>. This follows current subset-based scope resolution and macro-scope propagation; cross-macro capture does not occur unless the binding is passed explicitly.</p>"},{"location":"spec/macro_system/#attributes-and-hygienic-metadata","title":"Attributes and Hygienic Metadata","text":"<p>Attributes (e.g. <code>opaque</code>, <code>transparent</code>) are part of surface syntax and must be preserved through macro expansion.</p> <ul> <li>Propagation: If a macro rewrites a node that carries attributes, it is responsible for explicitly re-attaching them to the replacement node. Attributes are not dropped implicitly.</li> <li>Introduction: Macros may introduce attributes explicitly in their output syntax. There is no hidden injection of attributes by the expander.</li> <li>Hygienic attribute names: Attribute identifiers are scoped like other identifiers, so user-defined attributes cannot accidentally capture or be captured by macro-introduced names.</li> <li>Built-in attributes: Core attributes such as <code>opaque</code> and <code>transparent</code> are reserved and are resolved by name after expansion; they are not shadowable. Macros must emit them explicitly when intended.</li> </ul>"},{"location":"spec/macro_system/#reserved-core-forms","title":"Reserved Core Forms","text":"<p>Macro names that collide with core surface forms are reserved and cannot be defined or shadowed by macros. This preserves explicitness at safety and classical boundaries.</p> <p>Reserved core forms (non-exhaustive but enforced): *   <code>def</code>, <code>partial</code>, <code>unsafe</code> *   <code>axiom</code> *   <code>instance</code> *   <code>inductive</code>, <code>structure</code> *   <code>opaque</code>, <code>transparent</code> *   <code>import</code>, <code>import-macros</code> *   <code>eval</code> *   <code>defmacro</code></p>"},{"location":"spec/macro_system/#staging","title":"Staging","text":"<p>Macros are expanded at compile time (or pre-evaluation time in the REPL). *   Expansion happens top-down, processing macros until a fixed point (or fully expanded). *   Macros cannot execute runtime effects (IO) but can perform logic to rearrange syntax.</p>"},{"location":"spec/macro_system/#macro-environment-and-imports","title":"Macro Environment and Imports","text":"<p>Macros are file-scoped. A file can explicitly import macros from other files using:</p> <pre><code>(import-macros \"path/to/macros.lrl\")\n</code></pre> <ul> <li>Imports are file-scoped and processed before expansion; their position in the file does not affect visibility.</li> <li>Local macros (defined in the file) shadow imported macros of the same name.</li> <li>Imported modules are searched deterministically (lexicographic by module id).</li> <li>Imports are not transitive; if a macro depends on other macro modules, import them explicitly.</li> </ul>"},{"location":"spec/macro_system/#phase-separation-and-eval","title":"Phase Separation and Eval","text":"<p>Macro expansion is compile-time only and operates purely on syntax objects. Runtime evaluation is a separate phase and must be explicit in surface syntax.</p> <ul> <li>Any dynamic evaluation must appear as an explicit form (e.g. <code>(eval &lt;dyn-code&gt; &lt;EvalCap&gt;)</code>) in the expanded syntax.</li> <li>The expander does not insert <code>eval</code> forms or capabilities implicitly.</li> <li>Compile-time macros cannot perform runtime I/O or depend on runtime values; they may only compute and transform syntax.</li> </ul>"},{"location":"spec/macro_system/#expansion-order-and-trace-semantics","title":"Expansion Order and Trace Semantics","text":"<ul> <li>Order: Expansion is deterministic, top-down, and left-to-right within a form. Expansion repeats until a fixed point (no remaining macro calls) or a configured expansion limit.</li> <li>Scope generation: Each macro invocation introduces a fresh scope deterministically.</li> <li>Error/trace: Errors report the span of the macro call site. Diagnostics include a macro-expansion stack (macro name + call-site span) when available, not only on fatal errors.</li> </ul>"},{"location":"spec/macro_system/#quasiquoting","title":"Quasiquoting","text":"<p>To facilitate macro writing, LRL supports: *   <code>(quote x)</code>: Returns the syntax object for <code>x</code> literally. *   <code>(quasiquote x)</code> or <code>`x</code>: Template construction at macro time (produces syntax objects). *   <code>(unquote x)</code> or <code>,x</code>: Insert the syntax object produced by macro-time expansion of <code>x</code> into the template. *   <code>(unquote-splicing x)</code> or <code>,@x</code>: Splice a list of syntax objects produced by macro-time expansion of <code>x</code> into the template.</p>"},{"location":"spec/macro_system/#determinism","title":"Determinism","text":"<p>Macro expansion is deterministic. *   Scope IDs are generated deterministically based on expansion order. *   <code>gensym</code>s use deterministic counters. *   No access to system time or random numbers in macros.</p>"},{"location":"spec/macro_system/#caching-keys","title":"Caching Keys","text":"<p>Expansion results may be cached. A cache key must include: *   Macro identity + definition hash/version. *   Expanded input syntax structure, including identifier names and scopes (spans may be excluded from the key but must be preserved in output). *   Macro environment version (imports, definitions, and any feature flags affecting expansion). *   Expansion mode (e.g. single-step vs full expansion).</p>"},{"location":"spec/macro_system/#classical-logic-and-non-silent-injection","title":"Classical Logic and Non-Silent Injection","text":"<p>Any classical-logic forms (e.g. <code>import classical</code> or explicit <code>axiom</code>/classical tags) must be present explicitly in expanded syntax. *   The expander does not silently inject classical axioms or attributes. *   Macros may emit classical forms, but the output must make the classical dependency explicit to downstream phases and tooling. *   The expander emits a warning diagnostic when a macro expansion produces <code>unsafe</code> forms or classical/unsafe axioms/imports, pointing at the macro call site.</p>"},{"location":"spec/macro_system/#error-handling","title":"Error Handling","text":"<ul> <li>Errors during expansion report the span of the macro usage.</li> <li>If an inner term fails elaboration, the span points to the original source location if preserved, allowing users to debug macros effectively.</li> </ul>"},{"location":"spec/mode_boundaries/","title":"Mode Boundaries: Eval/Dyn (Pre-Interpreter)","text":""},{"location":"spec/mode_boundaries/#decision-note-2026-02-04","title":"Decision Note (2026-02-04)","text":"<p>Runtime <code>eval</code> is a boundary feature. It is capability-gated, returns <code>Dyn</code>, and is forbidden in kernel type positions and definitional equality. Macros are compile-time only (Syntax \u2192 Syntax); runtime evaluation is explicit and effectful.</p>"},{"location":"spec/mode_boundaries/#rules","title":"Rules","text":"<ol> <li><code>eval</code> is capability-gated and has the surface form <code>(eval &lt;dyn-code&gt; &lt;EvalCap&gt;) -&gt; Dyn</code>.</li> <li><code>eval</code> is not allowed in:</li> <li>type positions (declared types, Pi domains/codomains, expected types)</li> <li>definitional equality / normalization (NbE must not reduce <code>eval</code>)</li> <li><code>eval</code> must not be injected by macros in the prelude unless explicitly allowlisted.</li> <li><code>Dyn</code> and <code>EvalCap</code> are nominal placeholders in the prelude; they carry no runtime semantics yet.</li> </ol>"},{"location":"spec/mode_boundaries/#enforcement-points","title":"Enforcement Points","text":"<ul> <li>Frontend: elaborator rejects <code>eval</code> in type contexts early with a targeted diagnostic.</li> <li>Kernel: type-safety checks reject <code>eval</code> in types; defeq/NbE treats <code>eval</code> as opaque.</li> <li>Prelude boundary: macro expansion under Deny rejects <code>eval</code>/<code>axiom</code> smuggling.</li> </ul>"},{"location":"spec/mode_boundaries/#rationale","title":"Rationale","text":"<p>This keeps the trusted kernel free of runtime evaluation semantics while still allowing the surface language to express explicit, capability-gated dynamic evaluation in computational code.</p>"},{"location":"spec/ownership_model/","title":"Ownership and Resource Model","text":"<p>This document outlines how LeanRustLisp integrates Rust-style ownership into a dependent type system.</p>"},{"location":"spec/ownership_model/#1-core-principle","title":"1. Core Principle","text":"<p>Affine Types: Values are affine by default. *   Usage: 0 or 1 times. *   Drop: Allowed (destructors run). *   Copy: Opt-in via derived Copy instances on inductives (surface syntax: <code>(inductive copy ...)</code>). Explicit Copy instances are permitted only under <code>unsafe</code> and are tracked as unsafe axioms.</p>"},{"location":"spec/ownership_model/#11-copy-instances-and-safety","title":"1.1 Copy Instances and Safety","text":"<p>Copy instances come from two sources:</p> <ul> <li>Derived: <code>(inductive copy ...)</code> requests derivation. The kernel checks that the inductive is not interior-mutable and that all constructor fields are Copy (or depend only on parameters). If derivation fails and <code>copy</code> was requested, the declaration is rejected.</li> <li>Explicit: <code>(unsafe instance copy (pi ...))</code> registers a Copy instance. Explicit instances are always treated as unsafe axioms (recorded as <code>copy_instance(TypeName)</code> with the <code>unsafe</code> tag) and are rejected for interior-mutable inductives.</li> </ul> <p>Explicit instances take precedence over derived ones during Copy resolution.</p>"},{"location":"spec/ownership_model/#2-borrowing-references","title":"2. Borrowing &amp; References","text":"<p>Borrowing produces references with explicit lifetimes (regions):</p> <ul> <li>Shared Reference: <code>&amp;'\u03c1 A</code><ul> <li>Read-only access.</li> <li>Copyable (unrestricted).</li> </ul> </li> <li>Unique Reference: <code>&amp;'\u03c1 mut A</code><ul> <li>Read-write access.</li> <li>Linear capability: Cannot be aliased. Must be used linearly to preserve the ability to mutate.</li> </ul> </li> </ul> <p>At the core, references are expressed via the reserved primitives <code>Ref</code>, <code>Shared</code>, and <code>Mut</code> (e.g., <code>Ref Shared A</code>, <code>Ref Mut A</code>). These names are reserved by the kernel and must have fixed prelude-defined signatures; user code may not redefine them.</p> <p>Surface <code>&amp;</code>/<code>&amp;mut</code> desugar to the reserved primitives <code>borrow_shared</code> and <code>borrow_mut</code>. These primitives are admitted by the kernel as total axioms with fixed signatures. Their safety contract is enforced by the MIR borrow checker (outside the TCB), so safe code may borrow without an explicit <code>unsafe</code> marker.</p>"},{"location":"spec/ownership_model/#3-lifetimes-at-the-type-level","title":"3. Lifetimes at the Type Level","text":"<ul> <li>Lifetimes (<code>'\u03c1</code>) are first-class terms at the type level.</li> <li>They are not value-dependent at runtime (erased).</li> <li>The compiler implies a partial order (outlives relation) on regions.</li> <li>Verification: A constraint solver runs on the mid-level IR (LRL-MIR) and generates evidence or checkable constraints for the kernel (or acts as a trusted oracle if split logic is used).</li> </ul>"},{"location":"spec/ownership_model/#31-lifetime-labels-and-elision-function-types","title":"3.1 Lifetime Labels and Elision (Function Types)","text":"<p>Function types may label reference lifetimes by attaching an attribute to <code>Ref</code> in the signature. The label becomes a named region parameter; reusing the same label ties lifetimes together.</p> <p>Core/surface form: <pre><code>Ref #[label] Shared T\nRef #[label] Mut T\n</code></pre></p> <p>Implementation note: lifetime labels are carried structurally on the core <code>Ref</code> application node (not in side tables) and are preserved through term transformations (<code>shift</code>, <code>subst</code>, WHNF). Labels participate in definitional equality (label-strict); see <code>docs/spec/mir/borrows-regions.md</code> \u00a7Call-Site Region Constraints.</p> <p>Example (return tied to the first argument): <pre><code>(pi a (Ref #[a] Shared Nat)\n  (pi b (Ref #[b] Shared Nat)\n    (Ref #[a] Shared Nat)))\n</code></pre></p> <p>Elision rule (Rust-style): if a signature contains exactly one distinct reference lifetime among its inputs, unlabeled return references are assigned that lifetime. Otherwise, return references must be explicitly labeled.</p>"},{"location":"spec/ownership_model/#4-mutation-dependent-types","title":"4. Mutation &amp; Dependent Types","text":"<p>Systems programming wants in-place mutation, but dependent types need type stability.</p> <ul> <li>Rule: <code>&amp;mut T</code> preserves the type <code>T</code>. You cannot change the index of a dependently typed value in-place behind a reference if the index determines the type.<ul> <li>Example: You cannot mutate a <code>Vec A n</code> into a <code>Vec A (n+1)</code> in-place via a simple <code>&amp;mut</code> reference because the type changes.</li> </ul> </li> <li>State Replacement: To change type indices, you must take ownership and return a new value.</li> <li>Existential Packaging: For mutable containers with dynamic size:     <pre><code>(structure Buffer (A : Type)\n  (n : Nat)\n  (data : Vec A n))\n</code></pre>     The <code>n</code> is hidden; mutating the buffer updates <code>n</code> internally.</li> </ul>"},{"location":"spec/ownership_model/#5-safe-concurrency","title":"5. Safe Concurrency","text":"<ul> <li>Contract: Safe code implies no Data Races and no UB.</li> <li>Send/Sync: Modeled as typeclass predicates derived/verified by the compiler.</li> <li>Primitives: Mutexes, RwLocks, and Channels use ownership transfer to ensure safety.</li> </ul>"},{"location":"spec/ownership_model/#6-functions-and-closure-kinds","title":"6. Functions and Closure Kinds","text":"<p>Function values carry an explicit kind (<code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code>) that controls call semantics and ownership. See <code>docs/spec/function_kinds.md</code> for details.</p> <ul> <li>Fn calls use a shared borrow of the closure environment.</li> <li>FnMut calls use a mutable borrow of the closure environment.</li> <li>FnOnce calls consume the closure environment.</li> <li>Function values are non-Copy by default.</li> <li>MIR lowering may mark a closure value Copy-by-clone when all captured     values are Copy, enabling safe duplication of reusable closure adapters.</li> </ul>"},{"location":"spec/ownership_model/#61-implicit-binders-observational-only","title":"6.1 Implicit binders (observational-only)","text":"<p>Implicit binders (<code>{x}</code>) are for inference and erasure, not for consuming resources. For ownership soundness:</p> <ul> <li>Implicit value binders may only be used observationally at runtime:     read or copy, but never move, mutably borrow, or store in non-Copy     positions.</li> <li>Using an implicit value in a consuming position is a kernel error.</li> <li>If you need to consume a value, make the binder explicit.</li> </ul>"},{"location":"spec/ownership_model/#7-implementation-mir-based-analysis","title":"7. Implementation: MIR-Based Analysis","text":"<p>The ownership and borrow checking is implemented in the <code>mir</code> crate as a dataflow analysis over the Mid-level Intermediate Representation (MIR).</p>"},{"location":"spec/ownership_model/#71-architecture","title":"7.1 Architecture","text":"<pre><code>kernel::Term (typed AST)\n     \u2502\n     \u25bc\nmir::lower::MirLowerer\n     \u2502  Lowers Term to MIR Body (basic blocks, statements, terminators)\n     \u25bc\nmir::Body\n     \u2502\n     \u251c\u2500\u2500\u25ba mir::analysis::ownership::OwnershipAnalysis\n     \u2502         Tracks initialization state per local\n     \u2502\n     \u2514\u2500\u2500\u25ba mir::analysis::borrow::BorrowChecker\n               Tracks active loans and reference conflicts\n</code></pre>"},{"location":"spec/ownership_model/#72-ownership-analysis-mirsrcanalysisownershiprs","title":"7.2 Ownership Analysis (<code>mir/src/analysis/ownership.rs</code>)","text":"<p>Tracks the state of each local variable through program execution:</p> <pre><code>enum LocalState {\n    Uninitialized,  // Never assigned or after StorageDead\n    Initialized,    // Has a valid value\n    Moved,          // Value has been moved out\n}\n</code></pre> <p>Key checks performed: - Use after move: Detects when a moved value is used again - Double move in arguments: Catches same value moved multiple times in a call - Uninitialized use: Prevents reading uninitialized locals - Linear type consumption: Ensures linear (non-Copy) types are consumed exactly once - Return initialization: Verifies return value is initialized on all paths</p> <p>Copy type detection: Types are considered Copy if: - They are <code>Sort</code> (types themselves) - They are inductive types with a resolved Copy instance whose requirements are Copy (derived or explicit) - Function types (<code>Pi</code>) are never Copy Function values are non-Copy by default; capture information currently affects call mode, not Copy.</p> <pre><code>fn is_copy_type(&amp;self, ty: &amp;Rc&lt;Term&gt;) -&gt; bool {\n    match whnf(ty) {\n        Term::Sort(_) =&gt; true,\n        Term::Pi(_, _, _, _) =&gt; false,\n        Term::Ind(name, args) =&gt; copy_instance_satisfiable(name, args),\n        _ =&gt; false,\n    }\n}\n</code></pre>"},{"location":"spec/ownership_model/#73-borrow-checking-mirsrcanalysisborrowrs","title":"7.3 Borrow Checking (<code>mir/src/analysis/borrow.rs</code>)","text":"<p>Tracks active loans (borrows) and detects conflicts:</p> <pre><code>struct Loan {\n    place: Place,       // What is borrowed\n    kind: BorrowKind,   // Shared or Mut\n    block: BasicBlock,  // Where the borrow occurred\n}\n\nenum BorrowKind {\n    Shared,  // &amp;T - multiple allowed\n    Mut,     // &amp;mut T - exclusive\n}\n</code></pre> <p>Key checks performed: - Conflicting borrows: Cannot have <code>&amp;mut</code> while any other borrow exists - Use while borrowed: Cannot move/modify a borrowed value - Move out of reference: Cannot move out from behind a reference - Dangling references: Borrowed value must outlive all references - Escaping references: Cannot return references to local variables - Mutate through shared ref: Cannot write through <code>&amp;T</code></p>"},{"location":"spec/ownership_model/#74-structured-error-types-mirsrcerrorsrs","title":"7.4 Structured Error Types (<code>mir/src/errors.rs</code>)","text":"<p>Errors include source location information via <code>MirSpan</code>:</p> <pre><code>struct MirSpan {\n    block: BasicBlock,\n    statement_index: usize,\n}\n\nenum OwnershipError {\n    UseAfterMove { local: Local, location: Option&lt;MirSpan&gt; },\n    DoubleMoveInArgs { local: Local, location: Option&lt;MirSpan&gt; },\n    OverwriteWithoutDrop { local: Local, location: Option&lt;MirSpan&gt; },\n    LinearNotConsumed { local: Local, location: Option&lt;MirSpan&gt; },\n    UninitializedReturn { location: Option&lt;MirSpan&gt; },\n    UseUninitialized { local: Local, location: Option&lt;MirSpan&gt; },\n}\n\nenum BorrowError {\n    ConflictingBorrow { place, existing_kind, requested_kind, location },\n    UseWhileBorrowed { place, borrow_kind, location },\n    MoveOutOfRef { place, location },\n    DanglingReference { borrowed_local, location },\n    EscapingReference { place, location },\n    MutateSharedRef { place, location },\n    AssignWhileBorrowed { place, location },\n}\n</code></pre> <p>Error messages include helpful suggestions: <pre><code>use of moved value: local _1 at block 0 statement 2\n  help: value was moved earlier; consider using Clone or restructuring to avoid the move\n</code></pre></p>"},{"location":"spec/ownership_model/#75-copy-type-metadata","title":"7.5 Copy Type Metadata","text":"<p>Inductive types can request derived Copy via the <code>is_copy</code> field in <code>InductiveDecl</code>. This is a derivation request; the kernel attempts to build a Copy instance and rejects the inductive if derivation fails. Explicit Copy instances are stored separately and treated as unsafe axioms.</p> <pre><code>// kernel/src/ast.rs\nstruct InductiveDecl {\n    name: String,\n    univ_params: Vec&lt;String&gt;,\n    num_params: usize,\n    ty: Rc&lt;Term&gt;,\n    ctors: Vec&lt;Constructor&gt;,\n    is_copy: bool,  // Whether Copy derivation was explicitly requested\n    markers: Vec&lt;TypeMarker&gt;,\n    axioms: Vec&lt;String&gt;,\n}\n\nimpl InductiveDecl {\n    fn new(name, ty, ctors) -&gt; Self { /* is_copy: false */ }\n    fn new_copy(name, ty, ctors) -&gt; Self { /* is_copy: true */ }\n}\n</code></pre> <p>Resolved Copy instances (derived or explicit) are propagated to MIR locals via <code>LocalDecl::is_copy</code>, enabling the ownership analysis to distinguish between linear and freely-copyable types.</p>"},{"location":"spec/ownership_model/#76-integration-points","title":"7.6 Integration Points","text":"<p>Lowering (<code>mir/src/lower.rs</code>): - Converts kernel <code>Term</code> to MIR <code>Body</code> - Resolves Copy via kernel Copy-instance checking for each local - Generates <code>Move</code> vs <code>Copy</code> operands based on type</p> <p>Compilation (<code>cli/src/compiler.rs</code>): - After MIR lowering, runs ownership and borrow analysis - Reports structured errors with location information - Only proceeds to codegen if analyses pass</p>"},{"location":"spec/phase_boundaries/","title":"Phase Boundaries and Core Invariants","text":"<p>This document records the contract between compiler phases. It is the source of truth for what each phase must produce and what downstream phases may assume.</p>"},{"location":"spec/phase_boundaries/#1-macro-expansion-boundary","title":"1. Macro Expansion Boundary","text":"<p>Input: surface syntax (S-expressions + macro forms).</p> <p>Output: surface syntax with macros expanded.</p> <p>Invariants: - Expansion is deterministic (no order-dependent results). - Hygiene is preserved (introduced binders do not capture). - Source spans are retained on expanded syntax where possible. - Span contract: nodes originating from existing syntax keep their spans; nodes synthesized by macro   expansion (including quasiquote list constructors) use the span of the originating form. <code>unquote</code>   and <code>unquote-splicing</code> preserve the spans of the inserted syntax. - Expansion does not introduce core terms; it only produces surface syntax. - Attributes (e.g. <code>opaque</code>, <code>transparent</code>) are preserved or explicitly re-attached by macro output. - Expansion is compile-time only; any runtime evaluation must be an explicit surface form (e.g. <code>eval</code>). - Classical logic imports/axioms must appear explicitly in expanded syntax (no silent injection).</p>"},{"location":"spec/phase_boundaries/#2-elaboration-boundary","title":"2. Elaboration Boundary","text":"<p>Input: expanded surface syntax.</p> <p>Output: kernel core terms (<code>kernel::ast::Term</code>) plus core definitions.</p> <p>Invariants: - No <code>Term::Meta</code> remains (all metas solved). - All implicit arguments are inserted; the term is fully explicit. - <code>match</code> is fully desugared to <code>Rec</code> with an explicit motive. - Every <code>Rec</code> term carries explicit universe levels (no empty level list), with the level list   ordered as <code>[inductive universe params..., motive level]</code>. - <code>Fix</code> is only used at function types (enforced by the kernel). - Lambda/function kinds are inferred and attached to <code>Lam</code>/<code>Pi</code>. Explicit kind   annotations (if present) must be at least the inferred kind. - Core-term invariants are validated after elaboration (e.g. <code>kernel::checker::validate_core_term</code>).</p> <p>The elaborator is responsible for computing the recursor universe level from the motive type and attaching it to <code>Rec</code> together with the inductive's universe parameters.</p>"},{"location":"spec/phase_boundaries/#3-kernel-boundary","title":"3. Kernel Boundary","text":"<p>Input: fully explicit core terms from elaboration.</p> <p>Output: accepted definitions in the kernel environment (or a rejection).</p> <p>Invariants enforced by the kernel: - Type checking for all terms. - Definitional equality (NbE). - Large elimination restrictions for <code>Prop</code>. - Termination / totality boundaries. - Explicit recursor levels are required. - Function kind validation for <code>Lam</code>/<code>Pi</code> (e.g., <code>FnOnce</code> values are not treated   as <code>Fn</code> without an explicit coercion). - Effect boundaries are enforced via totality markers (total cannot call partial/unsafe;   partial cannot call unsafe). Effect typing (requiring <code>Comp</code> returns) is enforced. - Capture-mode annotations are checked for structural validity only   (closure id exists, indices reference actual free variables). The kernel does not   enforce capture-mode strength.</p>"},{"location":"spec/phase_boundaries/#4-mir-lowering-boundary","title":"4. MIR Lowering Boundary","text":"<p>Input: kernel-accepted core terms.</p> <p>Output: MIR bodies.</p> <p>Invariants expected by MIR lowering: - Core terms are explicit and contain no surface constructs. - <code>Rec</code> is the canonical elimination form (pattern matching already desugared). - Inductive parameters and indices are explicit in <code>Rec</code> applications. - <code>Fix</code> is only used at function types (safe lowering). - MIR recomputes required capture modes from closure usage and rejects any   annotation that is weaker than required. Capture modes determine whether a   captured value is moved or borrowed (and with what mutability), and MIR   instantiates the corresponding regions/borrows during lowering.</p>"},{"location":"spec/phase_boundaries/#5-safety-and-codegen-boundary","title":"5. Safety and Codegen Boundary","text":"<p>Input: MIR bodies.</p> <p>Output: borrow-checked MIR and generated Rust.</p> <p>Invariants: - Borrow and ownership checks are applied before codegen. - The production pipeline must run MIR typing + NLL for top-level user-defined   bodies and derived closure bodies (this is a release-bar invariant). - Canonical constructor aliases are excluded: constructors are resolved from   inductive metadata as constructor values, not admitted as ordinary definitions. - <code>Prop</code> terms are erased before codegen (no runtime dependence on proofs).</p>"},{"location":"spec/phase_boundaries/#6-failure-policy","title":"6. Failure Policy","text":"<p>Any phase may reject input that violates these invariants. The kernel remains the ultimate authority for soundness.</p>"},{"location":"spec/prelude_api/","title":"Prelude API Contract","text":""},{"location":"spec/prelude_api/#architecture","title":"Architecture","text":"<p>Prelude loading is now layered:</p> <ol> <li><code>stdlib/prelude_api.lrl</code> (shared public contract)</li> <li>backend platform layer</li> <li>dynamic: <code>stdlib/prelude_impl_dynamic.lrl</code></li> <li>typed/auto: <code>stdlib/prelude_impl_typed.lrl</code></li> </ol> <p>The user-facing assumption is: programs target the API contract, not a backend-specific prelude file.</p>"},{"location":"spec/prelude_api/#guaranteed-api-surface-01","title":"Guaranteed API Surface (0.1)","text":"<p>The following names are guaranteed by <code>prelude_api.lrl</code>:</p> <ul> <li>Marker axioms:</li> <li><code>interior_mutable</code></li> <li><code>may_panic_on_borrow_violation</code></li> <li><code>concurrency_primitive</code></li> <li><code>atomic_primitive</code></li> <li><code>indexable</code></li> <li>Core types/constructors:</li> <li><code>Nat</code>, <code>zero</code>, <code>succ</code></li> <li><code>Bool</code>, <code>true</code>, <code>false</code></li> <li><code>False</code></li> <li><code>List</code>, <code>nil</code>, <code>cons</code></li> <li><code>Comp</code>, <code>ret</code>, <code>bind</code></li> <li><code>Eq</code>, <code>refl</code></li> <li>Core functions:</li> <li><code>add</code>, <code>append</code>, <code>not</code>, <code>if_nat</code>, <code>and</code>, <code>or</code></li> <li><code>print_nat</code>, <code>print_bool</code></li> </ul> <p><code>append</code> is executable in the shared API prelude. Current signature is Nat-list focused: <code>append : List Nat -&gt; List Nat -&gt; List Nat</code>. It is defined once in <code>prelude_api.lrl</code> and must not be redefined in backend impl preludes. - Borrow/index/runtime boundary names:   - <code>Shared</code>, <code>Mut</code>, <code>Ref</code>, <code>borrow_shared</code>, <code>borrow_mut</code>   - <code>VecDyn</code>, <code>Slice</code>, <code>Array</code>   - <code>index_vec_dyn</code>, <code>index_slice</code>, <code>index_array</code>   - <code>RefCell</code>, <code>Mutex</code>, <code>Atomic</code></p>"},{"location":"spec/prelude_api/#platform-surface-allowed-in-impl-layers","title":"Platform Surface (Allowed in Impl Layers)","text":"<p>Backend implementation preludes are restricted to platform-dependent items:</p> <ul> <li>Dynamic platform (<code>prelude_impl_dynamic.lrl</code>):</li> <li><code>Dyn</code>, <code>EvalCap</code>, <code>eval</code></li> <li>Typed platform (<code>prelude_impl_typed.lrl</code>):</li> <li><code>Dyn</code>, <code>EvalCap</code>, <code>eval</code> (typed representation)</li> </ul> <p>Implementation preludes should not carry shared stdlib algorithms (for example <code>add</code>, <code>not</code>, <code>and</code>, <code>or</code>, <code>if_nat</code>). This includes <code>append</code>, which is part of the shared public API layer.</p>"},{"location":"spec/prelude_api/#stdlib-migration-boundary","title":"Stdlib Migration Boundary","text":"<p>The migration target is:</p> <ul> <li><code>prelude_api.lrl</code> = public API contract and stable exported names.</li> <li><code>prelude_impl_dynamic.lrl</code> / <code>prelude_impl_typed.lrl</code> = platform substrate only.</li> <li>shared, backend-neutral library logic = <code>stdlib/std/*</code> modules.</li> </ul> <p>Ownership rules for definitions:</p> <ul> <li>Pure library algorithms must be defined once in shared stdlib modules (or temporarily in <code>prelude_api.lrl</code> while migrating).</li> <li>Backend impl preludes must not define or redefine user-facing stdlib algorithms.</li> <li>If a definition is needed only to bridge backend runtime representation, it may live in an impl prelude and must be documented as platform-specific.</li> </ul> <p>Current 0.1 status:</p> <ul> <li>Core shared algorithms still live in <code>prelude_api.lrl</code>.</li> <li>Platform impl preludes are restricted to <code>Dyn</code> / <code>EvalCap</code> / <code>eval</code> substrate.</li> <li>Moving shared algorithms from <code>prelude_api.lrl</code> into <code>stdlib/std/*</code> is a staged migration, with API names kept stable.</li> </ul>"},{"location":"spec/prelude_api/#guard-policy","title":"Guard Policy","text":"<p><code>cli/tests/prelude_api_conformance.rs</code> enforces:</p> <ul> <li>shared API symbols are present when loading API + impl per backend</li> <li>platform impl files stay small (definition-count threshold)</li> <li>impl files do not duplicate shared stdlib algorithm definitions</li> </ul>"},{"location":"spec/syntax_contract_0_1/","title":"LRL 0.1 Syntax Contract (Draft)","text":"<p>This document is an evidence-based snapshot of the syntax currently implemented in the parser, macro expander, declaration parser, desugarer, elaborator, and CLI driver as of 2026-02-05. It also proposes a minimal set of missing syntax that should be frozen early to avoid breaking changes.</p> <p>Code audit targets (primary sources): - Reader/parser: <code>frontend/src/parser.rs</code>, <code>frontend/src/surface.rs</code> - Macro expansion: <code>frontend/src/macro_expander.rs</code> - Top-level forms: <code>frontend/src/declaration_parser.rs</code> - Term desugaring/elaboration: <code>frontend/src/desugar.rs</code>, <code>frontend/src/elaborator.rs</code> - CLI/driver: <code>cli/src/driver.rs</code>, <code>cli/src/compiler.rs</code></p> <p>Part 1 \u2014 Syntax That Exists Today (Evidence-Based)</p> <p>1) Reader &amp; Lexical Layer</p> <p>Program shape: - A program is a sequence of forms (zero or more). The parser returns <code>Vec&lt;Syntax&gt;</code>.</p> <p>Comments: - Line comments start with <code>;</code> and run to end of line.</p> <p>Whitespace: - Any Unicode whitespace (<code>char::is_whitespace</code>) separates tokens.</p> <p>Delimiters: - Lists use parentheses: <code>( ... )</code>. - Braced lists use braces: <code>{ ... }</code>. - Indexing uses brackets: <code>expr[expr]</code> (see below).</p> <p>Literals: - Integers: non-negative decimal digits only (<code>[0-9]+</code>). No sign prefix. Parsed as <code>usize</code>. - Strings: double-quoted. Supports escapes <code>\\n</code>, <code>\\r</code>, <code>\\t</code>, <code>\\\"</code>, <code>\\\\</code>. Unknown escapes keep the backslash. - Symbols: any run of non-whitespace characters excluding <code>(){}[]</code>. - Hole: <code>_</code> is a dedicated token, not a symbol.</p> <p>Indexing: - Postfix index syntax <code>expr [ index ]</code> is parsed as <code>SyntaxKind::Index</code>. - Indexing associates left-to-right and can be repeated: <code>a[b][c]</code>.</p> <p>Quote tokens (reader sugar): - <code>'x</code> =&gt; <code>(quote x)</code> - <code>`x</code> =&gt; <code>(quasiquote x)</code> - <code>,x</code> =&gt; <code>(unquote x)</code> - <code>,@x</code> =&gt; <code>(unquote-splicing x)</code></p> <p>Spans: - Each syntax node carries <code>Span { start, end, line, col }</code>. - <code>start/end</code> are byte offsets in the input. - <code>line</code> starts at 1; <code>col</code> starts at 0 at line start. - List and braced list spans cover from their opening delimiter to their closing delimiter.</p> <p>Parse errors: - <code>UnexpectedEof</code>, <code>UnexpectedChar</code>, <code>UnmatchedParen</code> are emitted by the parser.</p> <p>2) Syntax Objects &amp; Macro Hygiene Model</p> <p>Syntax node kinds (see <code>SyntaxKind</code>): - <code>List</code>, <code>BracedList</code>, <code>Index</code>, <code>Symbol</code>, <code>String</code>, <code>Int</code>, <code>Hole</code>.</p> <p>Hygiene model: - Each <code>Syntax</code> carries a <code>scopes: Vec&lt;ScopeId&gt;</code>. - Macro expansion introduces a fresh scope id for each macro call and attaches it to all nodes originating from the macro body. - Macro arguments are substituted verbatim and keep their original scopes. - Spans of macro-introduced nodes are remapped to the call-site span; substituted arguments keep their original spans.</p> <p>Identifier resolution in desugaring: - Desugaring normalizes scope sets (sort + dedup) and resolves references by exact scope-set match. - The most specific (largest) matching scope set wins.</p> <p>Quote/quasiquote model: - <code>quote</code> prevents macro expansion under it. - <code>quasiquote</code> expands recursively and handles <code>unquote</code> and <code>unquote-splicing</code> with nesting depth. - <code>unquote</code> expands its inner expression at depth 1. - <code>unquote-splicing</code> is only valid inside list contexts at depth 1; its expansion must yield a list/braced-list which is spliced.</p> <p>Reserved macro names: - Macros cannot use these names, and forms with these heads are not macro-expandable (only their arguments are expanded): <code>axiom</code>, <code>def</code>, <code>defmacro</code>, <code>eval</code>, <code>import</code>, <code>import-macros</code>, <code>inductive</code>, <code>instance</code>, <code>opaque</code>, <code>partial</code>, <code>noncomputable</code>, <code>structure</code>, <code>transparent</code>, <code>unsafe</code>.</p> <p>3) Top-Level Forms (Declarations)</p> <p>Top-level forms are parsed after macro expansion. Anything not recognized as a declaration is treated as a term expression.</p> <p>(def ...) / (partial ...) / (unsafe ...) / (noncomputable ...)</p> <p>Syntax: - <code>(def name type value)</code> - <code>(def opaque name type value)</code> - <code>(def transparent name type value)</code> - <code>(partial name type value)</code> - <code>(partial opaque name type value)</code> - <code>(partial transparent name type value)</code> - <code>(unsafe name type value)</code> - <code>(unsafe opaque name type value)</code> - <code>(unsafe transparent name type value)</code> - <code>(noncomputable name type value)</code> - <code>(noncomputable opaque name type value)</code> - <code>(noncomputable transparent name type value)</code></p> <p>Notes: - <code>def</code> and <code>partial</code> default to <code>transparent</code> if no transparency modifier is given. - <code>unsafe</code> is a totality marker (<code>Totality::Unsafe</code>). - <code>noncomputable</code> sets a flag but does not change totality. - <code>fix</code> is rejected in any definition whose totality is not <code>partial</code>.</p> <p>Example: <pre><code>(def id (pi (x (sort 0)) (sort 0)) (lam x (sort 0) x))\n(partial diverge (pi (x (sort 0)) (sort 0)) (fix f (pi (x (sort 0)) (sort 0)) (lam x (sort 0) (f x))))\n(unsafe opaque raw_ffi (pi (x (sort 0)) (sort 0)) (lam x (sort 0) x))\n</code></pre></p> <p>Errors: - Wrong arity. - Name must be a symbol. - Non-<code>partial</code> definitions cannot contain <code>fix</code>.</p> <p>(opaque ...) / (transparent ...)</p> <p>Syntax: - <code>(opaque name type value)</code> - <code>(transparent name type value)</code></p> <p>These are equivalent to <code>def</code> with a fixed transparency.</p> <p>(axiom ...)</p> <p>Syntax: - <code>(axiom name type)</code> - <code>(axiom tag name type)</code> - <code>(axiom (tag1 tag2 ...) name type)</code></p> <p>Tags: - <code>classical</code>, <code>unsafe</code> only.</p> <p>Example: <pre><code>(axiom classical choice (pi (A (sort 0)) (sort 0)))\n(axiom (classical unsafe) excluded_middle (sort 0))\n</code></pre></p> <p>Errors: - Name must be a symbol. - Tags must be symbols or a list of symbols. - Unknown tags are rejected. - If CLI flag <code>--require-axiom-tags</code> is enabled, empty tags are rejected.</p> <p>(inductive ...)</p> <p>Syntax: - <code>(inductive Name Type ctor ...)</code> - <code>(inductive (attr1 attr2 ...) Name Type ctor ...)</code> - <code>(inductive {attr1 attr2 ...} Name Type ctor ...)</code> - <code>(inductive copy Name Type ctor ...)</code> - <code>(inductive copy (attr1 attr2 ...) Name Type ctor ...)</code></p> <p>Constructor specs: - <code>(Name Type)</code> - <code>(Name : Type)</code> - <code>(ctor Name Type)</code> (keyworded form)</p> <p>Attributes: - <code>copy</code> is a special attribute that sets <code>is_copy</code>. - Other attributes are treated as inductive type markers (see Attributes section).</p> <p>Example: <pre><code>(inductive Nat (sort 0)\n  (Zero Nat)\n  (Succ (pi (n Nat) Nat)))\n\n(inductive copy (indexable) VecDyn (sort 0)\n  (Nil (ind VecDyn))\n  (Cons (pi (n Nat) (pi (xs (ind VecDyn)) (ind VecDyn)))))\n</code></pre></p> <p>Errors: - Name must be a symbol. - Attributes must be symbols. - Each ctor must be a list of the accepted shapes.</p> <p>(instance ...)</p> <p>Syntax: - <code>(instance TraitName Head Requirement*)</code> - <code>(unsafe instance TraitName Head Requirement*)</code></p> <p>Example: <pre><code>(instance Copy (ind Nat))\n(unsafe instance Copy (ind Dyn) dyn_copy)\n</code></pre></p> <p>Errors: - Trait name must be a symbol. - Requires at least <code>TraitName</code> and <code>Head</code>.</p> <p>(defmacro ...)</p> <p>Syntax: - <code>(defmacro name (arg1 arg2 ...) body)</code></p> <p>Example: <pre><code>(defmacro unless (cond body)\n  (quasiquote (if (unquote cond) (quote ()) (unquote body))))\n</code></pre></p> <p>Errors: - Name must be a symbol and not reserved. - Args must be symbols. - Arity must be exactly 3 items after the head.</p> <p>(module ...)</p> <p>Syntax: - <code>(module std.list)</code></p> <p>Rules: - At most one module declaration is allowed per file. - Module declarations must appear before other declarations in a file. - Unqualified declaration names are recorded under the module path.</p> <p>(import ...)</p> <p>Syntax: - <code>(import std.list as List)</code> (recommended) - <code>(import std.list)</code> (default alias is the last module segment, e.g. <code>list</code>) - <code>(import classical)</code> (special axiom import form)</p> <p>Rules: - Importing modules does not open them into unqualified scope. - Qualified lookup can use alias prefixes (<code>List.map</code>) or full module paths (<code>std.list.map</code>). - Importing an unknown module is an error.</p> <p>Errors: - Invalid shape is rejected; only <code>(import &lt;module&gt;)</code>, <code>(import &lt;module&gt; as &lt;alias&gt;)</code>, or <code>(import classical)</code> are accepted.</p> <p>(open ...)</p> <p>Syntax: - <code>(open List)</code> (open alias) - <code>(open std.list)</code> (open explicit module path) - <code>(open list)</code> is only legal if it resolves uniquely among imported modules/aliases.</p> <p>Rules: - Opened modules contribute to unqualified resolution in declaration order. - If multiple opened modules provide the same unqualified name, unqualified use is an error (no \u201clast open wins\u201d).</p> <p>Name resolution contract: - Unqualified lookup order: local binders &gt; current module &gt; opened modules (ordered) &gt; prelude/global unqualified names. - Imported aliases are qualified-only and do not participate in unqualified lookup unless opened. - Qualified lookup (<code>A.x</code> or <code>std.list.x</code>) resolves only through alias/module paths and never falls back to unqualified lookup. - Qualified names do not resolve to local binders.</p> <p>(import-macros ...)</p> <p>Syntax: - <code>(import-macros \"path\" \"path2\" ...)</code></p> <p>Notes: - This is handled by the CLI driver before macro expansion. - Each argument must be a string literal. - Paths are resolved relative to the current file. - Imports are recursive and cycle-checked.</p> <p>Top-level expression</p> <p>Any other form or atom is treated as an expression, elaborated, and (in the CLI) evaluated/displayed.</p> <p>4) Term-Level Special Forms</p> <p>(lam ...)</p> <p>Syntax: - <code>(lam binder type body)</code> - <code>(lam kind binder type body)</code></p> <p><code>kind</code> tokens: - <code>fn</code>, <code>fnmut</code>, <code>fnonce</code> - <code>#[fn]</code>, <code>#[mut]</code>, <code>#[once]</code></p> <p>Binder forms: - <code>x</code> (explicit) - <code>{x}</code> (implicit) - <code>_</code> (wildcard binder)</p> <p>Example: <pre><code>(lam x (sort 0) x)\n(lam #[once] {f} (pi (x (sort 0)) (sort 0)) (f x))\n</code></pre></p> <p>Errors: - Arity must be 4 or 5. - Binder must be a symbol, <code>{symbol}</code>, or <code>_</code>.</p> <p>(pi ...)</p> <p>Syntax (without kind token): - <code>(pi x T body)</code> - <code>(pi {x} T body)</code> - <code>(pi (x T) body)</code> - <code>(pi {x T} body)</code></p> <p>Syntax (with kind token): - <code>(pi fn x T body)</code> - <code>(pi fn (x T) body)</code> - <code>(pi #[fn] x T body)</code> - <code>(pi #[mut] (x T) body)</code></p> <p>Example: <pre><code>(pi (x (sort 0)) (sort 0))\n(pi #[mut] {f} (pi (x (sort 0)) (sort 0)) (sort 0))\n</code></pre></p> <p>Errors: - Binder must be <code>symbol</code>, <code>{symbol}</code>, <code>(symbol type)</code>, or <code>{symbol type}</code>. - Arity must match one of the accepted shapes.</p> <p>(let ...)</p> <p>Syntax: - <code>(let name type value body)</code></p> <p>Example: <pre><code>(let x (sort 0) (sort 0) x)\n</code></pre></p> <p>Errors: - Arity must be 4. - Name must be a symbol.</p> <p>(match ...)</p> <p>Syntax: - <code>(match scrutinee ret_type case+ )</code> - <code>case</code> form: <code>(case (Ctor arg1 arg2 ...) body)</code></p> <p>Example: <pre><code>(match xs (sort 0)\n  (case (Nil) (sort 0))\n  (case (Cons x xs) x))\n</code></pre></p> <p>Errors: - At least one case required. - Each case must be <code>(case (Ctor ...) body)</code>. - Constructor name must be a symbol.</p> <p>(match_list ...)</p> <p>Syntax: - <code>(match_list scrut param_t ret_t case_nil case_cons)</code> - <code>case_nil</code> must be <code>(case (nil t) body)</code>. - <code>case_cons</code> must be <code>(case (cons t h tl) body)</code> (exactly 4 items in pattern).</p> <p>Notes: - This form is implemented in the desugarer but appears unused.</p> <p>(fix ...)</p> <p>Syntax: - <code>(fix name type body)</code></p> <p>Notes: - <code>fix</code> is only permitted inside <code>partial</code> definitions.</p> <p>(eval ...)</p> <p>Syntax: - <code>(eval code cap)</code></p> <p>Notes: - Elaboration rejects <code>eval</code> when used in a type context.</p> <p>(quote ...)</p> <p>Syntax: - <code>(quote datum)</code> - <code>'datum</code> reader sugar</p> <p>Desugaring behavior: - Lists become <code>List</code> constructor chains. - Integers become <code>Nat</code> constructor chains. - Strings and symbols become lists of character codes (<code>Nat</code>) via <code>quote_syntax</code>. - Other syntax nodes become <code>_</code>.</p> <p>String literals in term position: - <code>\"abc\"</code> desugars to a <code>List Nat</code> of character codes (same as <code>quote</code> on strings).</p> <p>(sort ...)</p> <p>Syntax: - <code>(sort n)</code></p> <p>Notes: - <code>n</code> is an integer literal. - Current implementation maps <code>n</code> to <code>Level::Succ^n(Zero)</code>.</p> <p>(ind ...) / (ctor ...) / (rec ...)</p> <p>Syntax: - <code>(ind Name)</code> - <code>(ctor Name idx)</code> - <code>(rec Name)</code></p> <p>Notes: - <code>(rec Name)</code> is a placeholder; elaboration errors if used without a motive.</p> <p>Application and implicit arguments</p> <p>Syntax: - General application is any list not starting with a special-form keyword. - Each braced singleton argument <code>{arg}</code> is treated as an implicit argument.</p> <p>Example: <pre><code>(f x {y} z)\n</code></pre></p> <p>(app ...)</p> <p>Syntax: - <code>(app f arg)</code> - <code>(app f {arg})</code></p> <p>Notes: - Equivalent to a single-step application with explicit/implicit determined by braces.</p> <p>(&amp; ...) / (&amp;mut ...)</p> <p>Syntax: - <code>(&amp; x)</code> desugars to <code>(borrow_shared x)</code>. - <code>(&amp;mut x)</code> desugars to <code>(borrow_mut x)</code>.</p> <p>Indexing</p> <p>Syntax: - <code>expr[index]</code></p> <p>Notes: - Desugars to <code>SurfaceTermKind::Index</code>. - Elaboration rewrites indexing into calls to:   - <code>index_vec_dyn</code> for <code>VecDyn</code>   - <code>index_slice</code> for <code>Slice</code>   - <code>index_array</code> for <code>Array</code> - Indexing other types is rejected.</p> <p>5) Attribute &amp; Annotation Grammar</p> <p>Function kind annotations: - <code>fn</code>, <code>fnmut</code>, <code>fnonce</code> - <code>#[fn]</code>, <code>#[mut]</code>, <code>#[once]</code> - Accepted only as the optional first argument to <code>lam</code> and <code>pi</code>.</p> <p>Lifetime labels (for <code>Ref</code> applications): - <code>#[label]</code> is parsed as an index of symbol <code>#</code>. - Used as the first argument to <code>Ref</code> to attach a labeled lifetime.</p> <p>Example: <pre><code>(Ref #[a] T x)\n</code></pre></p> <p>Inductive type markers (attributes): - Recognized markers: <code>interior_mutable</code>, <code>may_panic_on_borrow_violation</code>, <code>concurrency_primitive</code>, <code>atomic_primitive</code>, <code>indexable</code>. - <code>interior_mutable</code> is only valid together with one of <code>may_panic_on_borrow_violation</code>, <code>concurrency_primitive</code>, <code>atomic_primitive</code>. - The marker names are validated against environment definitions.</p> <p>No other general attribute syntax is currently supported.</p> <p>6) Mode Boundaries Enforced by Syntax/Rules</p> <ul> <li><code>fix</code> is rejected in any definition whose totality is not <code>partial</code> (<code>frontend/src/declaration_parser.rs</code>).</li> <li><code>eval</code> is rejected in type context (<code>frontend/src/elaborator.rs</code>).</li> <li>Macro boundary policy (default: deny) prevents macros from expanding into:</li> <li><code>unsafe</code> forms with arity \u2265 3</li> <li><code>eval</code></li> <li><code>axiom</code> (tagged or untagged)</li> <li><code>(import classical)</code></li> <li>Prelude macro boundary allowlist is currently empty (<code>cli/src/lib.rs</code>).</li> </ul> <p>7) CLI/Driver Expectations</p> <p>Prelude loading: - compile paths load <code>stdlib/prelude_api.lrl</code> first, then backend impl:   - dynamic: <code>stdlib/prelude_impl_dynamic.lrl</code>   - typed/auto: <code>stdlib/prelude_impl_typed.lrl</code> - Prelude macros are set as default imports in the macro expander. - Redefinition of prelude names is blocked when prelude is frozen (default behavior).</p> <p>Macro imports: - <code>(import-macros ...)</code> is handled before expansion. - Imported files are parsed, macro-imported recursively, and their <code>defmacro</code> forms are registered. - Cycle detection is enforced.</p> <p>Axiom tagging policy: - <code>--require-axiom-tags</code> enforces at least one tag on <code>(axiom ...)</code>.</p> <p>Part 2 \u2014 Missing Syntax That Should Be Defined Early (Minimal Additions Only)</p> <p>Items below remain intentionally minimal after freezing module/import/open behavior.</p> <p>1) Multi-binder sugar for <code>lam</code>/<code>pi</code> - Proposed spelling: <code>(lam (x A) (y B) body)</code> and <code>(pi (x A) (y B) C)</code> - Desugars to: nested <code>lam</code>/<code>pi</code>. - Why freeze early: common in stdlib; avoids later syntax changes. - Status: experimental sugar.</p> <p>2) Arrow sugar for <code>pi</code> - Proposed spelling: <code>(-&gt; A B C)</code> - Desugars to: <code>(pi _ A (pi _ B C))</code>. - Why freeze early: pervasive in type signatures. - Status: experimental sugar.</p> <p>3) Term-level string literal semantics - Proposed spelling: existing string literal <code>\"...\"</code> in term position - Desugars to: <code>List Nat</code> character-code lists (bootstrap choice for 0.1). - Why freeze early: strings already parse; without a contract, future changes are breaking. - Status: core frozen.</p> <p>4) Struct/record surface sugar - Proposed spelling: <code>(struct Name (field T) ...)</code> - Desugars to: <code>inductive</code> + projections + constructor. - Why freeze early: likely stdlib data modeling; can be optional. - Status: experimental sugar.</p> <p>Part 3 \u2014 LRL 0.1 Syntax Contract</p> <p>FROZEN CORE SYNTAX (0.1) - Reader tokens and delimiters: lists <code>(...)</code>, braced lists <code>{...}</code>, indexing <code>expr[expr]</code>, quote tokens <code>'</code>, <code>`</code>, <code>,</code>, <code>,@</code>. - Literals: non-negative integers, strings, symbols, hole <code>_</code>. - Macro system: <code>defmacro</code>, <code>quote</code>, <code>quasiquote</code>, <code>unquote</code>, <code>unquote-splicing</code>, reserved macro heads. - Top-level declarations: <code>module</code>, <code>import</code> (module + alias + <code>classical</code>), <code>open</code>, <code>def</code>, <code>partial</code>, <code>unsafe</code>, <code>noncomputable</code>, <code>opaque</code>, <code>transparent</code>, <code>axiom</code>, <code>inductive</code>, <code>instance</code>. - Macro import directive: <code>import-macros</code>. - Term forms: <code>lam</code>, <code>pi</code>, <code>let</code>, <code>match</code>, <code>fix</code>, <code>eval</code>, <code>quote</code>, <code>sort</code>, <code>ind</code>, <code>ctor</code>, <code>rec</code>. - Application and implicit arguments via braced singletons. - Function kind annotations: <code>fn</code>, <code>fnmut</code>, <code>fnonce</code>, <code>#[fn]</code>, <code>#[mut]</code>, <code>#[once]</code>. - Lifetime label syntax for <code>Ref</code>: <code>#[label]</code> as first argument.</p> <p>Core Grammar (EBNF-ish)</p> <pre><code>program      ::= { form }\nform         ::= decl | term | macro_import\n\nmacro_import ::= \"(\" \"import-macros\" string { string } \")\"\n\ndecl         ::= def | partial | unsafe_def | noncomputable\n              | opaque | transparent | axiom | inductive | instance\n              | module_decl | import_decl | open_decl | import_classical | defmacro\n\ndef          ::= \"(\" \"def\" [transparency] name term term \")\"\npartial      ::= \"(\" \"partial\" [transparency] name term term \")\"\nunsafe_def   ::= \"(\" \"unsafe\" name term term \")\"\n              | \"(\" \"unsafe\" \"instance\" name term { term } \")\"\nnoncomputable::= \"(\" \"noncomputable\" [transparency] name term term \")\"\nopaque       ::= \"(\" \"opaque\" name term term \")\"\ntransparent  ::= \"(\" \"transparent\" name term term \")\"\ntransparency ::= \"opaque\" | \"transparent\"\n\naxiom        ::= \"(\" \"axiom\" [axiom_tags] name term \")\"\naxiom_tags   ::= symbol | \"(\" { symbol } \")\"\n\ninductive    ::= \"(\" \"inductive\" [ind_attrs] name term { ctor_spec } \")\"\nind_attrs    ::= \"copy\" [attr_list] | attr_list\nattr_list    ::= \"(\" { symbol } \")\" | \"{\" { symbol } \"}\"\nctor_spec    ::= \"(\" symbol term \")\" | \"(\" symbol \":\" term \")\" | \"(\" symbol symbol term \")\"\n\ninstance     ::= \"(\" \"instance\" name term { term } \")\"\nmodule_decl  ::= \"(\" \"module\" symbol \")\"\nimport_decl  ::= \"(\" \"import\" symbol \")\"\n              | \"(\" \"import\" symbol \"as\" symbol \")\"\nopen_decl    ::= \"(\" \"open\" symbol \")\"\nimport_classical ::= \"(\" \"import\" \"classical\" \")\"\n\ndefmacro     ::= \"(\" \"defmacro\" name \"(\" { symbol } \")\" syntax \")\"\n\nterm         ::= atom | list_term\natom         ::= symbol | int | hole\nlist_term    ::= \"(\" term_head { term | implicit_arg } \")\"\nimplicit_arg ::= \"{\" term \"}\"\n\nterm_head    ::= \"lam\" | \"pi\" | \"let\" | \"match\" | \"fix\" | \"eval\" | \"quote\" | \"sort\"\n              | \"ind\" | \"ctor\" | \"rec\" | term\n\nlam          ::= \"(\" \"lam\" [fn_kind] binder term term \")\"\npi           ::= \"(\" \"pi\" [fn_kind] (binder term term | binder_pair term) \")\"\nfn_kind      ::= \"fn\" | \"fnmut\" | \"fnonce\" | \"#[fn]\" | \"#[mut]\" | \"#[once]\"\n\nbinder       ::= symbol | hole | \"{\" symbol \"}\"\nbinder_pair  ::= \"(\" symbol term \")\" | \"{\" symbol term \"}\"\n</code></pre> <p>EXPERIMENTAL / SUGAR (May Change Without Edition Bump) - <code>match_list</code> special form. - <code>app</code> single-step application form. - <code>&amp;</code> and <code>&amp;mut</code> borrow sugar. - Indexing semantics beyond the current VecDyn/Slice/Array rewrite. - Future binder-group sugar and arrow sugar (proposed above).</p> <p>Stabilization Gates (Accepted)</p> <p>1) Canonical modifier authoring form - Policy: Canonical authoring uses <code>def</code> forms with modifiers in fixed positions; legacy spellings remain compatibility aliases with warnings. - Why: Canonical syntax is required for formatter/linter/style-guide convergence and avoids ecosystem fragmentation. - Gate to enforce canonical-only: Stdlib compiles cleanly under canonical form and an auto-formatter (or rewrite tool) is available.</p> <p>2) Dedicated <code>String</code> rollout - Policy: Keep string literals as <code>List Nat</code> for 0.1; introduce <code>String</code> later with migration sugar. - Why: Avoids premature runtime representation commitments while typed backend work is still stabilizing. - Planned migration: Introduce <code>String</code> as either inductive or primitive opaque with explicit operation contracts; update literal desugaring to <code>String</code>; keep compatibility mode (<code>--edition 0.1</code>) where literals remain <code>List Nat</code> as needed. - Gate to introduce <code>String</code>: Typed backend Stage 1 is stable and runtime representation contract is ready to freeze.</p> <p>3) Struct/record freeze - Policy: Keep struct/record syntax experimental for 0.1. - Why: Field semantics and derived-instance behavior are expensive to change once libraries depend on them. - Gate to freeze: Desugaring to inductive/projections is agreed and minimal derivation story (for example <code>Eq</code>, <code>Show</code>) is decided.</p> <p>4) <code>match_list</code> deprecation - Policy: Keep <code>match_list</code> as compatibility sugar/macro with warnings; do not keep as permanent core syntax. - Why: Avoids bootstrap breakage while moving toward a single generic <code>match</code> core. - Gate to remove: Generic <code>match</code> is stable, macro system can express list-pattern sugar, and stdlib no longer depends on <code>match_list</code>.</p> <p>5) Binder/arrow sugar freeze - Policy: Keep multi-binder and arrow syntax experimental until module/import/open and name resolution are frozen. - Why: Sugar stability depends on parser, qualification, and diagnostic behavior being stable first. - Gate to freeze: Module system contract is frozen and formatter can canonicalize sugar (or canonical desugaring) consistently.</p> <p>Implementation Checklist (Gate Tracking)</p> <p>1) Canonical modifier authoring form - Status: In progress. - Implemented now: compatibility warnings for top-level legacy <code>(opaque ...)</code> and <code>(transparent ...)</code> forms. - Remaining to close gate: rewrite stdlib to canonical <code>def</code> forms and ship formatter/rewrite support. - Code paths: <code>cli/src/driver.rs</code> (<code>emit_syntax_compat_warnings</code>). - Acceptance checks: <code>cli/tests/syntax_gate_acceptance.rs</code> (<code>legacy_modifier_spellings_emit_compatibility_warnings</code>, <code>canonical_def_modifiers_do_not_emit_compatibility_warnings</code>).</p> <p>2) Dedicated <code>String</code> rollout - Status: Planned. - Implemented now: string literals remain <code>List Nat</code> for 0.1. - Remaining to close gate: stabilize typed backend Stage 1, define runtime representation contract, introduce edition-gated migration behavior. - Code paths: <code>frontend/src/desugar.rs</code>, <code>frontend/src/declaration_parser.rs</code>. - Acceptance checks today: none (gate intentionally deferred).</p> <p>3) Struct/record freeze - Status: Planned/experimental. - Implemented now: no freeze; stays experimental sugar. - Remaining to close gate: finalize desugaring and minimal derivation policy. - Code paths: <code>frontend/src/declaration_parser.rs</code>, <code>frontend/src/desugar.rs</code>. - Acceptance checks today: none (gate intentionally deferred).</p> <p>4) <code>match_list</code> deprecation - Status: In progress. - Implemented now: deprecation warning emitted on <code>match_list</code> syntax. - Remaining to close gate: remove stdlib/internal dependency, ensure macro replacement is stable, then remove special-case core form. - Code paths: <code>cli/src/driver.rs</code> (<code>emit_match_list_warnings</code>). - Acceptance checks: <code>cli/tests/syntax_gate_acceptance.rs</code> (<code>match_list_emits_deprecation_warning</code>).</p> <p>5) Binder/arrow sugar freeze - Status: Planned/experimental. - Implemented now: still experimental, not frozen in 0.1 contract. - Remaining to close gate: freeze module/import/open contract and formatter canonicalization strategy. - Code paths: <code>frontend/src/desugar.rs</code>, <code>docs/spec/syntax_contract_0_1.md</code>. - Acceptance checks today: none (gate intentionally deferred).</p> <p>6) Module/import/open contract - Status: In progress with contract tests. - Implemented now: explicit <code>module</code>, aliased <code>import</code>, separate <code>open</code>, deterministic ambiguity diagnostics, strict qualified resolution rules. - Remaining to close gate: full stdlib migration and additional cross-module coverage as syntax expands. - Code paths: <code>cli/src/driver.rs</code>, <code>frontend/src/elaborator.rs</code>. - Acceptance checks: <code>cli/tests/module_resolution.rs</code>.</p> <p>7) Core parser/desugar syntax conformance - Status: In progress with executable contract checks. - Implemented now: conformance tests cover reader tokenization, quote token expansion, hole/index behavior, import/open declaration shapes, <code>app</code> arity, <code>match</code> minimum-case rule, and string/quote term desugaring. - Remaining to close gate: extend coverage to any newly documented forms as syntax evolves. - Code paths: <code>frontend/src/parser.rs</code>, <code>frontend/src/declaration_parser.rs</code>, <code>frontend/src/desugar.rs</code>. - Acceptance checks: <code>frontend/tests/syntax_contract_conformance.rs</code>.</p> <p>Edition Bump Required If Changed - Any change to the tokenization of symbols, integers, strings, or <code>_</code>. - Any change to list/braced/index/quote tokenization or precedence. - Any change to the surface spelling or arity of core declarations and term forms. - Any change to macro hygiene scope attachment or <code>quote</code>/<code>quasiquote</code> behavior.</p> <p>Known Discrepancies (Code vs. Expected Contract)</p> <p>None known after the 2026-02-06 conformance fixes.</p> <p>Missing Syntax Issues (GitHub-Issue-Ready, 5\u201315 items)</p> <p>1) Implement multi-binder sugar for <code>lam</code>/<code>pi</code> Justification: keeps stdlib readable and avoids later syntactic churn. Likely code locations: <code>frontend/src/desugar.rs</code>, <code>frontend/src/parser.rs</code> (if needed).</p> <p>2) Implement arrow sugar <code>(-&gt; A B ...)</code> Justification: standard in type signatures; freezes surface syntax early. Likely code locations: <code>frontend/src/desugar.rs</code>, <code>frontend/src/parser.rs</code> (if needed).</p> <p>3) Add struct/record surface sugar Justification: common data modeling; better to stabilize early if planned. Likely code locations: <code>frontend/src/declaration_parser.rs</code>, <code>frontend/src/desugar.rs</code>, <code>kernel</code> inductive generation.</p> <p>4) Move <code>match_list</code> into prelude sugar/macros and remove core special-case parser/desugar support Justification: currently hardcoded and unused; should be either promoted to core or moved to prelude macros. Likely code locations: <code>frontend/src/desugar.rs</code>, <code>stdlib/prelude_api.lrl</code>.</p> <p>5) Add explicit syntax for grouped def modifiers Justification: current mix of <code>(def opaque ...)</code> and <code>(opaque ...)</code> is easy to misuse. Likely code locations: <code>frontend/src/declaration_parser.rs</code>.</p> <p>6) Add module export controls (future) Justification: current module model exports all names by prefix; explicit export lists may be needed as stdlib scales. Likely code locations: <code>frontend/src/declaration_parser.rs</code>, <code>cli/src/driver.rs</code>, <code>kernel</code> env policy hooks.</p>"},{"location":"spec/codegen/erasure/","title":"Erasure","text":""},{"location":"spec/codegen/erasure/#prop-erasure","title":"Prop Erasure","text":"<p>Terms in <code>Prop</code> are erased. - <code>App(t, u)</code> where <code>u : Prop</code> -&gt; <code>t</code> (if <code>t</code> is a function). - <code>u : Prop</code> arguments are dropped from function signatures.</p>"},{"location":"spec/codegen/erasure/#type-erasure","title":"Type Erasure","text":"<p>Type parameters are erased in the dynamic backend, but monomorphized (specialized) in the typed backend. <code>PhantomData</code> fields are dropped.</p>"},{"location":"spec/codegen/ffi-abi/","title":"FFI and ABI","text":""},{"location":"spec/codegen/ffi-abi/#c-abi","title":"C ABI","text":"<p>LRL supports linking against C-compatible libraries. - <code>extern \"C\"</code> functions are invoked via <code>unsafe</code> wrappers. - Primitives must map to <code>LrlValue</code> (dynamic) or compatible Rust types (typed).</p>"},{"location":"spec/codegen/ffi-abi/#bindings","title":"Bindings","text":"<p>Bindings are currently manual. Future work includes <code>bindgen</code> integration.</p>"},{"location":"spec/codegen/lowering/","title":"Lowering","text":""},{"location":"spec/codegen/lowering/#mir-to-rust","title":"MIR to Rust","text":"<p>The typed backend lowers MIR to Rust AST/HIR. - <code>MirType::Adt</code> -&gt; <code>enum</code> or <code>struct</code>. - <code>MirType::Ref</code> -&gt; <code>LrlRefShared&lt;T&gt;</code> / <code>LrlRefMut&lt;T&gt;</code>. - <code>Statement::Assign</code> -&gt; Rust assignment.</p> <p>See Typed Backend for details.</p>"},{"location":"spec/codegen/runtime-repr/","title":"Runtime Representation","text":""},{"location":"spec/codegen/runtime-repr/#typed-backend","title":"Typed Backend","text":"<ul> <li><code>Nat</code>: <code>num_bigint::BigUint</code>.</li> <li><code>Bool</code>: <code>bool</code>.</li> <li><code>List</code>: <code>Vec&lt;T&gt;</code> (with wrapper).</li> <li><code>Ref</code>: Wrapper around raw pointer or <code>&amp;T</code>.</li> </ul>"},{"location":"spec/codegen/runtime-repr/#dynamic-backend","title":"Dynamic Backend","text":"<ul> <li><code>Value</code>: A universal enum (<code>Int</code>, <code>String</code>, <code>Cons</code>, <code>Closure</code>, <code>Foreign</code>).</li> </ul>"},{"location":"spec/codegen/typed-backend/","title":"Typed Backend Specification (Roadmap Phases 0-7)","text":"<p>This document defines the supported MIR -&gt; Rust typed backend surface and fallback behavior. The pipeline already enforces kernel/MIR typing/ownership/NLL; this document constrains what the typed backend accepts/emits and records roadmap phase coverage.</p>"},{"location":"spec/codegen/typed-backend/#goals","title":"Goals","text":"<ul> <li>Emit typed Rust (enums/structs/functions), not the universal <code>Value</code> runtime.</li> <li>Preserve pre-codegen semantics for the supported subset.</li> <li>Avoid \u201ctag-check panics\u201d for supported programs.</li> <li>Deterministic output and stable naming.</li> <li>Support typed higher-order calls in the current subset.</li> </ul>"},{"location":"spec/codegen/typed-backend/#roadmap-coverage-status","title":"Roadmap Coverage Status","text":"<ul> <li>Phase -1: complete. Dynamic and typed backends both consume validated MIR in one pipeline.</li> <li>Phase 0: complete. <code>--backend typed|dynamic|auto</code> is implemented; <code>auto</code> falls back with explicit diagnostics.</li> <li>Phase 1: complete. Non-parameterized ADTs, constructors, matches, and projections emit as typed Rust.</li> <li>Phase 2: complete. Typed calls, lifted closures/fixpoints, and higher-order function paths are supported.</li> <li>Phase 3: complete. Parametric ADTs/functions, refs, raw pointers, interior mutability, index/runtime-check lowering are supported in typed codegen.</li> <li>Phase 4: complete. Proof terms are erased before codegen; Prop ADTs are runtime-erased in typed output.</li> <li>Phase 5: complete. Indexed/dependent lowering paths are implemented for the documented indexable/container shapes.</li> <li>Phase 6: complete. Typed prelude provides the effect/capability surface (<code>Comp</code>, <code>EvalCap</code>, <code>eval</code>) used by typed backend tests.</li> <li>Phase 7 (optional): complete. <code>compile</code> and <code>compile-mir</code> default to <code>--backend auto</code> (typed-first, dynamic fallback).</li> <li>Conformance coverage is documented in <code>/Volumes/Crucial X6/MacBook/Code/leanrustlisp/docs/dev/backend_conformance_subset.md</code> and <code>/Volumes/Crucial X6/MacBook/Code/leanrustlisp/docs/dev/backend_conformance_report.md</code>.</li> </ul>"},{"location":"spec/codegen/typed-backend/#current-supported-subset","title":"Current Supported Subset","text":""},{"location":"spec/codegen/typed-backend/#types","title":"Types","text":"<ul> <li><code>Unit</code>, <code>Bool</code>, <code>Nat</code></li> <li>ADTs (<code>MirType::Adt</code>) including parameterized forms (<code>Adt&lt;T...&gt;</code>)</li> <li>Field types must themselves be supported by this backend.</li> <li>Direct self-recursion is allowed via <code>Box&lt;...&gt;</code> in Rust; mutual recursion is not supported yet.</li> <li>Prop inductives are runtime-erased:</li> <li>any <code>MirType::Adt</code> whose inductive result sort is <code>Prop</code> lowers to <code>()</code>,</li> <li>typed backend does not emit Rust enum definitions for these proof-only ADTs,</li> <li>proof constructors lower to curried callables returning <code>()</code>.</li> <li>Type parameters (<code>MirType::Param</code>) lowered to deterministic Rust generic names (<code>T0</code>, <code>T1</code>, ...).</li> <li>References (<code>MirType::Ref</code>) lowered via typed wrappers:</li> <li><code>LrlRefShared&lt;T&gt;</code></li> <li><code>LrlRefMut&lt;T&gt;</code></li> <li>Raw pointers (<code>MirType::RawPtr</code>) lowered to <code>*const T</code> / <code>*mut T</code>.</li> <li>Interior mutability wrappers (<code>MirType::InteriorMutable</code>) lowered to:</li> <li><code>LrlRefCell&lt;T&gt;</code></li> <li><code>LrlMutex&lt;T&gt;</code></li> <li><code>LrlAtomic&lt;T&gt;</code></li> <li>Index terms (<code>MirType::IndexTerm</code>) are accepted for typed codegen identity paths.</li> <li>Opaque MIR types (<code>MirType::Opaque</code>) are lowered to a typed placeholder wrapper (<code>LrlOpaque</code>).</li> <li>Functions of kind <code>Fn</code> and <code>FnOnce</code>:</li> <li>Represented as <code>Rc&lt;dyn LrlCallable&lt;Arg, Ret&gt;&gt;</code> (curried, unary MIR functions).</li> </ul>"},{"location":"spec/codegen/typed-backend/#mir-constructs","title":"MIR Constructs","text":"<ul> <li>Locals/temps with supported types.</li> <li><code>Rvalue::Use</code>, <code>Rvalue::Discriminant</code>, <code>Rvalue::Ref</code>.</li> <li><code>Statement::Assign</code>, <code>RuntimeCheck</code>, <code>StorageLive/Dead</code>, <code>Nop</code>.</li> <li><code>Terminator::Return</code>, <code>Goto</code>, <code>SwitchInt</code>, <code>Call</code>, <code>Unreachable</code>.</li> <li>Constructors as values (curried) for supported ADTs and builtins (<code>Nat</code>, <code>Bool</code>).</li> <li>Recursors (<code>Term::Rec</code>) with typed specialization entries.</li> </ul>"},{"location":"spec/codegen/typed-backend/#control-flow","title":"Control Flow","text":"<ul> <li>Straight-line code and <code>SwitchInt</code> on discriminants (ADT/Bool/Nat).</li> <li>Place projections include <code>Field</code>, <code>Downcast</code>, <code>Deref</code>, and <code>Index</code> lowering.</li> <li>Executable typed indexing is supported for:</li> <li>builtin <code>List&lt;T&gt;</code> traversal,</li> <li>indexable ADTs with direct payload access (<code>index == 0</code>) even when payload is not the first field,</li> <li>indexable ADTs whose payload field is another indexable/list container (delegates with <code>runtime_index</code>),</li> <li>multi-variant indexable ADTs when at least one variant provides an index source field,</li> <li>source-less indexable ADT shapes (compile successfully, with an explicit runtime panic path for index access).</li> </ul>"},{"location":"spec/codegen/typed-backend/#functions-closures","title":"Functions &amp; Closures","text":"<ul> <li>Higher-order typed calls are supported in the current subset:</li> <li>function values can be passed, returned, selected by <code>match</code>, and called.</li> <li>calls are emitted as typed trait-object calls (<code>.call(...)</code>), with no dynamic function tag checks.</li> <li>Closure conversion strategy in this backend:</li> <li>closure bodies are lifted to generated Rust functions,</li> <li>lifted closures and fixpoints are materialized as generated adapter structs (<code>LrlClosureAdapter</code>, <code>LrlFixAdapter</code>) implementing <code>LrlCallable</code>,</li> <li>captured values are stored in adapter struct fields (tuple-packed per closure literal).</li> <li><code>FnMut</code> function-kind values are supported in typed backend call/lowering paths.</li> <li>Polymorphic function-value wrappers are supported through typed closure/fix adapters.</li> </ul>"},{"location":"spec/codegen/typed-backend/#backend-selection-behavior","title":"Backend Selection Behavior","text":"<ul> <li><code>--backend typed</code>: hard error on unsupported constructs with a clear diagnostic.</li> <li><code>--backend typed</code> + axioms:</li> <li>default: reject axiom stubs,</li> <li>with <code>--allow-axioms</code>: emit typed panic stubs and loud warnings.</li> <li><code>--backend dynamic</code>: use dynamic backend.</li> <li><code>--backend dynamic</code> + axioms:</li> <li>default: reject executable axiom stubs,</li> <li>with <code>--allow-axioms</code>: emit dynamic panic stubs and loud warnings.</li> <li><code>--backend auto</code>:</li> <li>no axiom stubs: try typed; on unsupported constructs, fall back to dynamic with a warning.</li> <li>axiom stubs + no <code>--allow-axioms</code>: reject with an explicit opt-in diagnostic.</li> <li>axiom stubs + <code>--allow-axioms</code>: prefer typed panic stubs; if typed is unsupported for other reasons, fall back to dynamic with warning.</li> <li>CLI defaults for <code>compile</code> and <code>compile-mir</code> use <code>--backend auto</code>.</li> </ul>"},{"location":"spec/codegen/typed-backend/#axioms-and-stub-safety","title":"Axioms and Stub Safety","text":"<ul> <li>Axiom: a declaration without a body (<code>def.value = None</code>) that cannot be executed directly.</li> <li>Axiom stub: generated Rust function used when an executable pipeline needs a runtime placeholder for an axiom.</li> <li>Typed stubs are emitted as typed panic stubs (return type inferred by call site), for example:</li> <li><code>fn some_axiom&lt;T&gt;() -&gt; T { panic!(...) }</code></li> <li>Dynamic stubs are emitted as <code>Value</code>-returning panic stubs.</li> </ul> <p>Safety contract: - Axioms are non-executable by default. - Executable stubs require explicit <code>--allow-axioms</code> opt-in. - When enabled, codegen emits loud warnings and writes artifact metadata (<code>build/output_&lt;pid&gt;_&lt;nanos&gt;.artifacts.json</code>) indicating executable axioms are present. - If a runtime path reaches an axiom stub, execution will panic by design.</p>"},{"location":"spec/codegen/typed-backend/#typed-unsupported-reason-codes","title":"Typed Unsupported Reason Codes","text":"<p>Typed-backend unsupported diagnostics use stable reason codes so fallback behavior can be tested and triaged deterministically.</p> <ul> <li><code>TB001</code>: reserved legacy code (<code>FnMut</code> support gap; no longer emitted in current phase).</li> <li><code>TB002</code>: Non-unary function shape encountered (typed backend currently supports unary-curried callables).</li> <li><code>TB003</code>: Unsupported call operand form.</li> <li><code>TB004</code>: Assignment to projected place is not supported.</li> <li><code>TB005</code>: Unsupported place projection shape (malformed/non-lowerable projection path).</li> <li><code>TB006</code>: Unsupported closure-environment projection shape.</li> <li><code>TB007</code>: Unsupported closure type lowering.</li> <li><code>TB008</code>: Unsupported fixpoint type lowering.</li> <li><code>TB009</code>: reserved legacy code (polymorphic function-value support gap; no longer emitted in current phase).</li> <li><code>TB900</code>: Internal typed-codegen invariant failure.</li> </ul>"},{"location":"spec/codegen/typed-backend/#guard-closure-status","title":"Guard-Closure Status","text":"<ul> <li><code>TB001</code>: kept as a reserved stable code; former <code>FnMut</code> shape is supported and covered by direct typed-codegen tests.</li> <li><code>TB002</code>: malformed/non-lowerable MIR guard (non-unary function shape); covered by direct typed-codegen tests.</li> <li><code>TB003</code>: malformed/non-lowerable MIR guard (invalid call operand); covered by direct typed-codegen tests.</li> <li><code>TB004</code>: malformed/non-lowerable MIR guard (assignment to projected place); covered by direct typed-codegen tests.</li> <li><code>TB005</code>: malformed/non-lowerable MIR guard (unsupported place projection path); covered by direct typed-codegen tests.</li> <li><code>TB006</code>: malformed/non-lowerable MIR guard (invalid closure env projection); covered by direct typed-codegen tests.</li> <li><code>TB007</code>: malformed/non-lowerable MIR guard (closure literal/type mismatch); covered by direct typed-codegen tests.</li> <li><code>TB008</code>: malformed/non-lowerable MIR guard (fixpoint literal/type mismatch); covered by direct typed-codegen tests.</li> <li><code>TB009</code>: kept as a reserved stable code; former polymorphic function-value scenarios are supported in typed backend and covered by typed backend integration tests.</li> <li><code>TB900</code>: internal invariant guard; indicates a backend bug or malformed MIR outside supported invariants.</li> </ul>"},{"location":"spec/codegen/typed-backend/#no-tag-check-panics","title":"No Tag-Check Panics","text":"<p>For supported programs, emitted Rust must not include tag-check panics (e.g. \u201cExpected Func\u201d, \u201cwrong tag\u201d). Any remaining panic must be an intentional runtime check/helper path.</p>"},{"location":"spec/codegen/typed-backend/#determinism","title":"Determinism","text":"<ul> <li>Stable ordering of items (defs, ADTs, ctors).</li> <li>Stable symbol naming (sanitized names for Rust identifiers).</li> </ul>"},{"location":"spec/codegen/validation/","title":"Validation","text":""},{"location":"spec/codegen/validation/#output-validation","title":"Output Validation","text":"<p>Generated Rust code is compiled by <code>rustc</code>. - Borrow checker errors in generated code indicate bugs in LRL's MIR borrow checker. - Valid LRL programs should produce valid Rust code (no panics, no UB).</p>"},{"location":"spec/core/definitional-equality/","title":"Definitional Equality","text":""},{"location":"spec/core/definitional-equality/#reductions","title":"Reductions","text":"<p>The relation <code>t \u2261 u</code> is defined by normalizing both <code>t</code> and <code>u</code> to a common form.</p>"},{"location":"spec/core/definitional-equality/#beta","title":"Beta (\u03b2)","text":"<p><code>(\\x. b) a</code> reduces to <code>b[x/a]</code>.</p>"},{"location":"spec/core/definitional-equality/#delta","title":"Delta (\u03b4)","text":"<p>Constants are unfolded if transparency permits. <code>def x := v</code>. <code>x</code> reduces to <code>v</code>.</p>"},{"location":"spec/core/definitional-equality/#iota","title":"Iota (\u03b9)","text":"<p>Recursor on constructor. <code>Rec(Ctor(i, args))</code> reduces to the <code>i</code>-th minor premise applied to <code>args</code>.</p>"},{"location":"spec/core/definitional-equality/#zeta","title":"Zeta (\u03b6)","text":"<p><code>let x := v in b</code> reduces to <code>b[x/v]</code>.</p>"},{"location":"spec/core/definitional-equality/#eta","title":"Eta (\u03b7)","text":"<p><code>(\\x. f x)</code> reduces to <code>f</code>.</p>"},{"location":"spec/core/definitional-equality/#algorithmic-equality","title":"Algorithmic Equality","text":"<p>The implementation uses NbE (Normalization by Evaluation) with a fuel limit. 1. Evaluate terms to Weak Head Normal Form (WHNF). 2. If heads are different (and stubborn), they are not equal. 3. If heads are equal, recurse on arguments.</p>"},{"location":"spec/core/inductives/","title":"Inductive Types","text":""},{"location":"spec/core/inductives/#well-formedness","title":"Well-Formedness","text":"<p>An inductive definition <code>Ind</code> with constructors <code>C_1 ... C_n</code> is well-formed if: 1. The type of <code>Ind</code> is <code>Type u</code> or <code>Prop</code>. 2. Each constructor <code>C_i</code> returns <code>Ind</code>. 3. Inductive parameters are uniform. 4. Recursive occurrences of <code>Ind</code> in constructor arguments are Strictly Positive.</p>"},{"location":"spec/core/inductives/#strict-positivity","title":"Strict Positivity","text":"<p><code>Ind</code> occurs strictly positive in <code>T</code> if: - <code>T</code> is <code>Ind ...</code>. - <code>T</code> is <code>A -&gt; B</code> and <code>Ind</code> does not occur in <code>A</code>, and occurs strictly positive in <code>B</code>.</p> <p>It must NOT occur in the domain of an arrow (negative occurrence).</p>"},{"location":"spec/core/inductives/#elimination-rec","title":"Elimination (Rec)","text":"<p>For <code>Ind</code> with constructors <code>C_1 : A_1 -&gt; Ind ...</code>, the recursor <code>Ind.rec</code> has type: <code>Pi (motive : Ind -&gt; Sort u) ... (minor_1 : Pi args, motive (C_1 args)) ... -&gt; Pi (x : Ind), motive x</code></p>"},{"location":"spec/core/substitution/","title":"Substitution and De Bruijn Indices","text":""},{"location":"spec/core/substitution/#representation","title":"Representation","text":"<p>LRL uses de Bruijn indices for bound variables. - <code>Var(0)</code> is the innermost binder. - <code>Var(1)</code> is the next binder out.</p>"},{"location":"spec/core/substitution/#operations","title":"Operations","text":""},{"location":"spec/core/substitution/#lifting-shifting","title":"Lifting (Shifting)","text":"<p>When a term moves under a new binder (e.g. going inside a Lambda), free variables must be \"shifted\" (incremented). <code>shift(term, cutoff, amount)</code></p>"},{"location":"spec/core/substitution/#substitution","title":"Substitution","text":"<p><code>subst(term, index, replacement)</code> Replaces <code>Var(index)</code> with <code>replacement</code>. Variables &gt; <code>index</code> are decremented. <code>replacement</code> must be shifted when entering scopes.</p>"},{"location":"spec/core/substitution/#correctness","title":"Correctness","text":"<p>The kernel implementation must strictly follow these rules to avoid capturing variables (although NBE uses closures which handles this differently, the AST operations must be correct for printing/manipulation).</p>"},{"location":"spec/effects/capabilities/","title":"Capabilities","text":"<p>Access to system resources is controlled via Capabilities (tokens witness permission). - <code>IO</code> grants world capability. - <code>ST</code> grants state token.</p> <p>This linear resource tracking ensures single-threaded or synchronized access where required.</p>"},{"location":"spec/effects/effect-system/","title":"Effect System","text":"<p>LRL plans to use an Algebraic Effect System (or Monadic representation in the interim).</p>"},{"location":"spec/effects/effect-system/#goal","title":"Goal","text":"<p>Track side effects (IO, State, Exceptions) in the type system. <code>f : A -&gt; {E} B</code></p>"},{"location":"spec/effects/effect-system/#current-status","title":"Current Status","text":"<p>Currently emulated via the <code>IO</code> monad opaque type.</p>"},{"location":"spec/effects/total-vs-partial/","title":"Total vs Partial","text":""},{"location":"spec/effects/total-vs-partial/#totality","title":"Totality","text":"<p>Terms in <code>Type</code> arguments must be total to ensure type checking terminates. The kernel enforces termination (structural/well-founded).</p>"},{"location":"spec/effects/total-vs-partial/#partial","title":"Partial","text":"<p>Functions marked <code>partial</code> can loop. They return a computation type (e.g. <code>Comp A</code> or <code>IO A</code>) and cannot be unfolded by Refinement types or DefEq.</p>"},{"location":"spec/macros/determinism/","title":"Determinism","text":"<p>Macro expansion must be pure and deterministic. - No IO allowed in macros. - No access to global mutable state (unless thread-local to expansion session). - <code>gensym</code>s must be deterministic based on seed/position.</p>"},{"location":"spec/macros/expansion/","title":"Expansion Algorithm","text":"<ol> <li>Parse file to <code>Syntax</code>.</li> <li>Traverse top-down.</li> <li>If list head <code>(foo ...)</code> is a macro binding <code>foo</code>:    a. Invoke <code>foo</code> with arguments.    b. Replace node with result.    c. Comparison mark logic (hygiene) applied to result.    d. Continue expansion on the result (until fixpoint/atom).</li> <li>If not macro, descend into children.</li> </ol>"},{"location":"spec/macros/hygiene/","title":"Hygiene","text":"<p>LRL uses a \"sets of scopes\" hygiene algorithm.</p>"},{"location":"spec/macros/hygiene/#scopes","title":"Scopes","text":"<p>When a macro expands, a new <code>ScopeId</code> is generated. - Identifiers introduced by the macro receive this scope. - Identifiers passed to the macro do not receive this scope. - Resolution looks for identifiers that have a subset of the use-site scopes.</p>"},{"location":"spec/macros/hygiene/#breaking-hygiene","title":"Breaking Hygiene","text":"<p><code>datum-&gt;syntax</code> allows stripping or adding scopes manually to intentionally capture variables.</p>"},{"location":"spec/macros/staging/","title":"Staging","text":"<p>Macros run in a separate stage before type checking.</p>"},{"location":"spec/macros/staging/#invocation","title":"Invocation","text":"<p>Macros are expanded by the <code>Frontend</code>. The expander runs a VM/interpreter that evaluates the macro function. Dependencies for macros must be compiled and available in the \"macro stage\" (or host).</p>"},{"location":"spec/macros/syntax-objects/","title":"Syntax Objects","text":"<p>Macros operate on <code>Syntax</code> objects, not raw S-expressions.</p>"},{"location":"spec/macros/syntax-objects/#structure","title":"Structure","text":"<pre><code>struct Syntax {\n    kind: SyntaxKind,\n    span: Span,\n    scopes: Vec&lt;ScopeId&gt;, // Hygiene info\n}\n</code></pre>"},{"location":"spec/macros/syntax-objects/#kinds","title":"kinds","text":"<ul> <li><code>Symbol(String)</code></li> <li><code>List(Vec&lt;Syntax&gt;)</code></li> <li><code>Int(usize)</code></li> <li><code>String(String)</code></li> </ul>"},{"location":"spec/mir/","title":"MIR Specification (Structure + Places)","text":"<p>This document defines the structural shape of MIR (Mid-level IR) in LRL, with emphasis on places/projections and where region information lives.</p>"},{"location":"spec/mir/#overview","title":"Overview","text":"<p>MIR is a typed, CFG-based IR used for ownership, borrow checking (NLL), and typed backend readiness. It is the single pipeline IR for both batch compile and REPL evaluation.</p>"},{"location":"spec/mir/#core-structure","title":"Core Structure","text":"<p>A MIR body contains: - Locals: typed slots (<code>MirType</code>) for arguments, temporaries, and return. - Basic blocks: a sequence of statements plus a terminator. - CFG: explicit control-flow edges through terminators.</p> <p>Key nodes: - <code>Statement::Assign(Place, Rvalue)</code> - <code>Statement::StorageLive/StorageDead(Local)</code> - <code>Terminator::{Return, Goto, SwitchInt, Call, Unreachable}</code></p>"},{"location":"spec/mir/#places-and-projections","title":"Places and Projections","text":"<p>A Place represents a memory location: <pre><code>Place = LocalId + Projection*\n</code></pre></p> <p>Projections include: - <code>Deref</code> (indirection through references or raw pointers) - <code>Field(i)</code> (field projection for struct/ctor fields) - <code>Downcast(variant_index)</code> (enum/ADT variant projection) - <code>Index(local)</code> (optional; for indexed containers)</p> <p>Place typing must be projection-aware, using ADT layout metadata so that borrow checking and codegen can reason about field-level aliasing.</p>"},{"location":"spec/mir/#regions-in-mir","title":"Regions in MIR","text":"<p>Regions are not standalone MIR nodes; they are carried by <code>MirType::Ref</code>. Borrow creation is explicit (<code>Rvalue::Ref</code>) and assigns a fresh inference region to the new reference at the borrow site (origin location).</p> <ul> <li><code>Region::Static</code> is reserved for globals / truly static references.</li> <li>NLL solves region constraints over CFG points.</li> </ul>"},{"location":"spec/mir/#semantic-identity-rule","title":"Semantic Identity Rule","text":"<p>All semantic identity in MIR is keyed by nominal IDs (DefId/AdtId/CtorId/FieldId), not by raw strings. Borrow checking and codegen must not depend on names.</p>"},{"location":"spec/mir/borrows-regions/","title":"Ownership, Borrows, and Regions in LRL","text":""},{"location":"spec/mir/borrows-regions/#ownership","title":"Ownership","text":"<p>LRL adopts Rust's ownership model: -   Linear/Affine: Non-copy types must be used exactly once (or moved). -   Copy: Determined by kernel Copy instances; primitive types (Nat, Bool), shared references, and raw pointers are Copy. Function values are non-Copy. -   Move Semantics: Assigning a non-copy value moves ownership, invalidating the source.</p> <p>The <code>OwnershipAnalysis</code> pass verifies these properties: -   Use-after-move detection. -   Double-move detection. -   Linear type consumption (must not be dropped implicitly).</p>"},{"location":"spec/mir/borrows-regions/#borrows","title":"Borrows","text":"<p>Borrows create references to existing data. -   Shared Borrow (<code>&amp;T</code>): Allows multiple readers, no writers. <code>Copy</code>. -   Mutable Borrow (<code>&amp;mut T</code>): Allows single writer, no readers. <code>Not Copy</code>.</p> <p>Borrow creation in MIR must be explicit and assigns a fresh inference region to the new reference, with an origin location (the borrow statement).</p>"},{"location":"spec/mir/borrows-regions/#regions","title":"Regions","text":"<p>Regions (<code>'r</code>) denote the lifetime of a reference. In MIR, regions are explicit: <pre><code>Ref(Region(id), T, Mutability)\n</code></pre></p>"},{"location":"spec/mir/borrows-regions/#static-region","title":"Static Region","text":"<p><code>Region(0)</code> is reserved for <code>STATIC</code> (global constants).</p>"},{"location":"spec/mir/borrows-regions/#region-variables-and-origins","title":"Region Variables and Origins","text":"<ul> <li>Each borrow site creates a fresh region variable (e.g. <code>'?r1</code>), tagged with its   origin <code>Location</code> (block + statement index).</li> <li>NLL solves region constraints over CFG points; region \u201cvalues\u201d are sets of CFG   points inferred by the solver.</li> </ul>"},{"location":"spec/mir/borrows-regions/#region-inference","title":"Region Inference","text":"<p>LRL uses Non-Lexical Lifetimes (NLL). Regions are not tied to blocks but to the control-flow points where the data is actually used. -   Constraints are generated from data flow. -   If a reference is used at point P, its region must be live at P.</p>"},{"location":"spec/mir/borrows-regions/#call-site-region-constraints","title":"Call-Site Region Constraints","text":"<p>Function calls relate caller and callee regions: - Argument types are related to parameter types. - The destination type is related to the callee return type.</p> <p>Lowering assigns region parameters based on explicit <code>Ref</code> labels (surface <code>Ref #[label] Shared T</code> / <code>Ref #[label] Mut T</code>) or positional occurrence within the signature. Reusing the same label ties lifetimes together; unlabeled return references use the single-input elision rule (and otherwise must be labeled explicitly). This lets NLL constrain returned references by the intended input regions and prevents reference escape across call boundaries.</p> <p>Elision policy: An elided <code>Ref</code> label is treated as a fresh implicit label variable during elaboration. If a context expects an explicit label, the elided label may unify to that explicit label; explicit-to-explicit mismatches remain errors. After elaboration, labels are concrete strings and definitional equality compares labels strictly. See <code>docs/spec/ownership_model.md</code> \u00a73.1 for the core term representation and examples.</p>"},{"location":"spec/mir/borrows-regions/#closure-capture-extraction","title":"Closure Capture Extraction","text":"<p>When lowering closures, captures are extracted from the environment using: - <code>Move</code> for non-<code>Copy</code> captures. - <code>Copy</code> only when the capture is <code>Copy</code>.</p> <p>This prevents duplication of linear or affine values (including <code>&amp;mut</code>).</p>"},{"location":"spec/mir/borrows-regions/#interior-mutability-classification","title":"Interior Mutability (Classification)","text":"<p>Interior mutability is recognized via marker traits/attributes resolved by the elaborator into DefId-based metadata (no string matching). The standard marker definitions live in the prelude. This metadata drives: - runtime check insertion for RefCell/Mutex types, - the panic-free profile lint (rejects any interior mutability). The elaborator rejects <code>interior_mutable</code> without a kind marker and rejects conflicting kind markers (e.g., <code>may_panic_on_borrow_violation</code> with <code>concurrency_primitive</code>).</p> <p>Panic-free profile restrictions: Any interior mutability (RefCell/Mutex/Atomic) is rejected, indexing is rejected (bounds checks may panic), and <code>borrow_shared</code>/<code>borrow_mut</code> are rejected.</p>"},{"location":"spec/mir/borrows-regions/#runtime-layout-and-indices-policy","title":"Runtime Layout and Indices (Policy)","text":"<p>Dependent indices do not affect runtime layout. <code>MirType::Adt(AdtId, type_args)</code> defines the runtime identity; indices are erased or kept only as compile-time metadata. If a library needs a runtime index, it must be an explicit field.</p>"},{"location":"spec/mir/borrows-regions/#safety-guarantees","title":"Safety Guarantees","text":"<p>The combination of Ownership and NLL guarantees: 1.  No Dangling Pointers: Data cannot be dropped while a reference to it is live.     -   Enforced by checking <code>StorageDead</code> against active loans. 2.  No Data Races: Mutable borrows exclude all other access.     -   Enforced by conflict detection. 3.  No Use-After-Free: Ownership mechanics ensure moved values aren't accessed.</p>"},{"location":"spec/mir/borrows-regions/#codegen-contract","title":"Codegen Contract","text":"<p>The backend can assume: -   If a <code>Ref</code> exists, it points to valid memory. -   If <code>&amp;mut T</code> exists, it is unique. -   No need for runtime borrow flags for normal references.  -   No semantic decisions are made from raw strings; all identities are via IDs.</p>"},{"location":"spec/mir/nll-constraints/","title":"Non-Lexical Lifetimes (NLL) and Constraints in LRL MIR","text":""},{"location":"spec/mir/nll-constraints/#overview","title":"Overview","text":"<p>LRL employs a Non-Lexical Lifetime (NLL) system similar to Rust's to ensure memory safety without strict lexical scopes. This system operates on the Control Flow Graph (CFG) of the Mid-level Intermediate Representation (MIR).</p>"},{"location":"spec/mir/nll-constraints/#regions","title":"Regions","text":"<p>Every reference type in MIR is annotated with a Region variable: <pre><code>Ref(Region, Box&lt;MirType&gt;, Mutability)\n</code></pre> Regions represent the set of points in the CFG where the reference is valid (live).</p> <p>LRL uses a Rust-like region model: - <code>Region::Static</code> for globals / truly static references. - Fresh inference regions created at each borrow site, each with an origin   <code>Location</code> (block + statement index) for diagnostics.</p>"},{"location":"spec/mir/nll-constraints/#liveness-analysis","title":"Liveness Analysis","text":"<p>The NLL checker performs Precise Liveness Analysis: 1.  Backward Analysis: Starting from the end of each basic block, it computes the set of live variables before each statement. 2.  Statement Granularity: Unlike standard block-level analysis, LRL stores liveness sets for every <code>Location</code> (block + statement index). 3.  Region Liveness: A region <code>'r</code> is considered live at location <code>L</code> if any variable <code>v</code> whose type contains <code>'r</code> is live at <code>L</code>.</p>"},{"location":"spec/mir/nll-constraints/#constraint-generation","title":"Constraint Generation","text":"<p>The checker iterates forward through the MIR body to generate constraints based on assignments (subtyping):</p>"},{"location":"spec/mir/nll-constraints/#1-subtyping-dest-src","title":"1. Subtyping (<code>dest = src</code>)","text":"<p>If <code>dest</code> has type <code>&amp;'a T</code> and <code>src</code> has type <code>&amp;'b T</code>, the assignment implies that the value from <code>src</code> (valid for <code>'b</code>) flows into <code>dest</code> (valid for <code>'a</code>). Therefore, <code>'b</code> must outlive <code>'a</code>: <pre><code>'b : 'a  (b &gt;= a)\n</code></pre> This constraint is added to the <code>RegionInferenceContext</code>.</p>"},{"location":"spec/mir/nll-constraints/#2-loan-creation-dest-place","title":"2. Loan Creation (<code>dest = &amp;place</code>)","text":"<p>When a reference is created via <code>Rvalue::Ref(kind, place)</code>: 1.  A Loan is recorded:     <pre><code>Loan {\n    place: place,\n    region: region_of_dest,\n    kind: kind,\n    issued_at: current_location\n}\n</code></pre> 2.  The borrow site assigns a fresh inference region to the new reference. 3.  The region is constrained to be live wherever the reference is used (via liveness analysis).</p>"},{"location":"spec/mir/nll-constraints/#3-call-site-constraints-call","title":"3. Call-Site Constraints (<code>Call</code>)","text":"<p>For a call with callee type <code>fn&lt;'r0, ...&gt;(args...) -&gt; ret</code>, NLL first instantiates the callee\u2019s region parameters with fresh inference regions for the call site. Constraints are generated using the instantiated types so unrelated calls do not share region variables.</p> <p>NLL then relates caller and callee regions:</p> <ul> <li>Arguments: treat each parameter as a destination and each argument as the source.   If <code>param</code> has type <code>&amp;'p T</code> and <code>arg</code> has type <code>&amp;'a T</code>, add <code>'a : 'p</code>.</li> <li>Return: treat the call destination as the destination and the callee return type as the source.   If <code>dest</code> has type <code>&amp;'d T</code> and <code>ret</code> has type <code>&amp;'r T</code>, add <code>'r : 'd</code>.</li> </ul> <p>This ensures returned references cannot outlive the inputs they are derived from, preventing borrow-lifetime laundering across function boundaries.</p>"},{"location":"spec/mir/nll-constraints/#4-closure-captures","title":"4. Closure Captures","text":"<p>Closure locals carry a list of capture types (e.g., <code>Ref Shared T</code> or <code>Ref Mut T</code>) derived from per-capture modes during lowering. NLL treats these capture types as active borrows for as long as the closure value is live, preserving the same aliasing rules as direct borrows.</p>"},{"location":"spec/mir/nll-constraints/#constraint-solving","title":"Constraint Solving","text":"<p>The solver computes the transitive closure of the <code>outlives</code> constraints. Algorithm: 1.  Initialize <code>region_values['r]</code> with the set of locations where <code>'r</code> is required to be live (from liveness analysis). 2.  Iterate to fixpoint:     - If <code>'b : 'a</code> (b outlives a), add all locations from <code>region_values['a]</code> into <code>region_values['b]</code>.     - This ensures that if <code>'a</code> is live at <code>L</code>, and <code>'b</code> must outlive <code>'a</code>, then <code>'b</code> is also live at <code>L</code>.</p>"},{"location":"spec/mir/nll-constraints/#conflict-detection-borrow-checking","title":"Conflict Detection (Borrow Checking)","text":"<p>After solving, the checker verifies that no active loan is violated by conflicting accesses.</p> <p>For every statement at <code>Location L</code>: 1.  Identify Active Loans: A loan <code>L</code> is active if its region is live at <code>L</code> (<code>region_values[loan.region].contains(L)</code>). 2.  Identify Accesses:     - <code>Assign(dest, ...)</code> -&gt; Writes to <code>dest</code>.     - <code>Use(op)</code> -&gt; Reads from <code>op</code>. 3.  Check for Conflicts:     - Mutation of a place conflicts with any active loan of that place (Shared or Mut).     - Reading a place conflicts with an active Mutable loan of that place.</p>"},{"location":"spec/mir/nll-constraints/#interior-mutability","title":"Interior Mutability","text":"<p>Types wrapped in <code>InteriorMutable</code> (like <code>RefCell</code>) bypass static borrow checking for the inner content but are subject to: -   Panic-Free Lints: Driven by DefId-based marker metadata (interior mutability markers);     panic-free mode rejects any interior mutability. -   Runtime Checks: Codegen inserts runtime guards based on the same metadata.</p> <p>The NLL checker ensures the <code>InteriorMutable</code> container itself is borrowed safely, but does not track borrows inside it statically.</p> <p>Panic-free lints also reject indexing and borrow axiom usage. Indexing is detected via <code>RuntimeCheckKind::BoundsCheck</code> or an indexed place projection so the lint remains effective if lowering patterns change. Borrow axioms are detected via <code>Rvalue::Ref</code>.</p>"},{"location":"spec/mir/nll-constraints/#sanity-rule-id-only-semantics","title":"Sanity Rule (ID-Only Semantics)","text":"<p>Borrow checking, MIR typing, and codegen must never depend on raw strings for semantic identity. All semantics are keyed by DefId/AdtId/CtorId/FieldId (including PackageId).</p>"},{"location":"spec/mir/typing/","title":"MIR Typing and Nominal IDs","text":"<p>This document defines the MIR type language (<code>MirType</code>), nominal IDs, and runtime-vs-erased policy for indices and proofs.</p>"},{"location":"spec/mir/typing/#nominal-id-scheme-deterministic","title":"Nominal ID Scheme (Deterministic)","text":"<p>All semantic identity is keyed by deterministic nominal IDs derived from: - <code>PackageId</code> (from lrl.lock: name + version + source + hash) - <code>ModulePath</code> (e.g., std::list) - <code>ItemName</code> (e.g., List) - <code>Disambiguator</code> (only if needed; e.g., gensyms or same-name items)</p> <p>IDs are hashed to a 64-bit or 128-bit value (or interned as structured keys). A single registry mints these IDs during declaration loading/elaboration: - deterministic module load order - no HashMap iteration dependence - no ID minting inside MIR passes</p> <p>ID definitions: - DefId: any top-level definition (functions, constants, axioms) - AdtId: inductive type definition - CtorId: (AdtId, ctor_index) (index is preferred once ctor order is fixed) - FieldId: (CtorId, field_index) (or field name if fields are named)</p>"},{"location":"spec/mir/typing/#mirtype-runtime-type-language","title":"MirType (Runtime Type Language)","text":"<p><code>MirType</code> describes runtime types used by borrow checking and codegen: - <code>Unit</code>, <code>Bool</code>, <code>Nat</code> - <code>Adt(AdtId, Vec&lt;MirType&gt;)</code> (nominal ADT with type parameters) - <code>Ref(Region, Box&lt;MirType&gt;, Mutability)</code> - <code>Fn(FnKind, Vec&lt;Region&gt;, Vec&lt;MirType&gt;, Box&lt;MirType&gt;)</code> (kind is <code>Fn</code>, <code>FnMut</code>, or <code>FnOnce</code>) - <code>RawPtr(Box&lt;MirType&gt;, Mutability)</code> - <code>InteriorMutable(Box&lt;MirType&gt;, IMKind)</code></p> <p><code>FnKind</code> is preserved into MIR to drive ownership semantics for calls (shared borrow vs mutable borrow vs consume); see <code>docs/spec/function_kinds.md</code>.</p> <p><code>Fn</code> carries an ordered binder list of region parameters that are bound at the function type level. Region parameters are assigned from explicit reference labels (surface <code>Ref #[label] Shared T</code> / <code>Ref #[label] Mut T</code>) or by positional occurrence when no label is given. Reusing the same label ties lifetimes together (e.g., <code>Ref #[a] Shared T -&gt; Ref #[a] Shared T</code>). The pretty printer renders the binder list as <code>fn&lt;'r0, 'r1&gt;(...) -&gt; ...</code> (or <code>fn_mut</code> / <code>fn_once</code> for other kinds).</p> <p>Elision rule: if a signature has exactly one distinct reference lifetime among its inputs, unlabeled return references are assigned that lifetime. Otherwise, return references must be labeled explicitly.</p> <p>Implementation note: the core term stores the optional label on the outer <code>Ref</code> application; MIR lowering reads it directly. Labels are preserved through core term transformations and are ignored by definitional equality.</p> <p>At each call site, these region parameters are instantiated with fresh inference regions; call constraints relate arguments and the destination using the instantiated regions (see <code>docs/spec/mir/nll-constraints.md</code>).</p>"},{"location":"spec/mir/typing/#call-operands-borrowed-callees","title":"Call Operands (Borrowed Callees)","text":"<p><code>Terminator::Call</code> uses a dedicated call operand to encode how the callee is accessed:</p> <ul> <li><code>CallOperand::Operand(Operand)</code> uses the normal operand rules (e.g.,   <code>Operand::Move</code> consumes the function value).</li> <li><code>CallOperand::Borrow(BorrowKind, Place)</code> represents a borrow of the callee   place, used for <code>Fn</code>/<code>FnMut</code> calls.</li> </ul> <p>Typing rule: - The callee place must have type <code>MirType::Fn(kind, args, ret)</code>. - <code>BorrowKind::Shared</code> is required for <code>Fn</code> calls; <code>BorrowKind::Mut</code> is required   for <code>FnMut</code> calls. - <code>FnOnce</code> calls must use <code>Operand::Move</code> rather than a borrow.</p> <p>Borrow checking treats the callee borrow as a temporary loan that covers the call, ensuring arguments and destination do not violate aliasing constraints.</p>"},{"location":"spec/mir/typing/#closure-capture-modes","title":"Closure Capture Modes","text":"<p>Lowering preserves per-capture modes inferred during elaboration: - Observational captures become shared borrows (<code>Ref Shared</code>) of the   captured place. - Mutable-borrow captures become mutable borrows (<code>Ref Mut</code>). - Consuming captures move the value into the closure environment.</p> <p>The closure local records these capture types in <code>LocalDecl::closure_captures</code> so NLL can keep the corresponding loans live for the closure\u2019s lifetime.</p>"},{"location":"spec/mir/typing/#interior-mutability-classification","title":"Interior Mutability Classification","text":"<p>Interior mutability is determined by marker traits/attributes resolved by elaboration into DefId-based flags (no string matching). Examples: - <code>InteriorMutable</code> - <code>MayPanicOnBorrowViolation</code> (RefCell-like) - <code>ConcurrencyPrimitive</code> (Mutex/Atomic family) - <code>AtomicPrimitive</code> (Atomic subtype marker)</p> <p>These markers drive: - runtime check insertion - the panic-free profile lint</p> <p>Panic-free profile restrictions: - Any interior mutability (RefCell/Mutex/Atomic) is rejected. - Indexing (including bounds checks) is rejected because it may panic. - Borrowing via <code>borrow_shared</code>/<code>borrow_mut</code> is rejected.</p>"},{"location":"spec/mir/typing/#marker-resolution-flow","title":"Marker Resolution Flow","text":"<p>Surface <code>inductive</code> declarations may include a marker list, e.g.: <code>(inductive (interior_mutable may_panic_on_borrow_violation) RefCell ...)</code>. The parser does not interpret marker names. During elaboration, each marker symbol is resolved to a DefId by looking up the corresponding definition in the environment (prelude provides the standard marker defs). The elaborator then maps those DefIds to <code>TypeMarker</code> flags attached to the <code>InductiveDecl</code>. Downstream passes (MIR lowering, NLL, lints, codegen) use these flags, not raw strings.</p> <p>Validation rules: - <code>interior_mutable</code> alone is invalid; it must be paired with a kind marker   (<code>may_panic_on_borrow_violation</code>, <code>concurrency_primitive</code>, or <code>atomic_primitive</code>). - <code>may_panic_on_borrow_violation</code> may not be combined with concurrency/atomic   markers. <code>atomic_primitive</code> may appear with <code>concurrency_primitive</code> (redundant).</p> <p>Prelude defines marker axioms explicitly (e.g., <code>(axiom unsafe interior_mutable Type)</code>), and macro expansion may only introduce unsafe/classical forms in the prelude if the macro is explicitly allowlisted in the compiler.</p>"},{"location":"spec/mir/typing/#indices-and-layout-policy","title":"Indices and Layout Policy","text":"<p>Dependent indices do not affect runtime layout. - <code>MirType::Adt(AdtId, type_args)</code> is the runtime identity. - Index arguments are erased or kept only in compile-time metadata. - If a library needs a runtime index, it must be an explicit field in the   runtime representation (e.g., <code>VecDyn&lt;A&gt; { len: usize, data: Box&lt;[A]&gt; }</code>).</p> <p>This avoids backend-dependent layout logic and matches proof erasure.</p>"},{"location":"spec/mir/typing/#sanity-rule","title":"Sanity Rule","text":"<p>Borrow checking, MIR typing, and codegen must never depend on raw strings for semantic identity. All semantics must be keyed by DefId/AdtId/CtorId/FieldId (including PackageId).</p>"}]}