;; Prelude for LeanRustLisp

(defmacro id (x) x)

;; Marker attributes (resolved during elaboration).
;; These are unsafe axioms defined explicitly in the prelude.
(axiom unsafe interior_mutable Type)
(axiom unsafe may_panic_on_borrow_violation Type)
(axiom unsafe concurrency_primitive Type)
(axiom unsafe atomic_primitive Type)
(axiom unsafe indexable Type)

;; Dynamic evaluation boundary (placeholder; no runtime semantics yet)
(axiom Dyn (sort 1))
(axiom EvalCap (sort 1))
(axiom unsafe eval (pi code Dyn (pi cap EvalCap Dyn)))

(inductive copy Nat (sort 1)
  (ctor zero Nat)
  (ctor succ (pi n Nat Nat))
)

(inductive copy Bool (sort 1)
  (ctor true Bool)
  (ctor false Bool)
)

;; Borrowing primitives (opaque; handled by MIR lowering)
(axiom Shared (sort 1))
(axiom Mut (sort 1))
(axiom Ref (pi k (sort 1) (pi A (sort 1) (sort 1))))
(axiom borrow_shared (pi {A (sort 1)} (pi x A (Ref #[r] Shared A))))
(axiom borrow_mut (pi {A (sort 1)} (pi x A (Ref #[r] Mut A))))

;; Addition (Simplified for debug)
(def add (pi n Nat (pi m Nat Nat))
  (lam n Nat
    (lam m Nat
        (match n Nat
            (case (zero) m)
            (case (succ m' ih) (succ ih))
        )
    )
  )
)

(def not (pi b Bool Bool)
  (lam b Bool
    (match b Bool
      (case (true) false)
      (case (false) true)
    )
  )
)

(def if_nat (pi c Bool (pi t Nat (pi f Nat Nat)))
  (lam c Bool
    (lam t Nat
      (lam f Nat
        (match c Nat
            (case (true) t)
            (case (false) f)
        )
      )
    )
  )
)

(def and (pi a Bool (pi b Bool Bool))
  (lam a Bool
    (lam b Bool
      (match a Bool
        (case (true) b)
        (case (false) false)
      )
    )
  )
)

(def or (pi a Bool (pi b Bool Bool))
  (lam a Bool
    (lam b Bool
      (match a Bool
        (case (true) true)
        (case (false) b)
      )
    )
  )
)

(inductive List (pi T (sort 1) (sort 1))
  (ctor nil (pi {T (sort 1)} (List T)))
  (ctor cons (pi {T (sort 1)} (pi h T (pi t (List T) (List T)))))
)

;; Indexable container types (opaque, lowered specially by MIR)
(inductive (indexable) VecDyn (pi T (sort 1) (sort 1))
  (ctor mk_vec_dyn (pi {T (sort 1)} (pi data (List T) (VecDyn T))))
)

(inductive (indexable) Slice (pi T (sort 1) (sort 1))
  (ctor mk_slice (pi {T (sort 1)} (pi data (List T) (Slice T))))
)

(inductive (indexable) Array (pi T (sort 1) (sort 1))
  (ctor mk_array (pi {T (sort 1)} (pi data (List T) (Array T))))
)

;; Indexing primitives (opaque; handled by MIR lowering)
(axiom unsafe index_vec_dyn (pi {T (sort 1)} (pi v (VecDyn T) (pi i Nat T))))
(axiom unsafe index_slice (pi {T (sort 1)} (pi v (Slice T) (pi i Nat T))))
(axiom unsafe index_array (pi {T (sort 1)} (pi v (Array T) (pi i Nat T))))

;; Interior mutability primitives
;; NOTE: RefCell/Mutex runtime checks are not implemented yet.
;; Safe definitions that mention these types are rejected; use unsafe/noncomputable until checks exist.
(inductive (interior_mutable may_panic_on_borrow_violation) RefCell (pi T (sort 1) (sort 1))
  (ctor mk_refcell (pi {T (sort 1)} (pi x T (RefCell T))))
)

(inductive (interior_mutable concurrency_primitive) Mutex (pi T (sort 1) (sort 1))
  (ctor mk_mutex (pi {T (sort 1)} (pi x T (Mutex T))))
)

(inductive (interior_mutable concurrency_primitive atomic_primitive) Atomic (pi T (sort 1) (sort 1))
  (ctor mk_atomic (pi {T (sort 1)} (pi x T (Atomic T))))
)

(def append (pi #[once] {T (sort 1)} (pi #[once] l1 (List T) (pi #[once] l2 (List T) (List T))))
  (lam #[once] {T} (sort 1)
    (lam #[once] l1 (List T)
      (lam #[once] l2 (List T)
        ((match l1 (pi #[once] l2_acc (List T) (List T))
          (case (nil) (lam #[once] l2_acc (List T) l2_acc))
          (case (cons h t ih) (lam #[once] l2_acc (List T) (cons h (ih l2_acc))))
        ) l2)
      )
    )
  )
)

;; The Computation type for partiality and effects
;; Monadic structure: ret, bind
(inductive Comp (pi A (sort 1) (sort 1))
  (ctor ret (pi A (sort 1) (pi x A (Comp A))))
  (ctor bind (pi A (sort 1) (pi B (sort 1) (pi m (Comp A) (pi f (pi x A (Comp B)) (Comp B))))))
)

(inductive Eq (pi A (sort 1) (pi a A (pi b A (sort 0))))
  (ctor refl (pi A (sort 1) (pi a A (Eq A a a))))
)
