;; Prelude for LeanRustLisp

(defmacro id (x) x)

(inductive Nat (sort 1)
  (ctor zero Nat)
  (ctor succ (pi n Nat Nat))
)

(inductive Bool (sort 1)
  (ctor true Bool)
  (ctor false Bool)
)

;; Addition (Simplified for debug)
(def add (pi n Nat (pi m Nat Nat))
  (lam n Nat
    (lam m Nat
        (match n Nat
            (case (zero) m)
            (case (succ m' ih) (succ ih))
        )
    )
  )
)

(def not (pi b Bool Bool)
  (lam b Bool
    (match b Bool
      (case (true) false)
      (case (false) true)
    )
  )
)

(def if_nat (pi c Bool (pi t Nat (pi f Nat Nat)))
  (lam c Bool
    (lam t Nat
      (lam f Nat
        (match c Nat
            (case (true) t)
            (case (false) f)
        )
      )
    )
  )
)

(def and (pi a Bool (pi b Bool Bool))
  (lam a Bool
    (lam b Bool
      (match a Bool
        (case (true) b)
        (case (false) false)
      )
    )
  )
)

(def or (pi a Bool (pi b Bool Bool))
  (lam a Bool
    (lam b Bool
      (match a Bool
        (case (true) true)
        (case (false) b)
      )
    )
  )
)

(inductive List (pi T (sort 1) (sort 1))
  (ctor nil (pi T (sort 1) (List T)))
  (ctor cons (pi T (sort 1) (pi h T (pi t (List T) (List T)))))
)

;; The Computation type for partiality and effects
;; Monadic structure: ret, bind
(inductive Comp (pi A (sort 1) (sort 1))
  (ctor ret (pi A (sort 1) (pi x A (Comp A))))
  (ctor bind (pi A (sort 1) (pi B (sort 1) (pi m (Comp A) (pi f (pi x A (Comp B)) (Comp B))))))
)

(inductive Eq (pi A (sort 1) (pi a A (pi b A (sort 0))))
  (ctor refl (pi A (sort 1) (pi a A (Eq A a a))))
)

