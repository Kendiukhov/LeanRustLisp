;; Minimal prelude for typed backend Stage 1

(defmacro id (x) x)

;; Marker attributes (resolved during elaboration).
;; These are unsafe axioms defined explicitly in the prelude.
(axiom unsafe interior_mutable Type)
(axiom unsafe may_panic_on_borrow_violation Type)
(axiom unsafe concurrency_primitive Type)
(axiom unsafe atomic_primitive Type)
(axiom unsafe indexable Type)

(inductive copy Nat (sort 1)
  (ctor zero Nat)
  (ctor succ (pi n Nat Nat))
)

(inductive copy Bool (sort 1)
  (ctor true Bool)
  (ctor false Bool)
)

;; Core reserved names needed by user programs in typed mode.
(inductive False (sort 0))

(inductive List (pi T (sort 1) (sort 1))
  (ctor nil (pi {T (sort 1)} (List T)))
  (ctor cons (pi {T (sort 1)} (pi h T (pi t (List T) (List T)))))
)

(inductive Comp (pi A (sort 1) (sort 1))
  (ctor ret (pi A (sort 1) (pi x A (Comp A))))
)

(inductive Eq (pi A (sort 1) (pi a A (pi b A (sort 0))))
  (ctor refl (pi A (sort 1) (pi a A (Eq A a a))))
)

;; Typed dynamic boundary placeholders.
(inductive copy Dyn (sort 1)
  (ctor dyn_nat (pi n Nat Dyn))
  (ctor dyn_bool (pi b Bool Dyn))
  (ctor dyn_unit Dyn)
)

(inductive copy EvalCap (sort 1)
  (ctor eval_cap EvalCap)
)

(def eval (pi code Dyn (pi cap EvalCap Dyn))
  (lam code Dyn
    (lam cap EvalCap
      code))
)

;; Print helpers (typed backend special-cases these names).
(def print_nat (pi #[fn] n Nat Nat)
  (lam #[fn] n Nat n)
)

(def print_bool (pi #[fn] b Bool Bool)
  (lam #[fn] b Bool b)
)

;; Persistent list for typed backend (monomorphic Nat list for Stage 1).
(inductive copy ListRc (sort 1)
  (ctor nil_rc ListRc)
  (ctor cons_rc (pi h Nat (pi t ListRc ListRc)))
)

(def append (pi #[fn] l1 ListRc (pi #[fn] l2 ListRc ListRc))
  (lam #[fn] l1 ListRc
    (lam #[fn] l2 ListRc
      (match l1 ListRc
        (case (nil_rc) l2)
        (case (cons_rc h t ih) (cons_rc h ih))
      )
    )
  )
)
