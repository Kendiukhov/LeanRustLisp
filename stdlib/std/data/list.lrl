;; Shared stdlib list algorithms.
;; Base API definitions such as `append` remain in prelude_api.

;; Compute list length.
(def length (pi #[once] l (List Nat) Nat)
  (lam #[once] l (List Nat)
    (match l Nat
      (case (nil) zero)
      (case (cons h t ih) (succ ih))
    )
  )
)

;; Map a Nat->Nat function over a list.
(def map (pi #[fn] f (pi #[fn] x Nat Nat) (pi #[once] l (List Nat) (List Nat)))
  (lam #[fn] f (pi #[fn] x Nat Nat)
    (lam #[once] l (List Nat)
      ((match l (pi #[fn] f_acc (pi #[fn] x Nat Nat) (List Nat))
        (case (nil) (lam #[fn] f_acc (pi #[fn] x Nat Nat) nil))
        (case (cons h t ih)
          (lam #[fn] f_acc (pi #[fn] x Nat Nat)
            (let mapped_h Nat (f_acc h)
              (let mapped_t (List Nat) (ih f_acc)
                (cons mapped_h mapped_t)
              )
            )
          )
        )
      ) f)
    )
  )
)

;; Right-associative fold.
(def foldr
  (pi #[fn] step (pi x Nat (pi acc Nat Nat))
    (pi #[once] init Nat
      (pi #[once] l (List Nat) Nat)))
  (lam #[fn] step (pi x Nat (pi acc Nat Nat))
    (lam #[once] init Nat
      (lam #[once] l (List Nat)
        (((match l (pi #[once] step_acc (pi x Nat (pi acc Nat Nat))
                     (pi #[once] init_acc Nat Nat))
          (case (nil)
            (lam #[once] step_acc (pi x Nat (pi acc Nat Nat))
              (lam #[once] init_acc Nat init_acc)
            )
          )
          (case (cons h t ih)
            (lam #[once] step_acc (pi x Nat (pi acc Nat Nat))
              (lam #[once] init_acc Nat
                (let step_h (pi acc Nat Nat) (step_acc h)
                  (let tail_acc Nat ((ih step_acc) init_acc)
                    (step_h tail_acc)
                  )
                )
              )
            )
          )
        ) step) init)
      )
    )
  )
)

;; Left-associative fold.
(def foldl
  (pi #[fn] step (pi acc Nat (pi x Nat Nat))
    (pi #[once] init Nat
      (pi #[once] l (List Nat) Nat)))
  (lam #[fn] step (pi acc Nat (pi x Nat Nat))
    (lam #[once] init Nat
      (lam #[once] l (List Nat)
        (((match l (pi #[once] step_acc (pi acc Nat (pi x Nat Nat))
                     (pi #[once] acc_acc Nat Nat))
          (case (nil)
            (lam #[once] step_acc (pi acc Nat (pi x Nat Nat))
              (lam #[once] acc_acc Nat acc_acc)
            )
          )
          (case (cons h t ih)
            (lam #[once] step_acc (pi acc Nat (pi x Nat Nat))
              (lam #[once] acc_acc Nat
                (let next_acc Nat (step_acc acc_acc h)
                  ((ih step_acc) next_acc)
                )
              )
            )
          )
        ) step) init)
      )
    )
  )
)

;; Reverse list order.
(def reverse (pi #[once] l (List Nat) (List Nat))
  (lam #[once] l (List Nat)
    (match l (List Nat)
      (case (nil) nil)
      (case (cons h t ih) (append ih (cons h nil)))
    )
  )
)

;; Keep only elements that satisfy predicate p.
(def filter (pi #[fn] p (pi #[fn] x Nat Bool) (pi #[once] l (List Nat) (List Nat)))
  (lam #[fn] p (pi #[fn] x Nat Bool)
    (lam #[once] l (List Nat)
      ((match l (pi #[fn] p_acc (pi #[fn] x Nat Bool) (List Nat))
        (case (nil) (lam #[fn] p_acc (pi #[fn] x Nat Bool) nil))
        (case (cons h t ih)
          (lam #[fn] p_acc (pi #[fn] x Nat Bool)
            (let keep_h Bool (p_acc h)
              (let filtered_t (List Nat) (ih p_acc)
                (match keep_h (List Nat)
                  (case (true) (cons h filtered_t))
                  (case (false) filtered_t)
                )
              )
            )
          )
        )
      ) p)
    )
  )
)
