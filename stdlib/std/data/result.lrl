;; Shared stdlib Result APIs.

(inductive copy Result (pi E (sort 1) (pi T (sort 1) (sort 1)))
  (ctor err (pi {E (sort 1)} (pi {T (sort 1)} (pi e E (Result E T)))))
  (ctor ok (pi {E (sort 1)} (pi {T (sort 1)} (pi x T (Result E T)))))
)

;; Map over the successful branch.
(def result_map
  (pi E (sort 1)
    (pi A (sort 1)
      (pi B (sort 1)
        (pi #[fn] f (pi #[fn] x A B)
          (pi #[once] res (Result E A) (Result E B))))))
  (lam E (sort 1)
    (lam A (sort 1)
      (lam B (sort 1)
        (lam #[fn] f (pi #[fn] x A B)
          (lam #[once] res (Result E A)
            (match res (Result E B)
              (case (err e) (err e))
              (case (ok x) (ok (f x)))
            )
          )
        )
      )
    )
  )
)

;; Map over the error branch.
(def result_map_err
  (pi E1 (sort 1)
    (pi E2 (sort 1)
      (pi A (sort 1)
        (pi #[once] f (pi #[once] e E1 E2)
          (pi #[once] res (Result E1 A) (Result E2 A))))))
  (lam E1 (sort 1)
    (lam E2 (sort 1)
      (lam A (sort 1)
        (lam #[once] f (pi #[once] e E1 E2)
          (lam #[once] res (Result E1 A)
            (match res (Result E2 A)
              (case (err e) (err (f e)))
              (case (ok x) (ok x))
            )
          )
        )
      )
    )
  )
)

;; Sequence computations that can fail.
(def result_and_then
  (pi E (sort 1)
    (pi A (sort 1)
      (pi B (sort 1)
        (pi #[once] res (Result E A)
          (pi #[once] f (pi #[once] x A (Result E B))
            (Result E B))))))
  (lam E (sort 1)
    (lam A (sort 1)
      (lam B (sort 1)
        (lam #[once] res (Result E A)
          (lam #[once] f (pi #[once] x A (Result E B))
            (match res (Result E B)
              (case (err e) (err e))
              (case (ok x) (f x))
            )
          )
        )
      )
    )
  )
)

;; Default success value when result is an error.
(def result_unwrap_or
  (pi E (sort 1)
    (pi A (sort 1)
      (pi #[fn] fallback A
        (pi #[once] res (Result E A) A))))
  (lam E (sort 1)
    (lam A (sort 1)
      (lam #[fn] fallback A
        (lam #[once] res (Result E A)
          (match res A
            (case (err e) fallback)
            (case (ok x) x)
          )
        )
      )
    )
  )
)

;; Left-biased fallback for error values.
(def result_or
  (pi E (sort 1)
    (pi A (sort 1)
      (pi #[once] lhs (Result E A)
        (pi #[once] rhs (Result E A) (Result E A)))))
  (lam E (sort 1)
    (lam A (sort 1)
      (lam #[once] lhs (Result E A)
        (lam #[once] rhs (Result E A)
          ((match lhs (pi #[once] rhs_acc (Result E A) (Result E A))
            (case (err e)
              (lam #[once] rhs_acc (Result E A)
                rhs_acc
              )
            )
            (case (ok x)
              (lam #[once] rhs_acc (Result E A)
                (ok x)
              )
            )
          ) rhs)
        )
      )
    )
  )
)

(def result_is_ok
  (pi E (sort 1)
    (pi A (sort 1)
      (pi #[once] res (Result E A) Bool)))
  (lam E (sort 1)
    (lam A (sort 1)
      (lam #[once] res (Result E A)
        (match res Bool
          (case (err e) false)
          (case (ok x) true)
        )
      )
    )
  )
)

(def result_is_err
  (pi E (sort 1)
    (pi A (sort 1)
      (pi #[once] res (Result E A) Bool)))
  (lam E (sort 1)
    (lam A (sort 1)
      (lam #[once] res (Result E A)
        (not (result_is_ok E A res))
      )
    )
  )
)
