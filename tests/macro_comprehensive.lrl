;; Comprehensive Macro System Test

;; 1. Recursive Function via 'fix' (Manual)
(partial mul (pi n Nat (pi m Nat Nat))
  (fix mul (pi n Nat (pi m Nat Nat))
    (lam n Nat
      (lam m Nat
        (match n Nat
          (case (zero) zero)
          (case (succ n_pred) (add m (app (app mul n_pred) m)))
        )
      )
    )
  )
)

(def two Nat (succ (succ zero)))
(def three Nat (succ (succ (succ zero))))
(partial six Nat (app (app mul two) three)) 

;; 2. 'letrec' Macro (Direct Template)
(defmacro letrec (name type val body)
  (let name type 
    (fix name type val) 
    body
  )
)

(partial fact_res Nat
  (letrec fact (pi n Nat Nat)
    (lam n Nat
      (match n Nat
        (case (zero) (succ zero))
        (case (succ n_pred) (app (app mul n) (app fact n_pred)))
      )
    )
    (app fact three) 
  )
)

;; 3. Macro generating Macro (Direct Template)
(defmacro make-const-macro (name val)
  (defmacro name () val)
)

(make-const-macro const_five 5)
(def val_five Nat (const_five))

;; 4. Hygiene: Shadowing (Direct Template)
(defmacro add_one_hygiene (arg)
  (app 
    (lam y Nat (add arg y))
    (succ zero)
  )
)

(def y Nat (succ (succ (succ zero)))) ;; 3
(def hygiene_res Nat (add_one_hygiene y)) ;; 3 + 1 = 4

;; 5. List Splicing (Runtime List)
(def list1 (List Nat) (cons 1 (cons 2 nil)))

(def res_splice (List Nat) 
  (quasiquote (0 (unquote-splicing list1) 5))
)

;; This should now work with match parameter instantiation fix
(partial sum_list (pi l (List Nat) Nat)
  (fix sum (pi l (List Nat) Nat)
    (lam l (List Nat)
      (match l Nat
        (case (nil) zero)
        (case (cons h t) (add h (app sum t)))
      )
    )
  )
)

(partial splice_sum Nat (app sum_list res_splice)) ;; 0+1+2+5 = 8

;; Final Sum: 6 + 6 + 5 + 4 + 8 = 29
(partial partial_sum Nat 
  (add six 
    (add fact_res 
      (add val_five 
        (add hygiene_res splice_sum)
      )
    )
  )
)

partial_sum
