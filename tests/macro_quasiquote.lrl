;; tests/macro_quasiquote.lrl
;; append is provided by the prelude

(defmacro list1 (x) 
  (quasiquote (x)))

(defmacro list2 (x y)
  (quasiquote (x y)))

(defmacro splice (l)
  (quasiquote (1 (unquote-splicing l) 4)))

(def q1 (List Nat) (list1 42))
(def q2 (List Nat) (list2 1 2))

;; q3: Splice (2 3) into (1 ... 4).
;; l should be a term that evaluates to a List Nat.
;; (cons 2 (cons 3 nil))
(def l_inner (List Nat) (cons 2 (cons 3 nil)))

;; We pass the syntax of l_inner's value?
;; If we pass `l_inner` (the symbol), `unquote-splicing` puts `l_inner` in `append`.
;; (append l_inner (4)).
;; This should work.
(def q3 (List Nat) (splice l_inner))

(def manual_q3 (List Nat) (cons 1 (append l_inner (cons 4 nil))))

q3